<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试-zk篇</title>
      <link href="/2022/10/30/%E9%9D%A2%E8%AF%95%E9%A2%98/zookeeper%E7%AF%87/"/>
      <url>/2022/10/30/%E9%9D%A2%E8%AF%95%E9%A2%98/zookeeper%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="zookeeper场景面试题"><a href="#zookeeper场景面试题" class="headerlink" title="zookeeper场景面试题"></a>zookeeper场景面试题</h1><h2 id="1-为什么ZooKeeper可以作为注册中心"><a href="#1-为什么ZooKeeper可以作为注册中心" class="headerlink" title="1.为什么ZooKeeper可以作为注册中心"></a>1.为什么<code>ZooKeeper</code>可以作为注册中心</h2><p><code>zookeeper</code>作为注册中心依赖于<strong>临时节点</strong>和<strong>watch监听机制</strong>。<br>分布式系统就无法避免对节点管理的问题(实时感知<strong>节点的状态</strong>、节点进行<strong>统一管理</strong>等等)。<br>服务注册、发现过程简述如下：</p><ul><li>服务提供者启动时，会将其服务名称，ip地址（<code>临时节点</code>）注册到配置中心。</li><li>服务消费者在<strong>第一次</strong>调用服务时，会通过注册中心找到相应服务的<code>ip地址列表</code>，并缓存到本地，以供后续使用。当消费者调用服务时，不会再去请求注册中心，而是直接通过<code>负载均衡算法</code>从<code>ip列表</code>中取一个服务提供者的服务器调用服务。</li><li>当服务提供者的<code>某台服务器宕机或下线</code>时，相应的<code>ip</code>会从服务提供者<code>ip列表</code>中移除。同时，注册中心会将新的服务<code>ip地址列表</code>发送给服务消费者机器，缓存在消费者本机（<code>watch</code>）。</li><li>当某个服务的所有服务器都下线了，那么这个服务也就下线了。</li><li>同样，当服务提供者的某台服务器上线时，注册中心会将新的服务ip地址列表发送给服务消费者机器，缓存在消费者本机（<code>watch</code>)。</li></ul><p><code>zookeeper</code>提供了“心跳检测”功能，它会定时向各个服务提供者发送一个请求( socket 长连接)，长期没有响应，服务中心就认为该服务提供者已经挂了。</p><p>作为注册中心的缺点分析</p><ul><li><strong>数据一致性需求分析</strong>：ZK是CP系统，注册中心更需要AP系统，优先保证可用性，服务保证最终一致性即可。</li><li><strong>服务规模</strong>：服务规模增长，写请求会导致整个注册中心长连接的压力；<code>ZooKeeper</code> 的写并不是可扩展的，不可以通过加节点解决水平扩展性问题。</li><li><strong>持久化需求</strong>：注册中心不一定需要<strong>持久存储</strong>和<strong>事务日志</strong>；在服务发现中，服务调用发起方更关注的是其要调用的服务的实时的地址列表和实时健康状态，每次发起调用时，并不关心要调用的服务的历史服务地址列表、过去的健康状态。</li><li><strong>健康检测问题</strong>：zk的健康检测只是简单的TCP长链接活性探测，监控检测逻辑过于简单。</li></ul><h2 id="2-什么是ZAB协议"><a href="#2-什么是ZAB协议" class="headerlink" title="2.什么是ZAB协议"></a>2.什么是ZAB协议</h2><p><code>ZAB协议</code>是<code>zookeeper</code>专门用来实现一致性的原子广播协议。</p><ul><li><strong>领导选举阶段</strong>：从<code>zookeeper</code>集群中选出一个节点作为<code>leader</code>,所以的写请求都有leader完成。</li><li><strong>数据同步阶段</strong>：集群中所有节点的数据要和<code>leader</code>节点保持一致。</li><li><strong>请求广播阶段</strong>：当<code>leader</code>节点收到写请求会利用两阶段提交来广播写请求，使得写请求像事务应用在其他阶段上执行，达到节点上数据一致。</li></ul><p><code>ZAB协议</code>，所有的<code>写操作</code>都必须通过<code>Leader</code>完成，<code>Leader</code>写入本地日志后再复制到所有的<code>Follower</code>节点。一旦<code>Leader</code>节点无法工作，<code>ZAB协议</code>能够自动从<code>Follower节点</code>中重新选出一个合适的替代者，即<code>新的Leader</code>，该过程即为<code>领导选举</code>。该领导选举过程，是ZAB协议中最为重要和复杂的过程。<br>ZAB特性</p><ul><li><strong>一致性保证</strong>：一个<code>事务 A </code>被server提交(committed)了，那么它最终一定会被<code>所有的server</code>提交;</li><li><strong>全局有序</strong>：假设有A、B两个事务，有一台server<code>先执行A再执行B</code>，那么可以保证所有<code>server</code>上<code>A始终都被在B之前执行</code>;</li><li><strong>因果有序</strong>：如果发送者在事务A提交之后再发送B,那么B必将在A之后执行;</li><li>只要大多数节点启动，系统就行正常运行;</li><li>当节点下线后重启，它必须保证能恢复到当前正在执行的事务;</li></ul><h2 id="3-请谈谈zookeeper对事物性的支持"><a href="#3-请谈谈zookeeper对事物性的支持" class="headerlink" title="3.请谈谈zookeeper对事物性的支持"></a>3.请谈谈zookeeper对事物性的支持</h2><p>zookeeper对于事务的支持主要依赖于四个函数，<code>zoo_create_op_init</code>,<code>zoo_delete_op_init</code>,<code>zoo_set_op_init</code>以及<code>zoo_check_op_init</code>。<br>每个函数都会在客户端初始化一个<code>operation</code>，客户端程序有义务保留这些<code>operations</code>。当准备好了一个事务中的所有操作后，可以使用<code>zoo_multi</code>来提交所有的操作，由<code>zookeeper</code>服务来保证这一系统操作的原子性，也就是说只要其中有一个操作失败了，相当于此次提交的任何一个草率都没有对服务端的数据造成影响。<code>zoo_multi</code>的返回值是第一个失败操作的状态信号。</p><h2 id="4-讲下zookeeper-watch机制"><a href="#4-讲下zookeeper-watch机制" class="headerlink" title="4.讲下zookeeper watch机制"></a>4.讲下zookeeper watch机制</h2><p>客户端，可以通过<code>znode</code>上设置<code>watch</code>，实现实时监听<code>znode变化</code>，<br><code>watcher</code>是一个一次性的触发器，当被设置了<code>watch</code>的数据发生了改变的时候，则服务器将这个改变发生给设置了<code>watch</code>的客户端。</p><ul><li>父节点的创建，修改，删除；</li><li>子节点的创建，删除；</li></ul><p><code>watcher机制</code>包括三个角色，<code>客户端</code>，<code>客户端的watchManager</code>以及<code>zookeeper服务器</code></p><ul><li>客户端向<code>zookeeper</code>服务器注册一个<code>watcher</code>监听；</li><li>把这个监听信息存储到<code>客户端的watchManager</code>中，</li><li>当<code>zookeeper</code>中节点发送变化时，会通知客户端，客户端会调用相应<code>watcher</code>对象中的回调方法。<code>watch回调</code>时串行同步。</li></ul><p><strong>Watcher 特性总结：</strong></p><ul><li><strong>一次性</strong>：无论是服务端还是客户端，一旦一个<code>Watcher</code>被 触 发 ，<code>Zookeeper</code> 都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力。</li><li><strong>客户端串行执行</strong>：客户端 <code>Watcher 回调</code>的过程是一个串行同步的过程。<br>轻量：</li><li><strong><code>Watcher </code>通知非常简单</strong>，只会告诉客户端<code>发生了事件</code>，而不会说明事件的具体内容。</li><li>客户端向服务端注册<code>Watcher</code>的时候，并不会把客户端真实的 Watcher 对象实体传递到服务端，仅仅是在客户端请求中使用<code> boolean 类型</code>属性进行了标记。</li><li><code>watcher event </code>异步发送 <code>watcher </code>的通知事件从 <code>server </code>发送到 <code>client </code>是异步的，这就存在一个问题，不同的客户端和服务器之间通过<code>socket</code>进行通信，由于网络延迟或其他因素导致客户端在不同的时刻监听到事件，由于 <code>Zookeeper</code> 本身提供了 <code>ordering guarantee</code>，即客户端监听事件后，才会感知它所监视 <code>znode</code>发生了变化。所以我们使用 <code>Zookeeper </code>不能期望能够监控到节点每次的变化。<code>Zookeeper</code> 只能保证最终的一致性，而无法保证强一致性。</li></ul><h2 id="5-简述zk中的观察者机制。"><a href="#5-简述zk中的观察者机制。" class="headerlink" title="5.简述zk中的观察者机制。"></a>5.简述zk中的观察者机制。</h2><p><code>zk</code>集群有三种角色，<code>leader(领导者)</code>，<code>follower(跟随着)</code>,<code>观察者（obsever）</code>。<br>观察者（obsever）的设计希望可以<code>动态的扩展zk集群又不能降低写性能</code>。</p><p>zk集群的写操作，由<code>leader</code>进行，然后以<code>类似二阶段提交</code>的方式（超过半数以上的<code>follower</code>完成写操作），则同步到<code>follower</code>和<code>obsever</code>中。如果扩展的节点时<code>follower</code>节点，则写入操作提交时需要同步更多的节点，性能会下降，<code>follow</code>节点又参与投票选举阶段。也会导致投票的成本增加。</p><ul><li><p><code>observer</code>：<strong>解决扩展问题的同时，不参与投票机制，也可以出来读请求，将写写请求转发到leader。负责接受leader同步过来的提交数据。observer节点故障不影响可用性</strong>。</p></li><li><p><strong>跨数据中心部署</strong>。把节点分散到多个数据中心可能存在网络延迟会极大的拖慢系统(<code>follower</code>节点影响)。使用<code>obsever</code>的话，更新操作都是在一个单独的数据中心完成，并发送到其他数据中心，<strong>无法完全消除数据中心之间的网络延迟</strong>，因为<code>observer</code>需要把请求转发到另一个数据中心的<code>leader</code>，并处理同步消息，网络速度极慢也会有影响的，它的优势<strong>本地读请求提供快速的响应</strong>。</p></li></ul><h2 id="6-zk场景-以及如何实现"><a href="#6-zk场景-以及如何实现" class="headerlink" title="6.zk场景,以及如何实现"></a>6.zk场景,以及如何实现</h2><p>详情见 <a href="https://blog.csdn.net/weixin_42128977/article/details/127207494">zookeeper场景篇</a></p><ul><li>数据发布&#x2F;订阅</li><li>负载均衡</li><li>命名服务</li><li>分布式协调&#x2F;通知</li><li>集群管理</li><li>Master 选举</li><li>分布式锁</li><li>分布式队列</li></ul><h2 id="7-zookeeper集群节点之间数据如何同步"><a href="#7-zookeeper集群节点之间数据如何同步" class="headerlink" title="7.zookeeper集群节点之间数据如何同步"></a>7.zookeeper集群节点之间数据如何同步</h2><ul><li>集群启动时，会进行领导者选举，选出<code>leader</code>。</li><li><code>leader</code>会和其他节点进行数据同步，采用<code>快照</code>和发生<code>diff日志</code>的方式。</li><li>客户端向<code>zookeeper服务器</code>发起写请求。<ul><li>如果服务器是<code>Follower/Observer，转发到</code>Leader&#96;服务器上。</li><li><code>leader</code>生成一个新的<code>事务Proposal</code>并为这个事务生成一个唯一的<code>ZXID</code>。<br><code>Leader</code>将写请求以<code>Proposal（事务）</code>的形式发给所有<code>Follower</code>并等待<code>ACK</code>。</li></ul></li><li><code>Follower</code>收到<code>Proposal</code>后，<code>follower节点</code>将收到的<code>Proposal</code>请求加入到<code>历史队列(history queue)</code>中，然后写入本地事务日志，根据自身情况(是否故障)，和<code>zxid</code>的有效性(是否大于本地最大<code>zxid</code>),回复是否同意该事务的<code>ACK</code>。</li><li><code>Leader</code>得到过半数的<code>ACK</code>(Leader对自己默认有一个<code>ACK</code>) ，自己先添加事务。然后向所有的<code>Follower</code>和<code>Observer</code>发送<code>Commmit</code>,当<code>follower</code>收到commit<code>请求时，会判断该事务的</code>ZXID<code>是不是比历史队列中的任何事务的</code>ZXID<code>都小，如果是则提交，如果不是则等待比它更小的事务的</code>commit(保证顺序性)&#96;。</li><li><code>Leader</code>将处理结果返回给客户端。</li></ul><h2 id="8-Eureka和zookeeper作为注册中心有什么区别"><a href="#8-Eureka和zookeeper作为注册中心有什么区别" class="headerlink" title="8.Eureka和zookeeper作为注册中心有什么区别"></a>8.Eureka和zookeeper作为注册中心有什么区别</h2><p><code>CAP</code>理论：一致性（<code>consistency</code>）、可用性（<code>Aviailability</code>）、分区容错性（<code>Partition tolerance</code>）三者只能满足其二；</p><ul><li><strong><code>AP</code><strong>：加强</strong>可用性</strong>和分<strong>区容错性</strong>，放弃立即一致性（强一致性），追求最终一致性。比如<code>eureka</code>；比如微信提现，提示两小时到账，而不是马上到账；</li><li><strong><code>CP</code><strong>：强调</strong>强一致性</strong>和<strong>分区容错性</strong>，放弃可用性，比如<code>zookeeper</code>，<code>master</code>在宕机后进行选举<code>leader</code>期间服务不饿能提供；比如夸行转账，就是立即到账，你这边转出，那边收进，才任务一个事务完成；</li><li>由于<code>ZK</code>采用的时<code>cp</code>原则，所以其<code>可用性降低</code>，这是致命的问题，<code>springcloud</code>集成的<code>eureka</code>采用的是<code>ap原则</code>，牺牲了一致性，但是保证了可用性；</li></ul><h2 id="9-zk的初始化选举"><a href="#9-zk的初始化选举" class="headerlink" title="9.zk的初始化选举"></a>9.zk的初始化选举</h2><p><code>Zookeeper</code>集群<code>leader</code>的选举:服务器初始化阶段和服务器运行期间leader挂掉情况选举机制大体相同，此处仅对服务器<strong>初始化启动期间进行说明</strong>；</p><ul><li>先后启动两台服务器，启动后两台服务器进行通信，每台服务器都试图找到<code>lead</code>，于是进入<code>leader</code>选举过程，过程如下：</li><li>每个server发出一个投票，由于初始概况，<code>server1</code>和<code>server2</code>都会将自己作为<code>leader</code>服务器来进行投票，每次投票都会包含所推举的服务器的<code>myId</code>和<code>ZXID</code>，使用（<code>myid，ZXID</code>）来表示，此时<code>server1</code>的投票为（<code>1，0</code>），<code>server2</code>的投票为（<code>2，0</code>），然后各自将这个投票发给集群中的其他机器。</li><li>接受来自各个服务器的投票。集群的每个服务器收到投票后，首先判断该投票的有效性，如<strong>检查是否是本轮投票</strong>，<strong>是否来自lookiing状态的服务器</strong>。</li><li>处理投票：针对每一个投票，服务器都需要将<strong>别人的投票</strong>和<strong>自己的投票</strong>进行PK，pk规则如下：<br>优先检查<code>ZXID</code>。<code>ZXID</code>比较大的服务器优先作为<code>leader</code>。<br>如果<code>ZXID</code>相同，那么就比较<code>myid</code>。<code>Myid</code>比较大的服务作为<code>leader服务器</code>。</li><li>统计投票。每次投票后，服务器都会统计投票信息，<strong>判断是否已经有过半机器接受相同的投票信息</strong>，对于<code>server1，server2</code>而言，都统计出集群中已经有两台机器接受了（2，0）的投票信息，此时便认为已经选举出了leader；</li><li>改变服务器状态。一旦确定了<code>leader</code>，每个服务器就会更新自己的状态，如果是<code>follower</code>，就会变成<code>Followiing</code>，如果是<code>leader</code>，就会变成<code>Leading</code>。## Redis和ZooKeeper如何实现分布式锁以及区别</li></ul><h2 id="10-ZooKeeper在这一套体系中起到什么作用？"><a href="#10-ZooKeeper在这一套体系中起到什么作用？" class="headerlink" title="10.ZooKeeper在这一套体系中起到什么作用？"></a>10.ZooKeeper在这一套体系中起到什么作用？</h2><h2 id="11-Zookeeper的原理，什么情况下会使用zookeeper，zookeeper如何监听生成的节点，zk内部是如何实现的；"><a href="#11-Zookeeper的原理，什么情况下会使用zookeeper，zookeeper如何监听生成的节点，zk内部是如何实现的；" class="headerlink" title="11.Zookeeper的原理，什么情况下会使用zookeeper，zookeeper如何监听生成的节点，zk内部是如何实现的；"></a>11.Zookeeper的原理，什么情况下会使用zookeeper，zookeeper如何监听生成的节点，zk内部是如何实现的；</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker入门篇---初始docker（一）</title>
      <link href="/2022/10/28/docker/docker%E5%85%A5%E9%97%A8/"/>
      <url>/2022/10/28/docker/docker%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="docker为什么会出现？"><a href="#docker为什么会出现？" class="headerlink" title="docker为什么会出现？"></a>docker为什么会出现？</h1><p>一款产品：开发—-&gt;运维，两套环境！应用环境，应用配置！<br><strong>常见问题</strong>：我的电脑可以运行，版本更新，导致服务不可用。<br>环境配置十分的麻烦，每个机器都需要部署环境（redis集群，es等。。。。）。<br>不能跨平台。<br>发布项目（<code>jar+mysql+redis</code>。。。），<strong>项目能不能带上环境去发布。</strong><br>传统：开发<code>jar</code>，运维来做！<br>现在：开发打包部署上线，一套流程。</p><p>以上问题，<code>docker</code>提出解决方法。<br><code>java </code>—&gt;<code>jar</code>(环境)—-&gt;（打包项目带上环境）镜像—-&gt;(<code>docker</code>)—-&gt;下载镜像—-&gt;运行。<br>docker的核心思想：**<code>隔离，打包装箱，每个箱子互相隔离</code>**。</p><p>文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a><br>仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h1 id="docker能干嘛"><a href="#docker能干嘛" class="headerlink" title="docker能干嘛"></a>docker能干嘛</h1><blockquote><p>之前的虚拟机技术</p></blockquote><p><img src="https://img-blog.csdnimg.cn/bb9bef487dcb4355a40efa42ddf4f4a3.png" alt="在这里插入图片描述"></p><p>缺点：<br>1.资源占用多；<br>2.冗余步骤多；<br>3.启动慢。</p><blockquote><p>容器化技术</p></blockquote><p><img src="https://img-blog.csdnimg.cn/39504131cff34b88a53446bcc47831d1.png" alt="在这里插入图片描述"><br>与传统的虚拟机不同：</p><ul><li><strong>传统的虚拟机</strong>：运行一个完成的操作系统，在这个系统中安装和运行。</li><li><strong>容器化</strong>：应用直接运行在宿主机的内核上，容器自己没有内核， 每个容器间，相互隔离，互不影响。</li></ul><h1 id="docker的组成"><a href="#docker的组成" class="headerlink" title="docker的组成"></a>docker的组成</h1><p><img src="https://img-blog.csdnimg.cn/07aa2018a6084712864c3b6e1b4d9b75.png" alt="在这里插入图片描述"></p><ul><li><strong>镜像(Images):</strong>   docker镜像相当于模板<code>(对象)</code>，通过镜像来创建容器。</li><li><strong>容器(Containers):</strong> docker镜像相当于<code>(对象的实例化)</code>，独立运行一个或一组应用，服务最终运行在容器里面。</li><li><strong>仓库(Registry)：</strong>存放镜像的地方。<ul><li>共有仓库</li><li>私有仓库</li></ul></li></ul><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 1.移除掉旧的版本</span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line"># 2.删除所有旧的数据</span><br><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line"></span><br><span class="line">#  3.安装依赖包</span><br><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br><span class="line"></span><br><span class="line"># 4.添加源，使用了阿里云镜像</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 5.配置缓存</span><br><span class="line">sudo yum makecache fast</span><br><span class="line"></span><br><span class="line"># 6.安装最新稳定版本的docker</span><br><span class="line">sudo yum install -y docker-ce</span><br><span class="line"></span><br><span class="line"># 7启动docker引擎并设置开机启动</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 8.配置镜像加速器</span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 9重启</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><blockquote><p>docker version</p></blockquote><p><img src="https://img-blog.csdnimg.cn/42ec1d4093584c0e96c583201e99f10b.png" alt="在这里插入图片描述"></p><h1 id="第一个dockers容器"><a href="#第一个dockers容器" class="headerlink" title="第一个dockers容器"></a>第一个dockers容器</h1><blockquote><p>docker  run hello-world</p></blockquote><p><img src="https://img-blog.csdnimg.cn/f1146c0188cd4264bf668321336f319e.png" alt="在这里插入图片描述"></p><h2 id="分析run指令"><a href="#分析run指令" class="headerlink" title="分析run指令"></a>分析run指令</h2><p><img src="https://img-blog.csdnimg.cn/cc17ada228e6450db435a394c7e69677.png" alt="在这里插入图片描述"></p><h1 id="docker是怎么工作的？"><a href="#docker是怎么工作的？" class="headerlink" title="docker是怎么工作的？"></a>docker是怎么工作的？</h1><p><code>docker</code>是一个<code>client-server</code>的服务，<code>docker</code>的守护进程运行在主机上，通过<code>socket</code>从客户端访问。<code>docker-server</code>是接受<code>docker-client</code>的指令。<br><img src="https://img-blog.csdnimg.cn/212805b5875248269600244cbcb4416c.png" alt="在这里插入图片描述"></p><h1 id="docker为什么比vm快？"><a href="#docker为什么比vm快？" class="headerlink" title="docker为什么比vm快？"></a>docker为什么比vm快？</h1><ul><li><code>docker</code>有着比虚拟机更少的抽象层;</li><li><code>docker</code>利用的是宿主机的内核，<code>vm</code>需要的是<code>Guest OS</code>。<br><img src="https://img-blog.csdnimg.cn/f44ce2c25fe54966ad8c49f206743ac6.png" alt="在这里插入图片描述"><br>所以运行容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核。</li></ul>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-消息队列</title>
      <link href="/2022/10/27/redis/redis-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2022/10/27/redis/redis-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="回顾消息队列"><a href="#回顾消息队列" class="headerlink" title="回顾消息队列"></a>回顾消息队列</h1><p>消息队列 是指利用 <strong>高效可靠</strong> 的<strong>消息传递机制</strong> 进行与平台无关的 数据交流，并基于数据通信来进行分布式系统的集成。通过提供 <strong>消息传递</strong> 和 <strong>消息排队</strong> 模型，它可以在 分布式环境 下提供 应用<strong>解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步</strong> 等等功能。<br><strong>消息队列</strong>常见的使用场景：</p><ul><li>比如电商里的下单后与会员积分、物流订单等异步解耦处理</li><li>电商促销短信下发，使用MQ来削峰填谷</li></ul><p><img src="https://img-blog.csdnimg.cn/a172068232d448c08f3150b4c69334d5.png" alt="在这里插入图片描述"><br>三个角色：<strong>生产者、消费者、消息处理中心</strong><br>异步处理模式：生产者 将消息发送到一条 虚拟的通道（消息队列）上，而无须等待响应。消费者则<strong>订阅或是监听</strong>该通道，取出消息。两者互不干扰，甚至都不需要同时在线，也就是我们说的松耦合。<br><strong>一般设计消息队列需要考虑三个需求</strong>，分别是</p><ul><li><strong>消息保序</strong>：对应消息需要有序消费的场景;</li><li><strong>处理重复消息</strong>：如网络抖动引起的同一条消息多次被投递到队列的场景;</li><li><strong>保证消息可靠性</strong>：消息从队列取出，此时客户端宕机，消息未正常消费的场景;</li></ul><p>市面上已经存在专业的 <code>MQ</code>有<code>RocketMQ</code>、<code>Kafka</code>等，为什么还需要<code>Redis</code>来自定义实现消息队列？</p><ul><li>重！需要额外的成本负担，包括运维成本、学习成本等等；所以如果你的场景足够简单，redis 完全能满足需求，可以考虑使用 redis 做消息队列</li><li>redis 是一款轻量级内存组件，相信你一定也经常使用，使用成本低。</li></ul><h1 id="Redis-实现消息队列"><a href="#Redis-实现消息队列" class="headerlink" title="Redis 实现消息队列"></a>Redis 实现消息队列</h1><p>当我们在使用一个消息队列时，希望它的功能如下：</p><ul><li><strong>支持阻塞等待拉取消息</strong>;</li><li><strong>支持发布 &#x2F; 订阅模式</strong>;</li><li><strong>消费失败，可重新消费，消息不丢失</strong>;</li><li><strong>实例宕机，消息不丢失，数据可持久化</strong>;</li><li><strong>消息可堆积</strong>;</li></ul><h2 id="List-实现消息队列"><a href="#List-实现消息队列" class="headerlink" title="List 实现消息队列"></a>List 实现消息队列</h2><p>如果你的业务需求足够简单，想把<code>Redis</code>当作队列来使用，肯定最先想到的就是使用 <code>List</code> 这个数据类型。因为 <code>List </code>底层的实现就是一个链表，在<strong>头部和尾部操作元素，时间复杂度都是 O(1)<strong>，这意味着它非常符合</strong>消息队列</strong>的模型。</p><p><strong>生产者</strong> 发布消息</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> LPUSH queue msg1</span><br><span class="line"><span class="punctuation">(</span>integer<span class="punctuation">)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> LPUSH queue msg2</span><br><span class="line"><span class="punctuation">(</span>integer<span class="punctuation">)</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>消费者</strong> 拉取消息</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> RPOP queue</span><br><span class="line"><span class="string">&quot;msg1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> RPOP queue</span><br><span class="line"><span class="string">&quot;msg2&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3858fa58551a4800bb6e657202341883.png" alt="在这里插入图片描述"></p><h3 id="list常用命令"><a href="#list常用命令" class="headerlink" title="list常用命令"></a>list常用命令</h3><table><thead><tr><th>指令</th><th>用法</th><th>描述</th></tr></thead><tbody><tr><td>LPUSH</td><td>LPUSH KEY VALUE ….</td><td>将一个或者多个value插入表头</td></tr><tr><td>RPUSH</td><td>RPUSH KEY VALUE</td><td>将一个或者多个value插入表尾</td></tr><tr><td>LPOP</td><td>LPOP  KEY</td><td>移除并返回表头元素</td></tr><tr><td>RPOP</td><td>RPOP  KEY</td><td>移除并返回表尾元素</td></tr><tr><td>BLPOP</td><td>BLPOP  KEY TIMEOUT</td><td>移除并返回表头元素，没有元素则阻塞列表直到超时或者发现列表可弹元素</td></tr><tr><td>BRPOP</td><td>BRPOP  KEY TIMEOUT</td><td>移除并返回表尾元素，没有元素则阻塞列表直到超时或者发现列表可弹元素</td></tr><tr><td>LLEN</td><td>LLEN  KEY</td><td>返回列表长度，列表不存在，则返回0，key不是列表类型，返回错误</td></tr><tr><td>LRANGE</td><td>LRANGE KEY  START STOP</td><td>返回KEY中指定区间的元素</td></tr><tr><td>RPOPLPUSH</td><td>BRPOPLPUSH   S  D</td><td>在一个原子时间内，将S弹出的元素插入到另一个列表D并返回它，</td></tr><tr><td>BRPOPLPUSH</td><td>BRPOPLPUSH   S  D TIMEOUT</td><td>在一个原子时间内，将S弹出的元素插入到另一个列表D并返回它，如果列表没有元素则阻塞列表直到超时或者发现列表可弹元素</td></tr></tbody></table><p><strong>组合</strong><br><code>LPUSH、RPOP 左进右出</code><br><code>RPUSH、LPOP 右进左出</code></p><p>如果队列为空，那消费者依旧会<strong>频繁</strong>拉取消息，这会造成<strong>CPU 空转</strong>，不仅浪费 <code>CPU </code>资源，还会对 <code>Redis</code> 造成压力。<br><strong>解决</strong>：当队列为空时，我们可以<strong>休眠</strong>一会，再去尝试拉取消息。<br>但又带来另外一个问题：当消费者在休眠等待时，有新消息来了，那消费者处理新消息就会存在<strong>延迟</strong>。<br>那如何做，既能及时处理新消息，还能避免 CPU 空转呢？<br>Redis 确实提供了<strong>阻塞式</strong>拉取消息的命令：<code>BRPOP / BLPOP</code>。客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。这种方式就节省了不必要的 <code>CPU </code>开销。</p><ul><li><code>LPUSH、BRPOP 左进右阻塞出</code></li><li><code>RPUSH、BLPOP 右进左阻塞出</code></li></ul><p>使用 <code>BRPOP</code> 这种阻塞式方式拉取消息时，还支持传入一个<strong>超时时间</strong>，如果设置为 <code>0</code>，则表示不设置超时，直到有新消息才返回，否则会在指定的超时时间后返回 <code>NULL</code>。<br>这个方案不错，<strong>既兼顾了效率，还避免了 CPU 空转问题</strong>，一举两得。</p><blockquote><p>注意：如果设置的超时时间太长，这个连接太久没有活跃过，可能会被 Redis Server 判定为无效连接，之后 Redis Server会强制把这个客户端踢下线。所以，采用这种方案，客户端要有重连机制。</p></blockquote><p>解决了消息处理不及时的问题，这种队列模型，有什么缺点？</p><ul><li><strong>不支持重复消费</strong>：消费者拉取消息后，这条消息就从 <code>List </code>中删除了，无法被其它消费者再次消费;</li><li><strong>消息丢失</strong>：消费者拉取到消息后，如果发生<strong>异常宕机</strong>，那这条消息就丢失了，缺少消息确认机制;</li><li><strong>不能满足多组生产者和消费者的业务场景</strong>。</li></ul><h3 id="list是否满足以下功能"><a href="#list是否满足以下功能" class="headerlink" title="list是否满足以下功能"></a>list是否满足以下功能</h3><table><thead><tr><th>功能</th><th>是否满足</th></tr></thead><tbody><tr><td>支持阻塞等待拉取消息</td><td>是</td></tr><tr><td>支持发布 &#x2F; 订阅模式</td><td>否</td></tr><tr><td>消费失败，可重新消费，消息不丢失</td><td>否</td></tr><tr><td>实例宕机，消息不丢失，数据可持久化</td><td>是</td></tr><tr><td>消息可堆积</td><td>是</td></tr></tbody></table><h2 id="发布-x2F-订阅模型：Pub-x2F-Sub"><a href="#发布-x2F-订阅模型：Pub-x2F-Sub" class="headerlink" title="发布&#x2F;订阅模型：Pub&#x2F;Sub"></a>发布&#x2F;订阅模型：Pub&#x2F;Sub</h2><h3 id="解决重复消费"><a href="#解决重复消费" class="headerlink" title="解决重复消费"></a>解决重复消费</h3><p>它正好可以解决前面提到的第一个问题：<strong>重复消费</strong>。<br><img src="https://img-blog.csdnimg.cn/0d5fb4e691184eeabdc2f5cc32c8f202.png" alt="在这里插入图片描述"><br>“发布&#x2F;订阅”模式包含两种角色，分别是发布者和订阅者。订阅者可以订阅一个或者多个频道(<code>channel</code>)，而发布者可以向指定的频道(<code>channel</code>)发送消息，所有订阅此频道的订阅者都会收到此消息。<br>如上图 3个消费者，使用<code> SUBSCRIBE</code> 命令，启动 3 个消费者，并订阅同一个队列。<br>Redis 通过<code>PUBLISH 、 SUBSCRIBE </code>等命令实现了<code>订阅与发布</code>模式， 这个功能提供两种信息机制， 分别是<strong>订阅&#x2F;发布到频道</strong>和<strong>订阅&#x2F;发布到模式</strong>。</p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p> <strong>订阅&#x2F;发布到频道</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="number">3</span>个消费者 都订阅一个队列</span><br><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> SUBSCRIBE queue</span><br><span class="line">Reading messages... <span class="punctuation">(</span>press Ctrl<span class="operator">-</span>C to quit<span class="punctuation">)</span></span><br><span class="line"><span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;subscribe&quot;</span></span><br><span class="line"><span class="number">2</span><span class="punctuation">)</span> <span class="string">&quot;queue&quot;</span></span><br><span class="line"><span class="number">3</span><span class="punctuation">)</span> <span class="punctuation">(</span>integer<span class="punctuation">)</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>之后，再启动一个生产者，发布一条消息。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> PUBLISH queue msg1</span><br><span class="line"><span class="punctuation">(</span>integer<span class="punctuation">)</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这时，2 个消费者就会解除阻塞，收到生产者发来的新消息。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> SUBSCRIBE queue</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 收到新消息</span><br><span class="line"><span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;message&quot;</span>   <span class="operator">/</span><span class="operator">/</span>消息的种类</span><br><span class="line"><span class="number">2</span><span class="punctuation">)</span> <span class="string">&quot;queue&quot;</span>  <span class="operator">/</span><span class="operator">/</span>始发频道的名称</span><br><span class="line"><span class="number">3</span><span class="punctuation">)</span> <span class="string">&quot;msg1&quot;</span>  <span class="operator">/</span><span class="operator">/</span>实际的消息</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>订阅&#x2F;发布到模式</strong></p><p>Pub&#x2F;Sub 还提供了<strong>匹配订阅</strong>模式，允许消费者根据一定规则，订阅<strong>多个</strong>自己感兴趣的队列。<br>&#x2F;&#x2F; 订阅符合规则的队列。<br><img src="https://img-blog.csdnimg.cn/64164aca456c40aa9af5bd0fc224f738.png" alt="在这里插入图片描述"></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> PSUBSCRIBE queue.<span class="operator">*</span></span><br><span class="line">Reading messages... <span class="punctuation">(</span>press Ctrl<span class="operator">-</span>C to quit<span class="punctuation">)</span></span><br><span class="line"><span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;psubscribe&quot;</span></span><br><span class="line"><span class="number">2</span><span class="punctuation">)</span> <span class="string">&quot;queue.*&quot;</span></span><br><span class="line"><span class="number">3</span><span class="punctuation">)</span> <span class="punctuation">(</span>integer<span class="punctuation">)</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这里的消费者，订阅了 <code>queue.*</code> 相关的队列消息。<br>之后，生产者分别向 <code>queue.p1 </code>和 <code>queue.p2</code> 发布消息。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> PUBLISH queue.p1 msg1</span><br><span class="line"><span class="punctuation">(</span>integer<span class="punctuation">)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> PUBLISH queue.p2 msg2</span><br><span class="line"><span class="punctuation">(</span>integer<span class="punctuation">)</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这时再看消费者，它就可以接收到这 2 个生产者的消息了。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> PSUBSCRIBE queue.<span class="operator">*</span></span><br><span class="line">Reading messages... <span class="punctuation">(</span>press Ctrl<span class="operator">-</span>C to quit<span class="punctuation">)</span></span><br><span class="line">...</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 来自queue.p1的消息</span><br><span class="line"><span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;pmessage&quot;</span></span><br><span class="line"><span class="number">2</span><span class="punctuation">)</span> <span class="string">&quot;queue.*&quot;</span></span><br><span class="line"><span class="number">3</span><span class="punctuation">)</span> <span class="string">&quot;queue.p1&quot;</span></span><br><span class="line"><span class="number">4</span><span class="punctuation">)</span> <span class="string">&quot;msg1&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 来自queue.p2的消息</span><br><span class="line"><span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;pmessage&quot;</span></span><br><span class="line"><span class="number">2</span><span class="punctuation">)</span> <span class="string">&quot;queue.*&quot;</span></span><br><span class="line"><span class="number">3</span><span class="punctuation">)</span> <span class="string">&quot;queue.p2&quot;</span></span><br><span class="line"><span class="number">4</span><span class="punctuation">)</span> <span class="string">&quot;msg2&quot;</span></span><br></pre></td></tr></table></figure><p><code>Pub/Sub</code> 最大的优势就是，<strong>支持多组生产者、消费者处理消息</strong>。<br>讲完了它的优点，那它有什么缺点呢？</p><h3 id="Pub-x2F-Sub-最大问题是：丢数据"><a href="#Pub-x2F-Sub-最大问题是：丢数据" class="headerlink" title="Pub&#x2F;Sub 最大问题是：丢数据"></a>Pub&#x2F;Sub 最大问题是：丢数据</h3><p>其实，Pub&#x2F;Sub 最大问题是：<strong>丢数据。</strong><br>如果发生以下场景，就有可能导致数据丢失：</p><ul><li><strong>消费者下线</strong></li><li><strong>Redis 宕机</strong></li><li><strong>消息堆积</strong></li></ul><h4 id="Redis-宕机"><a href="#Redis-宕机" class="headerlink" title="Redis 宕机"></a>Redis 宕机</h4><p> <code>Pub/Sub </code>在实现时非常简单，<strong>它没有基于任何数据类型</strong>，也没有做任何的数据存储,也不具备<strong>数据持久化</strong>的能力。<code>Pub/Sub </code>的相关操作，不会写入到 <code>RDB</code> 和 <code>AOF</code> 中，当 <code>Redis</code> 宕机重启，<code>Pub/Sub</code> 的数据也会全部丢失，它只是单纯地为<strong>生产者、消费者</strong>建立数据转发通道，把符合规则的数据，从一端转发到另一端。整个过程中，没有任何的数据存储，一切都是<strong>实时转发</strong>的。当你在使用 <code>Pub/Sub </code>时，一定要注意：<strong>消费者必须先订阅队列，生产者才能发布消息，否则消息会丢失。</strong></p><h4 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h4><p>我们来看 <code>Pub/Sub </code>在处理消息积压时，为什么也会丢数据？</p><p><strong>当消费者的速度，跟不上生产者时，就会导致数据积压的情况发生。</strong><br>如果采用<code> List</code> 当作队列，消息积压时，会导致这个链表很长，最直接的影响就是，<code>Redis </code>内存会持续增长，直到消费者把所有数据都从链表中取出。但<code> Pub/Sub</code> 的处理方式却不一样，当消息积压时，有可能会导致<code>消费失败</code>和<code>消息丢失</code>！<br>每个消费者订阅一个队列时，<code>Redis </code>都会在 Server 上给这个消费者在分配一个<code>缓冲区</code>，这个缓冲区其实就是一块内存。当生产者发布消息时，<code>Redis</code> 先把消息写到对应消费者的缓冲区中。之后，消费者不断地从缓冲区读取消息，处理消息。因为这个<strong>缓冲区其实是有上限的</strong>，如果消费者拉取消息很慢，就会造成生产者发布到缓冲区的<strong>消息开始积压</strong>，缓冲区内存持续增长。如果<strong>超过了缓冲区配置的上限</strong>，此时，<code>Redis</code> 就会强制把这个<strong>消费者踢下线</strong>。这时消费者就会消费失败，也会<strong>丢失数据</strong>。<br>从这里你应该可以看出，<strong>List 其实是属于拉模型，而 Pub&#x2F;Sub 其实属于推模型</strong>。</p><p><strong>总结一下 Pub&#x2F;Sub 的优缺点：</strong></p><p><strong>优点</strong></p><ol><li><strong>支持发布 &#x2F; 订阅，支持多组生产者、消费者处理消息 ;</strong></li></ol><p><strong>缺点</strong></p><ol><li>消费者下线，数据会丢失 ;</li><li>不支持数据持久化，Redis 宕机，数据也会丢失;</li><li>消息堆积，缓冲区溢出，消费者会被强制踢下线，数据也会丢失;</li><li><code>Pub/Sub </code>从缓冲区取走数据之后，数据就从 Redis 缓冲区删除了，消费者发生异常，自然也无法再次重新消费。</li></ol><h4 id="Pub-x2F-Sub-是否满足以下功能"><a href="#Pub-x2F-Sub-是否满足以下功能" class="headerlink" title="Pub&#x2F;Sub 是否满足以下功能"></a>Pub&#x2F;Sub 是否满足以下功能</h4><table><thead><tr><th>功能</th><th>是否满足</th></tr></thead><tbody><tr><td>支持阻塞等待拉取消息</td><td>否</td></tr><tr><td>支持发布 &#x2F; 订阅模式</td><td>是</td></tr><tr><td>消费失败，可重新消费，消息不丢失</td><td>否</td></tr><tr><td>实例宕机，消息不丢失，数据可持久化</td><td>否</td></tr><tr><td>消息可堆积</td><td>否</td></tr></tbody></table><h2 id="趋于成熟的队列：Stream"><a href="#趋于成熟的队列：Stream" class="headerlink" title="趋于成熟的队列：Stream"></a>趋于成熟的队列：Stream</h2><h3 id="基本指令："><a href="#基本指令：" class="headerlink" title="基本指令："></a>基本指令：</h3><ul><li>xadd:追加消息</li><li>xdel:删除信息，这里的删除是设置标志位，不影响消息总长度</li><li>xrange 获取stream的消息列表（会过滤已经删除的信息）</li><li>xlen：获取信息长度</li><li>del：删除整个stream消息列表的种的所有信息（不会删除信息，只是给消息做个标记位）</li><li>xread: 可以将stream当作队列来使用，xread可以从队列中获取消息</li></ul><p>生产者发布 2 条消息：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">*</span>表示让Redis自动生成消息ID 这个消息 ID 的格式是「时间戳<span class="operator">-</span>自增序号」。</span><br><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> XADD queue <span class="operator">*</span> name zhangsan</span><br><span class="line"><span class="string">&quot;1618469123380-0&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> XADD queue <span class="operator">*</span> name lisi</span><br><span class="line"><span class="string">&quot;1618469127777-0&quot;</span></span><br></pre></td></tr></table></figure><p>消费者拉取消息：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 从开头读取<span class="number">5</span>条消息，<span class="number">0</span><span class="operator">-</span><span class="number">0</span>表示从开头读取</span><br><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> XREAD COUNT <span class="number">5</span> STREAMS queue <span class="number">0</span><span class="operator">-</span><span class="number">0</span></span><br><span class="line"><span class="number">1</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;queue&quot;</span></span><br><span class="line">   <span class="number">2</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;1618469123380-0&quot;</span></span><br><span class="line">         <span class="number">2</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;name&quot;</span></span><br><span class="line">            <span class="number">2</span><span class="punctuation">)</span> <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">      <span class="number">2</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;1618469127777-0&quot;</span></span><br><span class="line">         <span class="number">2</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;name&quot;</span></span><br><span class="line">            <span class="number">2</span><span class="punctuation">)</span> <span class="string">&quot;lisi&quot;</span></span><br></pre></td></tr></table></figure><p>如果想继续拉取消息，需要传入上一条消息的 ID：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> XREAD COUNT <span class="number">5</span> STREAMS queue <span class="number">1618469127777</span><span class="operator">-</span><span class="number">0</span></span><br><span class="line"><span class="punctuation">(</span>nil<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h3 id="Stream-是否支持「阻塞式」拉取消息？"><a href="#Stream-是否支持「阻塞式」拉取消息？" class="headerlink" title="Stream 是否支持「阻塞式」拉取消息？"></a>Stream 是否支持「阻塞式」拉取消息？</h3><p>可以的，在读取消息时，只需要增加 <code>BLOCK</code> 参数即可。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> BLOCK <span class="number">0</span> 表示阻塞等待，不设置超时时间</span><br><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> XREAD COUNT <span class="number">5</span> BLOCK <span class="number">0</span> STREAMS queue <span class="number">1618469127777</span><span class="operator">-</span><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="Stream-是否支持发布-x2F-订阅模式？"><a href="#Stream-是否支持发布-x2F-订阅模式？" class="headerlink" title="Stream 是否支持发布 &#x2F; 订阅模式？"></a>Stream 是否支持发布 &#x2F; 订阅模式？</h3><ul><li>XGROUP：创建消费者组</li><li>XREADGROUP：在指定消费组下，开启消费者拉取消息</li></ul><p>首先，生产者依旧发布 2 条消息：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> XADD queue <span class="operator">*</span> name zhangsan</span><br><span class="line"><span class="string">&quot;1618470740565-0&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> XADD queue <span class="operator">*</span> name lisi</span><br><span class="line"><span class="string">&quot;1618470743793-0&quot;</span></span><br></pre></td></tr></table></figure><p>之后，我们想要开启 2 组消费者处理同一批数据，就需要创建 2 个消费者组：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 创建消费者组<span class="number">1</span>，<span class="number">0</span><span class="operator">-</span><span class="number">0</span>表示从头拉取消息</span><br><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> XGROUP CREATE queue group1 <span class="number">0</span><span class="operator">-</span><span class="number">0</span></span><br><span class="line">OK</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 创建消费者组<span class="number">2</span>，<span class="number">0</span><span class="operator">-</span><span class="number">0</span>表示从头拉取消息</span><br><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> XGROUP CREATE queue group2 <span class="number">0</span><span class="operator">-</span><span class="number">0</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>消费者组创建好之后，我们可以给每个消费者组下面挂一个消费者，让它们分别处理同一批数据。<br>第一个消费组开始消费：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> group1的consumer开始消费，`&gt;`表示拉取最新数据</span><br><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> XREADGROUP GROUP group1 consumer COUNT <span class="number">5</span> STREAMS queue <span class="operator">&gt;</span></span><br><span class="line"><span class="number">1</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;queue&quot;</span></span><br><span class="line">   <span class="number">2</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;1618470740565-0&quot;</span></span><br><span class="line">         <span class="number">2</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;name&quot;</span></span><br><span class="line">            <span class="number">2</span><span class="punctuation">)</span> <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">      <span class="number">2</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;1618470743793-0&quot;</span></span><br><span class="line">         <span class="number">2</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;name&quot;</span></span><br><span class="line">            <span class="number">2</span><span class="punctuation">)</span> <span class="string">&quot;lisi&quot;</span></span><br></pre></td></tr></table></figure><p>同样地，第二个消费组开始消费：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> group2的consumer开始消费，<span class="operator">&gt;</span>表示拉取最新数据</span><br><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> XREADGROUP GROUP group2 consumer COUNT <span class="number">5</span> STREAMS queue <span class="operator">&gt;</span></span><br><span class="line"><span class="number">1</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;queue&quot;</span></span><br><span class="line">   <span class="number">2</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;1618470740565-0&quot;</span></span><br><span class="line">         <span class="number">2</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;name&quot;</span></span><br><span class="line">            <span class="number">2</span><span class="punctuation">)</span> <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">      <span class="number">2</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;1618470743793-0&quot;</span></span><br><span class="line">         <span class="number">2</span><span class="punctuation">)</span> <span class="number">1</span><span class="punctuation">)</span> <span class="string">&quot;name&quot;</span></span><br><span class="line">            <span class="number">2</span><span class="punctuation">)</span> <span class="string">&quot;lisi&quot;</span></span><br></pre></td></tr></table></figure><p>我们可以看到，这 2 组消费者，都可以获取同一批数据进行处理了。<br>这样一来，就达到了多组消费者订阅消费的目的。</p><h3 id="消息处理时异常，Stream-能否保证消息不丢失，重新消费？"><a href="#消息处理时异常，Stream-能否保证消息不丢失，重新消费？" class="headerlink" title="消息处理时异常，Stream 能否保证消息不丢失，重新消费？"></a>消息处理时异常，Stream 能否保证消息不丢失，重新消费？</h3><p>除了上面拉取消息时用到了<code>消息 ID</code>，这里为了保证<strong>重新消费</strong>，也要用到这个<code>消息 ID</code>。<br>当一组消费者处理完消息后，需要执行 <code>XACK</code> 命令告知<code> Redis</code>，这时 <code>Redis </code>就会把这条消息标记为处理完成。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> group1下的 <span class="number">1618472043089</span><span class="operator">-</span><span class="number">0</span> 消息已处理完成</span><br><span class="line"><span class="number">127.0</span>.0.1<span class="operator">:</span><span class="number">6379</span><span class="operator">&gt;</span> XACK queue group1 <span class="number">1618472043089</span><span class="operator">-</span><span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果消费者异常宕机，肯定不会发送<code> XACK</code>，那么<code>Redis</code>就会依旧保留这条消息。<br>待这组消费者重新上线后，<code>Redis </code>就会把之前没有处理成功的数据，重新发给这个消费者。这样一来，即使消费者异常，也不会丢失数据了。</p><h3 id="Stream-数据会写入到-RDB-和-AOF-做持久化吗？"><a href="#Stream-数据会写入到-RDB-和-AOF-做持久化吗？" class="headerlink" title="Stream 数据会写入到 RDB 和 AOF 做持久化吗？"></a>Stream 数据会写入到 RDB 和 AOF 做持久化吗？</h3><p><code>Stream </code>是新增加的数据类型，它与其它数据类型一样，每个写操作，也都会写入到<code>RDB</code>和 <code>AOF</code> 中。<br>我们只需要配置好<strong>持久化策略</strong>，这样的话，就算 <code>Redis </code>宕机重启，<code>Stream</code> 中的数据也可以从 <code>RDB </code>或 <code>AOF</code> 中恢复回来。</p><h3 id="消息堆积时，Stream-是怎么处理的？"><a href="#消息堆积时，Stream-是怎么处理的？" class="headerlink" title="消息堆积时，Stream 是怎么处理的？"></a>消息堆积时，Stream 是怎么处理的？</h3><p>其实，当消息队列发生消息堆积时，一般只有 2 个解决方案：</p><ul><li><strong>生产者限流：避免消费者处理不及时，导致持续积压</strong></li><li><strong>丢弃消息：中间件丢弃旧消息，只保留固定长度的新消息</strong><br>而 Redis 在实现 <code>Stream</code> 时，采用了第 2 个方案。在发布消息时，你可以指定队列的最大长度，<strong>防止队列积压导致内存爆炸</strong>。这么来看，<code>Stream</code> 在消息积压时，如果指定了最大长度，还是有可能<strong>丢失消息的</strong>。</li></ul><h3 id="Stream-是否满足以下功能"><a href="#Stream-是否满足以下功能" class="headerlink" title="Stream 是否满足以下功能"></a>Stream 是否满足以下功能</h3><table><thead><tr><th>功能</th><th>是否满足</th></tr></thead><tbody><tr><td>支持阻塞等待拉取消息</td><td>是</td></tr><tr><td>支持发布 &#x2F; 订阅模式</td><td>是</td></tr><tr><td>消费失败，可重新消费，消息不丢失</td><td>是</td></tr><tr><td>实例宕机，消息不丢失，数据可持久化</td><td>是</td></tr><tr><td>消息可堆积</td><td>否</td></tr></tbody></table><h2 id="与专业的消息队列对比"><a href="#与专业的消息队列对比" class="headerlink" title="与专业的消息队列对比"></a>与专业的消息队列对比</h2><p>其实，一个专业的消息队列，必须要做到两大块：</p><ul><li>消息不丢</li><li>消息可堆积</li></ul><p>消息是否会发生丢失，其重点也就在于以下 3 个环节：</p><ul><li>生产者会不会丢消息？</li><li>消费者会不会丢消息？</li><li>队列中间件会不会丢消息？</li></ul><h3 id="生产者会不会丢消息？"><a href="#生产者会不会丢消息？" class="headerlink" title="生产者会不会丢消息？"></a>生产者会不会丢消息？</h3><ul><li>消息没发出去：网络故障或其它问题导致发布失败，中间件直接返回失败</li><li>不确定是否发布成功：网络问题导致发布超时，可能数据已发送成功，但读取响应结果超时了</li></ul><p>如果是情况 1，消息根本没发出去，那么重新发一次就好了。<br>如果是情况 2，生产者没办法知道消息到底有没有发成功？所以，为了避免消息丢失，它也只能继续重试，直到发布成功为止。</p><blockquote><p>生产者一般会设定一个最大重试次数，超过上限依旧失败，需要记录日志报警处理。</p></blockquote><p>也就是说，生产者为了避免消息丢失，只能采用失败重试的方式来处理。从这点看，生产者不丢消息与整个中间件无关，完全是业务实现的问题，是否考虑了以上的异常情况。</p><h3 id="消费者会不会丢消息？"><a href="#消费者会不会丢消息？" class="headerlink" title="消费者会不会丢消息？"></a>消费者会不会丢消息？</h3><p>这种情况就是我们前面提到的，消费者拿到消息后，还没处理完成，就异常宕机了，那消费者还能否重新消费失败的消息？<br>要解决这个问题，消费者在处理完消息后，必须告知队列中间件，队列中间件才会把标记已处理，否则仍旧把这些数据发给消费者。<br>这种方案需要消费者和中间件互相配合，才能保证消费者这一侧的消息不丢。<br>无论是 <code>Redis</code> 的 <code>Stream</code>，还是专业的队列中间件，例如 <code>RabbitMQ、Kafka</code>，其实都是这么做的。<br>所以，从这个角度来看，<code>Redis </code>也是合格的。</p><h3 id="中间丢失消息的情况"><a href="#中间丢失消息的情况" class="headerlink" title="中间丢失消息的情况"></a>中间丢失消息的情况</h3><p>这其实就是中间件的实现方式了，redis存在两个风险点：</p><ul><li><code>aof</code>周期性刷盘，这个过程是<strong>异步的</strong>，<strong>有丢失</strong>的风险；</li><li><strong>主从复制也是异步</strong>的，主从切换时，也存在丢失数据的可能。</li></ul><p>基于以上原因我们可以看到，<code>Redis </code>本身的无法保证严格的数据完整性。<br>而<code>kafka、rabbitMQ</code>则是通过一次写入，多个节点同时<code>ack</code>，才认为写入成功，进一步加强了消息的可靠性。</p><h3 id="消息积压怎么办？"><a href="#消息积压怎么办？" class="headerlink" title="消息积压怎么办？"></a>消息积压怎么办？</h3><p>因为 <code>Redis</code> 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致<code>Redis</code>的内存持续增长，如果超过机器内存上限，就会面临被 <strong>OOM</strong> 的风险。<br>所以，<code>Redis</code> 的 <code>Stream </code>提供了可以指定队列最大长度的功能，就是为了避免这种情况发生。<br>但 <code>Kafka、RabbitMQ</code> 这类消息队列就不一样了，它们的数据都会存储在磁盘上，磁盘的成本要比内存小得多，当消息积压时，无非就是多占用一些磁盘空间，相比于内存，在面对积压时也会更加坦然。<br>综上，我们可以看到，把 <code>Redis</code> 当作队列来使用时，始终面临的 2 个问题：</p><ul><li><strong>Redis 本身可能会丢数据</strong></li><li><strong>面对消息积压，Redis 内存资源紧张</strong></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://img-blog.csdnimg.cn/1ed740d7173c421ea19502ae8cc658d7.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis高级特性—HyperLoglog解决统计问题</title>
      <link href="/2022/10/27/redis/Redis%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E2%80%94HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/"/>
      <url>/2022/10/27/redis/Redis%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E2%80%94HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>HyperLogLog</code>是用来做<strong>基数统计</strong>的算法，<code>HyperLogLog </code>的优点是，在输入元素的数量或者<strong>体积非常非常大</strong>时，计算基数所需的空间总是<code>固定 </code>的、并且是<code>很小</code>的。在 <code>Redis </code>里面，每个<code> HyperLogLog</code> 键只需要花费 <code>12 KB</code> 内存，就可以计算接近 <code>2^64 </code>个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为<code> HyperLogLog</code> 只会根据输入元素来计算基数，而<code>不会储存输入元素本身</code>，所以 <code>HyperLogLog</code> 不能像集合那样，返回输入的各个元素。但要注意，<code>HyperLogLog </code>是统计规则是基于概率完成的，不是非常准确，标准误算率是 <code>0.81%</code>。</p><h1 id="关于基数统计"><a href="#关于基数统计" class="headerlink" title="关于基数统计"></a>关于基数统计</h1><p>基数统计通常是用来统计一个集合中<strong>不重复</strong>的元素个数。<br>思考这样的一个场景： 开发维护一个大型的网站，有一天老板找产品经理要网站上每个网页的<code> UV</code>(每个用户每天只记录一次)，然后让你来开发这个统计模块，你会如何实现？</p><ul><li>统计<code>PV(点一次记一次)</code>，可以给每个页面一个单独的<code>redis</code>计数器。</li><li>统计<code>UV(每个用户每天只记录一次)</code><ul><li>每个页面一个<code>zset</code>保存用户<code>ID</code>，存储空间大，聚合麻烦（·老板知道估计打死·。。。）；</li><li><code>bitmap</code>:用位数组来表示用户<code>ID</code>是否出现，每个用户<code>ID</code>对应一位，所需的总内存为<code>n bit</code>。能大大减少内存占用且位操作迅速，统计1亿个数据的基数值，大约需要内存<code>100000000/8/1024/1024 ≈ 12M</code>。统计<code>一个对象</code>的基数值需要<code>12M</code>，如果统计<code>10000</code>个对象，就需要将近<code>120G</code>；</li></ul></li><li>概率算法 <code>HyperLogLog</code>：使用<strong>概率算法</strong>算是一个不错的解决方案。概率算法不直接存储数据集合本身，通过一定的概率统计方法预估基数值，这种方法可以<strong>大大节省内存</strong>，同时保证<strong>误差控制在一定范围内</strong>。</li></ul><h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><h2 id="pfadd-添加"><a href="#pfadd-添加" class="headerlink" title="pfadd 添加"></a>pfadd 添加</h2><ul><li>影响基数估值则返回1否则返回0.若key不存在则创建</li><li>时间复杂度O(1)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd web:index user1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li></ul><h2 id="pfcount-获得基数值"><a href="#pfcount-获得基数值" class="headerlink" title="pfcount 获得基数值"></a>pfcount 获得基数值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;pfadd web:index user1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount web:index</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h2 id="pfmerge-合并多个key"><a href="#pfmerge-合并多个key" class="headerlink" title="pfmerge 合并多个key"></a>pfmerge 合并多个key</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;pfadd web:index:1 user1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount web:index:1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd web:index:2 user2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount web:index:2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfmerge web:index web:index:1 web:index:2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount web:index </span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>百万级网页 <code>UV </code>计数</li><li>统计每日访问 <code>IP</code> 数</li><li>统计在线百万级用户数</li><li>统计用户每天搜索不同词条的个数</li></ul><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>基数不大，数据量不大就用不上，会有点大材小用浪费空间;</li><li>有局限性，就是只能统计基数数量，而没办法去知道具体的内容是什么;</li><li>和<code>bitmap</code>相比，属于两种特定统计情况，简单来说，<code>HyperLogLog </code>去重比<code> bitmap</code> 方便很多;</li><li>一般可以<code>bitmap</code>和<code>hyperloglog</code>配合使用，<code>bitmap</code>标识哪些用户活跃，<code>hyperloglog</code>计数;</li></ul><h1 id="pf-的内存占用为什么是-12k-？"><a href="#pf-的内存占用为什么是-12k-？" class="headerlink" title="pf 的内存占用为什么是 12k ？"></a>pf 的内存占用为什么是 12k ？</h1><p>在 <code>Redis </code>的 <code>HyperLogLog</code>实现中用到的是 <code>16384 </code>个桶，也就是 <code>2^14</code>，每个桶的 <code>maxbits</code> 需要 <code>6 </code>个 <code>bits</code> 来存储，最大可以表示 <code>maxbits</code>&#x3D;<code>63</code>，于是总共占用内存就是 <code>2^14 * 6 / 8 = 12k</code>字节。</p><h1 id="个人总结："><a href="#个人总结：" class="headerlink" title="个人总结："></a>个人总结：</h1><ul><li>目的是做<strong>基数统计</strong>，故不是集合，不会保存元数据，只记录<strong>数量</strong>而不是数值;</li><li>耗空间极小，支持输入非常体积的数据量,最终数值存在一定误差;</li><li>redis中每个<code>hyperloglog key</code>占用了<code>12K</code>的内存用于标记基数;</li><li><code>pfadd</code>命令并不会一次性分配<code>12k</code>内存，而是随着基数的增加而逐渐增加内存分配；而<code>pfmerge</code>操作则会将<code>source key</code>合并后存储在<code>12k</code>大小的<code>key</code>中，这由<code>hyperloglog</code>合并操作的原理（两个hyperloglog&#96;合并时需要单独比较每个桶的值）可以很容易理解。</li><li>误差说明：<code>Redis </code>对 <code>HyperLogLog</code> 的存储进行了优化，在计数比较小时，它的存储空间采用<strong>稀疏矩阵存储，空间占用很小，仅仅在计数慢慢变大，稀疏矩阵占用空间渐渐超过了阈值时才会一次性转变成稠密矩</strong>阵，才会占用 <code>12k </code>的空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>别问我内存满了怎么办</title>
      <link href="/2022/10/27/redis/redis%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-bitmap/"/>
      <url>/2022/10/27/redis/redis%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-bitmap/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我们平时开发过程中，会有一些 <code>bool </code>型数据需要存取，比如用户一年的签到记录，签了是 <code>1</code>，没签是 <code>0</code>，要记录 <code>365</code> 天。如果使用普通的<code> key/value</code>，每个用户要记录<code> 365</code>个，当用户上亿的时候，需要的存储空间是惊人的。为了解决这个问题，Redis 提供了<strong>位图</strong>数据结构，这样每天的签到记录只占据一个位，<code>365</code> 天就是<code> 365</code> 个位，<code>46</code>个字节 (一个稍长一点的字符串) 就可以完全容纳下，这就大大节约了存储空间。</p><h1 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h1><p>即位图，是一串连续的<code>二进制数组</code>（0和1），可以通过<code>偏移量（offset）</code>定位元素。<code>BitMap</code>通过最小的单位<code>bit</code>来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为O(1)。由于 <code>bit </code>是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些<code>数据量大</code>且使用<code>二值统计</code>的场景。<br><img src="https://img-blog.csdnimg.cn/3ee6b236b5c547b7950a6a860e66880e.png" alt="在这里插入图片描述"><br><strong><code>bitmap </code>并不是一种数据结构，实际上它就是字符串，但是可以对字符串的位进行操作。</strong></p><p>从以下结果可以看出 Bitmaps实际上存的就是String</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set hello big</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; getbit hello 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit hello 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit hello 2</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/e642cbd4bb8b4182a58da81cf8636d87.png" alt="在这里插入图片描述"></p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="setbit"><a href="#setbit" class="headerlink" title="setbit"></a>setbit</h2><p>setbit key offset value：  &#x2F;&#x2F;给对应的位设置值</p><p>比如今天有用户<code>3、8、</code>登录了网站，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setbit user:login:200517 3 1</span><br><span class="line">setbit user:login:200517 8 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>开发提示</strong>：很多应用<code>id</code>都不是从<code>1</code>开始，有许多是从指定数字开始的，比如<code>1001</code>、<code>10001</code>开始。对于这些，我们在设置的时候可以先减去初始值，防止浪费空间。</p><h2 id="getbit"><a href="#getbit" class="headerlink" title="getbit"></a>getbit</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset    //用于获取Redis中指定key对应的值，中对应offset的bit</span><br></pre></td></tr></table></figure><p>如果我想知道今天<code>8</code>号用户和<code>10</code>号用户是否登录过，则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit user:login:200517 8</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit user:view:200517 10</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h2 id="bitcount"><a href="#bitcount" class="headerlink" title="bitcount"></a>bitcount</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount key [start end]   //用于统计字符串被设置为1的bit数</span><br></pre></td></tr></table></figure><p>我想知道今天有多少用户登陆过了，则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount user:login:200517</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitop and/or/xor/not  destkey   key  [key …]    用于对多个key求逻辑与/逻辑或/逻辑异或/逻辑非</span><br></pre></td></tr></table></figure><p><code>bitop</code>命令可以对多个<code>bitmaps</code>做交集（<code>and</code>)、并集（<code>or</code>）、非（<code>not</code>）、异或（<code>xor</code>），并将操作结果存放在destkey中。</p><p>如果想知道连续三天都登陆过的用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitop and three:and user:login:200517 user:login:200518 user:view:200519</span><br><span class="line">127.0.0.1:6379&gt; bitcount three:and</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>通过<code> bitcount</code>可以很快速的统计，比传统的关系型数据库效率高很多。</p><ul><li><strong>统计年活跃用户数量</strong><ul><li>用户的<code>ID</code>作为<code>offset</code>，当用户在一年内访问过网站，就将对应<code>offset</code>的<code>bit</code>值设置为“1”；</li><li>通过<code>bitcount </code>来统计一年内访问过网站的用户数量</li></ul></li><li><strong>统计三天内活跃用户数量</strong><ul><li>时间字符串作为<code>key</code>，比如 <code>“190108：active“ “190109：active”“190110：active” </code>；</li><li>用户的<code>ID</code>就可以作为<code>offset</code>，当用户访问过网站，就将对应<code>offset</code>的<code>bit</code>值设置为“1”；</li></ul></li><li><strong>统计在线人数</strong> 设置在线<code>key</code>：“online：active”，当用户登录时，通过<code>setbit</code>设置<ul><li><code> bitmap</code>的优势，以统计活跃用户为例</li><li>每个用户id占用空间为<code>1bit</code>，消耗内存非常少，存储<code>1亿</code>用户量只需要<code>12.5M</code>。</li></ul></li><li><strong>签到统计</strong><ul><li>在签到打卡的场景中，我们只用记录签到,就将对应<code>offset</code>的<code>bit</code>值设置为“1”；</li><li>每个用户一天的签到用 <code>1 </code>个 <code>bit </code>位就能表示，一个月的签到情况用<code> 30</code> 个 <code>bit </code>位就可以，而一年的签到也只需要用<code>365</code>个<code> bit</code> 位，根本不用太复杂的集合类型。</li></ul></li><li><strong>布隆过滤器</strong></li></ul><p><strong>注意：最好给<code>Bitmap</code>设置过期时间，让<code> Redis</code> 删除过期的打卡数据，节省内存。</strong></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-哨兵模式</title>
      <link href="/2022/10/27/redis/redis-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/10/27/redis/redis-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要有哨兵机制？"><a href="#为什么要有哨兵机制？" class="headerlink" title="为什么要有哨兵机制？"></a>为什么要有哨兵机制？</h1><p>在 Redis 的主从架构中，由于主从模式是读写分离的，如果主节点（master）挂了，那么将没有主节点来服务客户端的写操作请求，也没有主节点给从节点（slave）进行数据同步了。</p><p><img src="https://img-blog.csdnimg.cn/c29962405bc546f2ace83b979e11067d.png" alt="在这里插入图片描述"><br>这时如果要恢复服务的话，需要人工介入，选择一个<strong>从节点</strong>切换为<strong>主节点</strong>，然后让其他从节点指向新的主节点，同时还需要通知上游那些连接 Redis 主节点的客户端，将其配置中的主节点 IP 地址更新为<strong>新主节点的 IP 地址</strong>。<br>Redis 在 2.8 版本以后提供的<strong>哨兵（Sentinel）机制</strong>，它的作用是实现<strong>主从节点故障转移</strong>。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</p><h1 id="作用和架构"><a href="#作用和架构" class="headerlink" title="作用和架构"></a>作用和架构</h1><p><img src="https://img-blog.csdnimg.cn/e80894f5cddd4a198ac1d028ec03f1e2.png" alt="在这里插入图片描述"><br>解决的问题是：<br>哨兵：哨兵的核心功能是主节点的自动故障转移。在主从复制的基础上，哨兵实现了<strong>自动化的故障恢复</strong>。缺陷：<strong>写操作无法负载均衡；存储能力受到单机的限制</strong>。</p><ul><li><strong>监控</strong>（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。</li><li><strong>自动故障转移</strong>（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li><strong>配置提供者</strong>（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li><li><strong>通知</strong>（Notification）：哨兵可以将故障转移的结果发送给客户端。</li></ul><h1 id="部署主从"><a href="#部署主从" class="headerlink" title="部署主从"></a>部署主从</h1><p>主从搭建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#redis-6379.conf</span></span><br><span class="line">port <span class="number">6379</span></span><br><span class="line">daemonize yes</span><br><span class="line">logfile <span class="string">&quot;6379.log&quot;</span></span><br><span class="line">dbfilename <span class="string">&quot;dump-6379.rdb&quot;</span></span><br><span class="line">redis-server redis<span class="number">-6379.</span>conf</span><br><span class="line"> </span><br><span class="line"><span class="meta">#redis-6380.conf</span></span><br><span class="line">port <span class="number">6380</span></span><br><span class="line">daemonize yes</span><br><span class="line">logfile <span class="string">&quot;6380.log&quot;</span></span><br><span class="line">dbfilename <span class="string">&quot;dump-6380.rdb&quot;</span></span><br><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span></span><br><span class="line">redis-server redis<span class="number">-6380.</span>conf</span><br><span class="line"> </span><br><span class="line"><span class="meta">#redis-6381.conf</span></span><br><span class="line">port <span class="number">6381</span></span><br><span class="line">daemonize yes</span><br><span class="line">logfile <span class="string">&quot;6381.log&quot;</span></span><br><span class="line">dbfilename <span class="string">&quot;dump-6381.rdb&quot;</span></span><br><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span></span><br><span class="line">redis-server redis<span class="number">-6381.</span>conf</span><br></pre></td></tr></table></figure><p>redis哨兵架构搭建步骤</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#sentinel‐26379.conf</span></span><br><span class="line">port <span class="number">26379</span></span><br><span class="line">daemonize yes</span><br><span class="line">pidfile <span class="string">&quot;/var/run/redis‐sentinel‐26379.pid&quot;</span></span><br><span class="line">logfile <span class="string">&quot;26379.log&quot;</span></span><br><span class="line"><span class="meta"># sentinel monitor <span class="string">&lt;master‐redis‐name&gt;</span> <span class="string">&lt;master‐redis‐ip&gt;</span> <span class="string">&lt;master‐redis‐port&gt;</span> <span class="string">&lt;quorum&gt;</span></span></span><br><span class="line"><span class="meta"># quorum是一个数字，指明当有多少个sentinel认为一个master失效时(值一般为：sentinel总数/2 +1)，master才算真正失效</span></span><br><span class="line">sentinel monitor mymaster <span class="number">192.168</span><span class="number">.0</span><span class="number">.60</span> <span class="number">6379</span> <span class="number">2</span> <span class="meta">#mymaster名字随便取，客户端访问时会用到</span></span><br><span class="line">src/redis‐sentinel sentinel‐<span class="number">26379.</span>conf # 启动sentinel哨兵实例</span><br><span class="line"></span><br><span class="line">src/redis‐cli ‐p <span class="number">26379</span> 查看sentinel的info信息</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">26379</span>&gt;info #可以看到Sentinel的info里已经识别出了redis的主从</span><br><span class="line"></span><br><span class="line">同理在配置<span class="number">2</span>个哨兵</span><br></pre></td></tr></table></figure><p>查看下如下配置文件sentinel-26379.conf，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat sentinel<span class="number">-26379.</span>conf</span><br><span class="line">......</span><br><span class="line"><span class="meta"># sentinel集群都启动完毕后，会将哨兵集群的元数据信息写入所有sentinel的配置文件里去(追加在文件的</span></span><br><span class="line">最下面)</span><br><span class="line"><span class="number">1</span> sentinel known‐replica mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6380</span> #代表redis主节点的从节点信息</span><br><span class="line"><span class="number">2</span> sentinel known‐replica mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6381</span> #代表redis主节点的从节点信息</span><br><span class="line"><span class="number">3</span> sentinel known‐sentinel mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">26380</span> <span class="number">52</span>d0a5d70c1f90475b4fc03b6ce7c3c569</span><br><span class="line"><span class="number">35760f</span> #代表感知到的其它哨兵节点</span><br><span class="line"><span class="number">4</span> sentinel known‐sentinel mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">26381</span> e9f530d3882f8043f76ebb8e1686438ba8</span><br><span class="line">bd5ca6 #代表感知到的其它哨兵节点</span><br><span class="line">sentinel current-epoch <span class="number">0</span></span><br></pre></td></tr></table></figure><p><code>known-slave</code>和<code>known-sentinel</code>显示哨兵已经发现了从节点和其他哨兵；带有<code>epoch</code>的参数与配置纪元有关</p><h1 id="Redis哨兵的高可用"><a href="#Redis哨兵的高可用" class="headerlink" title="Redis哨兵的高可用"></a>Redis哨兵的高可用</h1><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>原理：当主节点出现故障时，由<code>Redis Sentinel</code>自动完成故障发现和转移，并通知应用方，实现高可用性。<br><img src="https://img-blog.csdnimg.cn/14ad3b6a22e54c869e2e0cb478d6add5.png" alt="在这里插入图片描述"></p><ul><li>哨兵机制建立了多个哨兵节点(进程)，共同监控数据节点的运行状况。</li><li>同时<strong>哨兵节点之间也互相通信，交换对主从节点的监控</strong>状况。</li><li>每隔1秒每个哨兵会向整个集群：Master主服务器+Slave从服务器+其他Sentinel（哨兵）进程，发送一次ping命令做一次心跳检测。</li></ul><p>这个就是哨兵用来判断节点是否正常的重要依据，涉及两个新的概念：<strong>主观下线和客观下线</strong>。</p><ol><li><strong>主观下线</strong><br>适用于<strong>主服务器和从服务器</strong>。如果在规定的时间内(配置参数：<code>down-after-milliseconds</code>)，<code>Sentinel </code>节点没有收到目标服务器的有效回复，则判定该服务器为“主观下线”。比如 Sentinel1 向主服务发送了PING命令，在规定时间内没收到主服务器PONG回复，则 Sentinel1 判定主服务器为“主观下线”。</li><li><strong>客观下线</strong><br>只适用于<strong>主服务器</strong>。 Sentinel1 发现主服务器出现了故障，它会通过相应的命令，询问其它 Sentinel 节点对主服务器的状态判断。如果超过半数以上的  Sentinel 节点认为主服务器 down 掉，则 Sentinel1 节点判定主服务为“客观下线”。<strong>客观下线是主节点才有的概念；如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作。</strong><br>（4）选举领导者哨兵节点：当主节点被判断客观下线以后，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。<br>监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；<strong>Raft算法的基本思路是先到先得</strong>：即在一轮选举中，哨兵A向B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者。选举的具体过程这里不做详细描述，一般来说，<strong>哨兵选择的过程很快，谁先完成客观下线，一般就能成为领导者</strong>。</li></ol><h1 id="主从故障转移的过程是怎样的？"><a href="#主从故障转移的过程是怎样的？" class="headerlink" title="主从故障转移的过程是怎样的？"></a>主从故障转移的过程是怎样的？</h1><h2 id="新主节点选举"><a href="#新主节点选举" class="headerlink" title="新主节点选举"></a>新主节点选举</h2><p>首先，Sentinel Leader会按照以下条件剔除从节点：</p><ul><li>主观宕机（SDOWN）或与处于断线状态的从节点；</li><li>最近5秒内未回复过Sentinel Leader <code>INFO</code>命令的从节点；</li><li>与主节点断开连接超过10倍<code>down-after-milliseconds</code>(主从节点断连的最大连接超时时间)的从节点；</li></ul><p>筛选过后，剩下的从节点都是数据比较新、与Sentinel Leader通信正常的，可以保证故障转移后最小的数据丢失。<br>然后，按照以下规则选择新的主节点：</p><ul><li>选择<code>replica-priority</code>最低的节点(优先级最高)。如果存在相同，则继续；</li><li>选择<code>复制偏移量最大</code>的的从节点。如果存在相同，则继续；</li><li>选择<code>runId</code>最小的从节点；</li></ul><h2 id="将从节点指向新主节点"><a href="#将从节点指向新主节点" class="headerlink" title="将从节点指向新主节点"></a>将从节点指向新主节点</h2><p>配置新主节点&amp;新主节点角色提升<br>更新主从状态：通过<code>slaveof no one</code>命令，让选出来的从节点成为主节点；并通过<code>slaveof</code>命令让其他节点成为其从节点。</p><h2 id="通知客户的主节点已更换"><a href="#通知客户的主节点已更换" class="headerlink" title="通知客户的主节点已更换"></a>通知客户的主节点已更换</h2><p>客户端和哨兵建立连接后，<strong>客户端会订阅哨兵提供的频道</strong>。主从切换完成后，哨兵就会向<code>+switch-master</code>频道发布新主节点的<code> IP 地址和端口</code>的消息，这个时候客户端就可以收到这条信息，然后用这里面的<code>新主节点的 IP 地址和端口</code>进行通信了。</p><h2 id="将旧主节点变为从节点"><a href="#将旧主节点变为从节点" class="headerlink" title="将旧主节点变为从节点"></a>将旧主节点变为从节点</h2><p>继续监视旧主节点，当旧主节点重新上线时，哨兵集群就会向它发送 <code>SLAVEOF </code>命令，让它成为新主节点的从节点。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>sentinel</code>会为每个被监视的主服务器创建相应的实列，并创建连向主服务器的<strong>命令连接(向主服务器发送命令)和订阅连接（接受指定频道消息）</strong>。</li><li><code>sentinel</code>通过向<code>master</code>发送<code>Info</code>命令，获取<code>master</code>和它下面所有<code>slave</code>的当前信息。并为这些从服务器创建相应的实例结构，连向从服务器的<strong>命令连接</strong>和<strong>订阅连接</strong>。</li><li>每隔10秒向<code>master</code>和从服务器发送<code>info</code>命令，当主服务器下线时或者<code>sentinel</code>对主服务器进行故障迁移操作时，<code>sentinel</code>向从服务器发送<code>info</code>命令的时间为1秒1次。</li><li><code>sentinel</code>和<code>sentinel</code>之间只会有命令连接。<code>sentinel</code>与主从服务器创建命令连接和订阅连接。每个<code>sentinel</code>通过<code>__sentinel__:hello</code>频道发送消息来向其他的sentinel宣告存在。</li><li><code>sentinel</code>每隔1秒向所有服务器发送<code>ping</code>命令，如果某台服务器在配置的响应时间内连续返回无效回复，将会被标记为主观下线。</li></ul><p><strong>注意</strong><br><strong>sentinel会为每个被监视的主服务器创建相应的实列，并创建连向主服务器的命令连接和订阅连接，为什么会有2个实例？</strong><br>在<code>redis</code>的订阅功能中，被发送的消息都不会保存在<code>redis</code>服务器里面，如果在信息发送时，想要收到信息的客户端不在，那么就会数据丢失。为了不丢失任何信息，必须专门建立一个频道来接受。另一方面，除了订阅连接，<code>sentinel</code>还必须向主服务器发送命令，以此来与主服务器通信，所以还必须有命令连接。因为<code>sentinel</code>有多个实例创建的网络连接，所以<code>sentinel</code>使用的异步连接。</p><p><strong>sentinel之间不会建立订阅连接</strong><br>因为<code>sentinel</code>在连接主服务器和从服务器时，会同时创建命令连接和订阅连接，但是在连接其他的<code>sentinel</code>时，只会创建命令连接，而不是订阅连接。这是因为<code>sentinel</code>需要通过接受主服务器或者从服务器发送的频道信息来发现未知的<code>sentinel</code>，所以才需要连接订阅连接。而相互已知的<code>sentinel</code>只要使用命令连接就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-持久化进阶篇-一致性问题</title>
      <link href="/2022/10/27/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%9B%E9%98%B6/"/>
      <url>/2022/10/27/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="RDB对过期键的处理"><a href="#RDB对过期键的处理" class="headerlink" title="RDB对过期键的处理"></a>RDB对过期键的处理</h1><h2 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h2><p>在<code>RDB</code>中是以快照的形式获取内存中某一时间点的数据副本，在创建<code>RDB</code>文件的时候可以通过<code>save</code>和<code>bgsave</code>命令执行创建RDB文件。<strong>这两个命令都不会把过期的key保存到RDB文件中</strong>，这样也能<strong>达到删除过期key的效果</strong>。如：数据库中包含3个键<code>k1、k2、k3</code>，并且<code>k2已经过期</code>，那么创建新的<code>RDB</code>文件时，程序只会将<code>k1</code>和<code>k3</code>保存到<code>RDB</code>文件中，<code>k2</code>则会被忽略。</p><h2 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 如果服务器为主节点的话，</span></span><br><span class="line"><span class="comment">* 那么在键已经过期的时候，不再将它们关联到数据库中去</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp; expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) &#123;</span><br><span class="line">            decrRefCount(key);</span><br><span class="line">            decrRefCount(val);</span><br><span class="line">            <span class="comment">// 跳过</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动Redis服务器时，如果服务器只开启了<code>RDB持久化</code>，那么服务器将会<code>载入RDB文件</code>：</p><ul><li>如果服务器以<strong>主服务器</strong>模式运行，在载入<code>RDB</code>文件时，<strong>程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，过期键会被忽略</strong>。</li><li>如果服务器以<strong>从服务器模式</strong>运行，在载入RDB文件时，<strong>文件中保存的所有键，不论是否过期，都会被载入到数据库中。</strong></li></ul><p>因为主从服务器在进行数据同步的时候，从服务器的数据库会被清空，所以一般情况下，过期键对载入RDB文件的从服务器不会造成影响。</p><h1 id="AOF对过期键的处理"><a href="#AOF对过期键的处理" class="headerlink" title="AOF对过期键的处理"></a>AOF对过期键的处理</h1><h2 id="AOF文件写入"><a href="#AOF文件写入" class="headerlink" title="AOF文件写入"></a>AOF文件写入</h2><p>如果<strong>数据库中的某个键已经过期</strong>，并且服务器开启了<code>AOF持久化功能</code>，当过期键被<code>惰性删除</code>或者<code>定期删除</code>后，程序会向<code>AOF文件</code>追加一条<code>DEL命令</code>，显式记录该键<code>已被删除</code>。举个例子，如果客户端执行命令<code>GET message</code>访问已经过期的<code>message</code>键，那么服务器将执行以下3个动作：</p><ul><li>从数据库中删除message键;</li><li>追加一条<code>DEL message</code>命令到AOF文件;</li><li>向执行·GET message·命令的客户端返回空回复。</li></ul><h2 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h2><p>在执行<strong>AOF文件重写</strong>时，程序会对数据库中的键进行检查，<strong>已过期的键不会被保存到重写后的AOF文件中</strong>。</p><h2 id="复制功能对过期键的处理"><a href="#复制功能对过期键的处理" class="headerlink" title="复制功能对过期键的处理"></a>复制功能对过期键的处理</h2><p>在<strong>主从复制</strong>模式下，<strong>从服务器的过期键删除</strong>动作由<strong>主服务器</strong>控制：</p><ul><li><strong>主服务器</strong>在删除一个过期键后，向所有<strong>从服务器</strong>发送一个<code>DEL</code>命令，从服务器删除这个过期键。</li><li><strong>从服务器</strong>在执行客户端发送的读命令时，即使发现<strong>该键已过期也不会删除该键</strong>，照常返回该键的值。</li><li><strong>从服务器</strong>只有接收到<strong>主服务器</strong>发送的<code>DEL命令</code>后，才会<code>删除过期键</code>。</li></ul><h3 id="问题-你可能会为问了，既然Redis有过期数据删除策略，那为什么还会拉取到已经过期的数据呢？"><a href="#问题-你可能会为问了，既然Redis有过期数据删除策略，那为什么还会拉取到已经过期的数据呢？" class="headerlink" title="问题:你可能会为问了，既然Redis有过期数据删除策略，那为什么还会拉取到已经过期的数据呢？"></a>问题:你可能会为问了，既然Redis有过期数据删除策略，那为什么还会拉取到已经过期的数据呢？</h3><p><img src="https://img-blog.csdnimg.cn/6e0c5ba6be0d4c09a0df38525d7e611d.png" alt="在这里插入图片描述"><br>当客户端往<strong>主库写入数据</strong>后，并设置了<strong>过期时间</strong>，数据会以<strong>异步方式</strong>同步给从库。</p><ul><li>如果此时<strong>读主库</strong>，数据已经过期，主库的<strong>惰性删除</strong>会发挥作用，主动触发删除操作，客户端不会拿到已过期数据</li><li>但是如果<strong>读从库</strong>，则有<strong>可能拿到过期数据</strong>。原因如下<ul><li>原因一：跟<code> Redis</code> 的版本有关系，<code>Redis 3.2 </code>之前版本，读从库并<code>不会判断数据是否过期</code>，所以有可能返回过期数据。<br> -原因二：跟过期时间的设置方式有关系，我们一般采用<code> EXPIRE</code> 和 <code>PEXPIRE</code>，表示从执行命令那个时刻开始，往后延长<code> ttl</code> 时间。严重依赖于 <code>开始时间 </code>从什么时候算起。</li></ul></li></ul><p><strong>原因一解决方案：</strong></p><blockquote><p>升级Redis的版本，至少要3.2 以上版本，读从库，如果数据已经过期，则会过滤并返回空值。</p></blockquote><p><strong>原因二：</strong><br><img src="https://img-blog.csdnimg.cn/141bfe73ae614f42a770c39b3999cf38.png" alt="在这里插入图片描述"><br>如上图所示，简单描述下过程：</p><ul><li>主库在<code> t1</code> 时刻写入一个带过期时间的数据，数据的有效期一直到<code> t3</code>。</li><li>由于网络原因、或者缓存服务器的执行效率，从库的命令并没有立即执行。一直等到了<code> t2</code> 才开始执行， 数据的有效期则会延后到 <code>t5</code>。</li><li>如果，此时客户端访问从库，发现数据依然处于有效期内，可以正常使用。</li></ul><p><strong>原因二解决方案：</strong><br>可以采用<code>Redis</code>的另外两个命令，<code>EXPIREAT</code> 和 <code>PEXPIREAT</code>，相对简单，表示过期时间为一个具体的时间点。避免了对开始时间从什么时候算起的依赖。</p><blockquote><p>EXPIREAT：单位为秒<br>PEXPIREAT：单位为毫秒</p></blockquote><p>特别注意：</p><blockquote><p>EXPIREAT 和 PEXPIREAT 设置的是时间点，所以要求主从节点的时钟保持一致，需要与NTP 时间服务器保持时钟同步。</p></blockquote><p>主从同步，除了读从库可能拉取到过期数据，还可能遇到数据一致性问题。这个。。。。以后再说。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis持久化进阶篇-大key的影响</title>
      <link href="/2022/10/27/redis/%E5%A4%A7key%E5%AF%B9%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
      <url>/2022/10/27/redis/%E5%A4%A7key%E5%AF%B9%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="大-Key-对-AOF-日志的影响"><a href="#大-Key-对-AOF-日志的影响" class="headerlink" title="大 Key 对 AOF 日志的影响"></a>大 Key 对 AOF 日志的影响</h1><p> AOF 日志三种写回磁盘的策略：</p><ul><li><code>Always</code>:所以它的意思是每次写操作命令执行完后，<strong>同步</strong>将 AOF 日志数据写回硬盘；</li><li><code>Everysec</code>:所以它的意思是每次写操作命令执行完后，先将命令<strong>写入到 AOF 文件的内核缓冲区</strong>，然后<strong>每隔一秒</strong>将缓冲区里的内容写回到硬盘；</li><li><code>No</code>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操<strong>作系统决定</strong>何时将缓冲区内容写回硬盘。</li></ul><p>这三种策略只是在控制<code>fsync() </code>函数的调用时机。</p><p><img src="https://img-blog.csdnimg.cn/16a8f5cc141044edb83f36397f83da48.png" alt="在这里插入图片描述"></p><ul><li><code> Always</code> 策略就是每次写入 AOF 文件数据后，就执行<code> fsync()</code>函数；</li><li><code>Everysec </code>策略就会创建一个<code>异步任务来执行 fsync()</code> 函数；</li><li><code>No</code>策略就是<code>永不执行 fsync() </code>函数;</li></ul><p><strong>分别说说这三种策略，在持久化大 Key 的时候，会影响什么？</strong></p><ul><li><p>当使用 <code>Always</code> 策略的时候，如果写入是一个大<code> Key</code>，主线程在执行 <code>fsync()</code> 函数的时候，<strong>阻塞的时间会比较久</strong>，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很<strong>耗时</strong>的。</p></li><li><p>当使用<code>Everysec</code>策略的时候，由于是异步执行<code>fsync()</code>函数，所以大 Key 持久化的过程（数据同步磁盘）<strong>不会影响主线程</strong>。</p></li><li><p>当使用 <code>No</code>策略的时候，由于永不执行 fsync() 函数，所以大<code> Key</code> 持久化的过程<strong>不会影响</strong>主线程。</p></li></ul><h1 id="大-Key-对-AOF-重写和-RDB-的影响"><a href="#大-Key-对-AOF-重写和-RDB-的影响" class="headerlink" title="大 Key 对 AOF 重写和 RDB 的影响"></a>大 Key 对 AOF 重写和 RDB 的影响</h1><p>当<code>AOF</code>日志写入了很多的大<code> Key·</code>，<code>AOF </code>日志文件的大小会很大，那么很快就会触发 <code>AOF 重写</code>机制。<code>AOF 重写机制</code>和 <code>RDB 快照</code>的过程，都会分别通过<code>fork()</code>函数创建一个子进程来处理任务。</p><h2 id="页表复制，内存共享"><a href="#页表复制，内存共享" class="headerlink" title="页表复制，内存共享"></a>页表复制，内存共享</h2><p>在创建子进程的过程中，操作系统会把<strong>父进程的页表</strong>复制一份给子进程，这个<strong>页表记录着虚拟地址和物理地址映射关系</strong>，而不会复制物理内存，也就是说，<strong>两者的虚拟空间不同，但其对应的物理空间是同一个</strong>。<strong>子进程就共享了父进程的物理内存数据了</strong>，这样能够<strong>节约物理内存资源</strong>。在通过<code>fork()</code>函数创建子进程的时候，虽然不会复制父进程的物理内存，但是内核会把父进程的页表复制一份给子进程，如果页表很大，那么这个复制过程是会很耗时的，那么在执行<code>fork</code>函数的时候就会发生阻塞现象。</p><p>执行<code>info</code>命令获取到<code>latest_fork_usec</code>指标，表示 Redis 最近一次 fork 操作耗时。</p><blockquote><p>latest_fork_usec:100</p></blockquote><p><code> fork</code> 耗时很大，则需要做出优化调整：</p><ul><li>单个实例的内存占用控制在 10 GB 以下，这样 fork 函数就能很快返回。</li><li>如果 Redis 只是当作纯缓存使用，不关心 Redis 数据安全性问题，可以考虑关闭 AOF 和 AOF 重写，这样就不会调用 fork 函数了。<br>在- 主从架构中，要适当调大 <code>repl-backlog-size</code>，避免因为<code>repl_backlog_buffer</code>不够大，导致主节点频繁地使用<strong>全量同步</strong>的方式，<code>全量同步</code>的时候，是会创建<code>RDB</code>文件的，也就是会调用<code> fork</code> 函数。</li></ul><h2 id="物理内存的复制"><a href="#物理内存的复制" class="headerlink" title="物理内存的复制"></a>物理内存的复制</h2><p>当父进程或者子进程在向共享内存发起写操作时，操作系统会在进行<strong>物理内存的复制</strong>，并重新设置其内存映射关系。这个过程被称为<strong>写时复制Copy On Write</strong>。</p><p>写时复制：在发生写操作的时候，操作系统才会去复制物理内存，这样是为了防止 <code>fork </code>创建子进程时，由于<strong>物理内存数据的复制时间过长而导致父进程长时间阻塞</strong>的问题。</p><p>创建完子进程后，父进程对共享内存中的<code>大 Key</code> 进行了修改，那么内核就会发生<code>写时复制</code>，会把物理内存复制一份，由于<code>大 Key </code>占用的物理内存是比较大的，那么在复制物理内存这一过程中，也是比较<code>耗时</code>的，于是父进程就会发生<code>阻塞</code>。</p><p>有两个阶段会导致<strong>阻塞父进程</strong>：</p><ul><li>创建子进程的途中，由于要<strong>复制父进程的页表</strong>等数据结构，<strong>阻塞的时间跟页表的大小有关</strong>，页表越大，阻塞的时间也越长；</li><li>创建完子进程后，如果子进程或者父进程<strong>修改了共享数据</strong>，就会发生写时复制，这期间会拷贝物理内存，如果<strong>内存越大，自然阻塞的时间也越长</strong>；</li></ul><p><img src="https://img-blog.csdnimg.cn/47f8a086e907451b90d461e0f3075aed.png" alt="在这里插入图片描述"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>当 AOF 写回策略配置了 <code>Always</code> 策略，如果写入是一个<code>大 Key</code>，主线程在执行 <code>fsync() </code>函数的时候，阻塞的时间会比较久。</li><li><code>AOF 重写机制</code>和 <code>RDB 快照</code>的过程，都会分别通过<code>fork()</code>函数创建一个子进程来处理任务。会有两个阶段会导致阻塞父进程：</li><li>创建子进程的途中，由于要复制父进程的页表等数据结构，页表越大，阻塞的时间也越长；</li><li>创建完子进程后，如果父进程修改了共享数据中的<code>大 Key</code>，就会发生写时复制，这期间会拷贝物理内存，由于·大 Key ·占用的物理内存会很大。</li></ul><p>大 key 除了会影响<strong>持久化</strong>之外，还会有以下的影响。</p><ul><li>客户端超时阻塞。由于 Redis 执行命令是单线程处理，然后在操作<code>大 key </code>时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li><li>引发<strong>网络阻塞</strong>。每次获取大 key 产生的<strong>网络流量较大</strong>，如果一个 key 的大小是 1 MB，每秒访问量为<code> 1000</code>，那么每秒会产生<code>1000MB</code>的流量，这对于<code>普通千兆网卡</code>的服务器来说是灾难性的。</li><li>阻塞工作线程。如果使用<code>del</code>删除<code>大 key </code>时，会阻塞工作线程，这样就没办法处理后续的命令。</li><li>内存分布不均。集群模型在<code>slot</code>分片均匀情况下，会出现数据和查询倾斜情况，部分有<code>大 key</code> 的 Redis 节点占用内存多，<code>QPS</code> 也会比较大。</li></ul><h2 id="如何避免大-Key-呢？"><a href="#如何避免大-Key-呢？" class="headerlink" title="如何避免大 Key 呢？"></a>如何避免大 Key 呢？</h2><ul><li>最好在设计阶段，就把大 key 拆分成一个一个小 key。</li><li>定时检查 Redis 是否存在大 key ，如果该<code>大 key</code> 是可以删除的，不要使用<code>DEL </code>命令删除，因为该命令删除过程会阻塞主线程，而是用<code>unlink</code>命令（Redis 4.0+）删除<code>大 key</code>，因为该命令的删除过程是异步的，不会阻塞主线程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-持久化基础篇</title>
      <link href="/2022/10/27/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/10/27/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要持久化"><a href="#为什么要持久化" class="headerlink" title="为什么要持久化"></a>为什么要持久化</h1><p><code>Redis</code>是内存数据库，宕机后数据会消失，<code>Redis</code>重启后快速恢复数据，要提供<strong>持久化机制</strong>。<code>Redis</code>持久化<strong>不保证数据的完整性</strong>，有可能会丢数据。当下次<code>Redis</code>重启时，利用持久化文件实现数据恢复。除此之外，为了<strong>进行灾难备份</strong>，可以将持久化文件拷贝到一个远程位置。</p><h1 id="RDB-默认"><a href="#RDB-默认" class="headerlink" title="RDB(默认)"></a>RDB(默认)</h1><p><code>RDB</code>方式是通过<strong>快照</strong>完成的。它保存的是某一时刻的数据并不关注过程。<code>RDB</code>保存<code>redis</code>某一时刻的数据的快照。</p><h2 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h2><ul><li><strong>执行<code>save</code>命令</strong> ：  会在主进程执行RDB，导致其他命令阻塞</li><li><strong>执行<code>bgsave</code>命令</strong> ：会开启独立进程异步执行RDB,主进程可以持续处理请求</li><li><code>shutdown</code>指令：<code>redis</code>通过<code>shutdown</code>指令接受到关闭服务器的请求时，会触发一次<code>SAVE</code>命令，阻塞所有的客户端</li><li>执行主从复制操作 (第一次)。</li><li>符合<strong>自定义配置</strong>的快照规则；<br><img src="https://img-blog.csdnimg.cn/7e3fbb9b8e2b40bca00c0ed9cd1ad35e.png" alt="在这里插入图片描述"></li></ul><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><img src="https://img-blog.csdnimg.cn/6cc66ba03bac44deb4b75b034bbdb358.png" alt="在这里插入图片描述"><br><strong>执行流程</strong></p><ol><li><code>Redis</code>父进程首先判断：当前是否在执行<strong>save或bgsave&#x2F;bgrewriteaof</strong>的子进程，如果在执行则<code>bgsave</code>命令直接返回。<code>bgsave/bgrewriteaof </code>的子进程不能同时执行，主要是基于<strong>性能方面的考虑</strong>：两个并发的子进程同时执行大量的<strong>磁盘写操作</strong>，可能引起严重的性能问题;</li><li>父进程执行<code>fork</code>操作创建子进程，这个过程中<strong>父进程是阻塞</strong>的，<code>Redis</code><strong>不能</strong> 执行来自客户端的任何命令;</li><li>父进程<code>fork</code>后，<code>bgsave</code>命令不再阻塞父进程，并可以响应其他命令;</li><li>子进程创建<code>RDB</code>文件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换;</li><li>子进程发送信号给父进程表示完成，父进程更新统计信息。</li></ol><p><strong>写时复制机制(cow机制)</strong><br>原因：在服务执行请求的同时，<code>Redis</code>还需要进行快照<strong>（文件IO操作）</strong>，所以<code>文件IO</code>操作不能进行多路复用。单线程同时在服务线上的请求还要进行<code>文件 IO </code>操作，<code>文件 IO</code> 操作会严重拖垮服务器请求的性能。</p><p>原理：<code>Redis </code>在持久化时<strong>fork 产生一个子进程</strong>，快照持久化完全交给子进程来处理，子进程刚刚产生时，它和父进程共享内存里面的<strong>代码段和数据段（上图共享内存）</strong>。这是 Linux 操作系统的机制，为了节约内存资源，所以尽可能让它们共享起来。在进程分离的一瞬间，内存的增长几乎没有明显变化。这时父进程持续服务客户端请求，然后对内存数据结构进行不间断的修改。这个时候就会使用操作系统的 <code>COW </code>机制来进行数据段页面的分离（<strong>对数据页进行复制，子进程读取不变</strong>）。父进程修改操作的持续进行，越来越多的共享页面被分离出来，内存就会持续增长。但是也不会超过原有数据内存的 2 倍大小。</p><p><strong>save与bgsave对比：</strong></p><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>是否阻塞redis其它命令</td><td>是</td><td>否(在生成子进程执行调用fork函数时会有短暂阻塞)</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fork子进程，消耗内存</td></tr></tbody></table><h2 id="在执行BGSAVE命令时，服务器BGSAVE-，SAVAE-BGREWRITEAOF-异同。-了解"><a href="#在执行BGSAVE命令时，服务器BGSAVE-，SAVAE-BGREWRITEAOF-异同。-了解" class="headerlink" title="在执行BGSAVE命令时，服务器BGSAVE ，SAVAE ,BGREWRITEAOF 异同。(了解)"></a>在执行BGSAVE命令时，服务器BGSAVE ，SAVAE ,BGREWRITEAOF 异同。(了解)</h2><p>1.<code>BGSAVE</code>执行期间，客户端发送<code>SAVE</code>命令全部拒绝。避免父子进程同时调用<code>rdbSave</code>，防止竞争。<br>2.<code>BGSAVE</code>执行期间，客户端发送<code>BGSAVE</code>命令全部拒绝，同理。<br>3.<code>BGSAVE</code>和<code>BGWRITEAOF</code>不能同时执行。如果执行<code>BGSAVE</code>期间，客户端发送<code>BGWRITEAOF</code>指令，延迟到<code>BGSAVE</code>指令完成之后执行。如果<code>BGWRITEAOF</code>正在执行，客户端发送<code>BGSAVE</code>会被拒绝。两个指令都是子进程完成，出于性能考虑不能同时执行，并且两个指令进行大量写入磁盘的操作。</p><h2 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h2><p>优点：<strong>RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小</strong>。</p><p>缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然<strong>做不到实时持久化</strong>，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，<strong>兼容性差</strong>（如老版本的Redis不兼容新版本的RDB文件）。</p><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p><code>AOF</code>默认情况下是不开启的。开启<code>AOF</code>持久化后<code>Redis </code>将所有对数据库进行过<strong>写入的命令记录</strong>到 <code>AOF </code>文件， 这样当Redis重启后只要按顺序回放这些命令就会恢复到原始状态了。<strong>AOF会记录过程，RDB只管结果</strong>。<br>通过修改配置文件来打开 AOF 功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># appendonly yes</span></span><br></pre></td></tr></table></figure><p>可以配置<code>Redis</code>多久才将数据 <code>fsync</code> 到磁盘一次。<br>有三个选项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always：每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。</span><br><span class="line">appendfsync everysec：每秒 fsync 一次，足够快，并且在故障时只会丢失 <span class="number">1</span> 秒钟的数据。</span><br><span class="line">appendfsync no：从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。</span><br></pre></td></tr></table></figure><p>推荐（并且也是默认）的措施为每秒<code>fsync</code>一次， 这种<code>fsync</code>策略可以兼顾速度和安全性。</p><h2 id="AOF的执行流程"><a href="#AOF的执行流程" class="headerlink" title="AOF的执行流程"></a>AOF的执行流程</h2><ul><li>命令追加(append)：Redis的所有写命令依然写入<code>AOF缓冲区(aof_buf)</code>。（主要是为了避免每次有写命令都直接写入硬盘，导致硬盘IO成为Redis负载的瓶颈。）</li><li>文件写入(write)和文件同步(sync)：根据不同的同步策略将<code>aof_buf</code>中的内容同步到硬盘；操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到硬盘里。这样的操作虽然提高了效率，但也带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失；因此系统同时提供了<strong>fsync、fdatasync（appendfsync控制）等同步函数</strong>，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保数据的安全性。</li><li>文件重写(rewrite)：定期重写<code>AOF</code>文件，达到压缩的目的。</li></ul><h2 id="具体执行流程"><a href="#具体执行流程" class="headerlink" title="具体执行流程"></a>具体执行流程</h2><p><img src="https://img-blog.csdnimg.cn/bee4eadf269c40f49e73c7c508e9aa0c.png" alt="在这里插入图片描述"><br>1.<code>Redis</code>父进程首先判断当前是否存在正在执行 <code>bgsave/bgrewriteaof</code>的子进程，如果存在则<code>bgrewriteaof</code>命令直接返回，如果存在<code>bgsave</code>命令则等<code>bgsave</code>执行完成后再执行。前面曾介绍过，这个主要是基于性能方面的考虑。<br>2. 父进程执行<code>fork</code>操作创建子进程，这个过程中父进程是阻塞的。<br>3.1:父进程<code>fork</code>后，<code>bgrewriteaof</code>命令返回并不再阻塞父进程，并可以响应其他命令。<code>Redis</code>的所有写命令依然写入<strong>AOF缓冲区(aof_buf)<strong>。<br>3.2. 由于<code>fork</code>操作使用写时复制技术，子进程只能共享<code>fork</code>操作时的内存数据。由于父进程依然在响应命令，因此<code>Redis</code>使用<code>AOF</code>重写缓冲区(图中的<code>aof_rewrite_buf)</code>保存这部分数据，防止新AOF文件生成期间丢失这部分数据。也就是说，<code>bgrewriteaof</code>执行期间，Redis的写命令同时追加到</strong>aof_buf和aof_rewirte_buf两个缓冲区</strong>。（<code>aof_buf</code>定时写入aof文件，<code>aof_rewirte_buf</code>写入新的aof文件）<br>4. 子进程根据内存快照，按照命令合并规则写入到新的<code>AOF</code>文件。<br>5.1.子进程写完新的<code>AOF</code>文件后，向父进程发信号。<br>5.2.父进程把<code>AOF</code>重写缓冲区的数据写入到新的AOF文件，这样就保证了新AOF文件所保存的数据库状态和服务器当前状态一致。<br>5.3.使用新的<code>AOF</code>文件替换老文件，完成AOF重写。</p><h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>如下两个配置可以控制AOF自动重写频率</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta"># auto‐aof‐rewrite‐min‐size 64mb <span class="comment">//aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就</span></span></span><br><span class="line">很快，重写的意义不大</span><br><span class="line"><span class="number">2</span> <span class="meta"># auto‐aof‐rewrite‐percentage 100 <span class="comment">//aof文件自上一次重写后文件大小增长了100%则再次触发重写</span></span></span><br></pre></td></tr></table></figure><p>当然AOF还可以手动重写，进入redis客户端执行命令<strong>bgrewriteaof</strong>重写AOF。<br>注意：<code>AOF</code>重写<code>redis</code>会<code>fork</code>出一个子进程去做(与bgsave命令类似)，不会对<code>redis</code>正常命令处理有太多影响。</p><p><code>Redis</code>可以在<code> AOF</code>体积变得过大时，自动地在后台（Fork子进程）对 AOF进行重写。重写后的新 <code>AOF</code>文件包含了恢复当前数据集所需的最小命令集合。 <strong>AOF 重写并不需要对原有的 AOF 文件进行任何写入和读取</strong>， 它针对的是数据库中键的当前值。<br><code>Redis</code> 不希望<code>AOF</code>重写造成服务器无法处理请求， 所以<code>Redis</code>决定将 AOF 重写程序放到（后台）子进程里执行， 这样处理的最大好处是：</p><ul><li>子进程进行 <code>AOF</code> 重写期间，主进程可以继续处理命令请求。</li><li>子进程带有主进程的数据副本，使用子进程而不是线程，可以在避免锁的情况下，保证数据的安全性。</li></ul><p> 使用子进程也有一个问题需要解决： <strong>因为子进程在进行 AOF 重写期间， 主进程还需要继续处理命令， 而新的命令可能对现有的数据进行修改， 这会让当前数据库的数据和重写后的 AOF 文件中的数据不一致。</strong> 为了解决这个问题，<code>Redis</code>增加了一个 <code>AOF </code>重写缓存， 这个缓存在 <code>fork </code>出子进程之后开始启用，<code>Redis </code>主进程在接到新的写命令之后， 除了会将这个写命令的协议内容追加到现有的<code>AOF</code>文件之外，还会追加到这个<code>缓存</code>中。</p><p>当子进程在执行 <code>AOF </code>重写时， 主进程需要执行以下三个工作：<br>1.处理命令请求；<br>2.将写命令追加到现有的 <code>AOF </code>文件中；<br>3.将写命令追加到<code>AOF</code>重写缓存中。<br>当子进程完成<code>AOF</code>重写之后， 它会向父进程发送一个完成信号， 父进程在接到完成信号之后， 会调用一个信号处理函数， 并完成以下工作：<br>1、 将 AOF 重写缓存中的内容全部写入到新 <code>AOF</code> 文件中；<br>2、 对新的 AOF 文件进行改名，覆盖原有的 <code>AOF </code>文件；<br><strong>Redis数据库里的+AOF重写过程中的命令——-&gt;新的AOF文件—-&gt;覆盖老的AOF文件</strong><br>这个信号处理函数执行完毕之后， 主进程就可以继续像往常一样接受命令请求了。 在整个<code>AOF</code>后台重写过程中， 只有最后的<strong>写入缓存和改名操作会造成主进程阻塞</strong>， 在其他时候，<code>AOF</code>后台重写都不会对主进程造成阻塞， 这将 AOF 重写对性能造成的影响降到了最低。</p><h2 id="AOF持久化优缺点"><a href="#AOF持久化优缺点" class="headerlink" title="AOF持久化优缺点"></a>AOF持久化优缺点</h2><p><strong>优点</strong></p><ul><li><p>AOF 的默认策略为每秒钟<code>fsync</code>一次，在这种配置下，<code>Redis </code>仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据，也可以根据实际情况设置fsync的策略。</p></li><li><p><code>AOF</code> 文件是一个只进行追加操作的日志文件，  即使日志因为某些原因而包含了未写入完整的命令， redis-check-aof 工具也可以轻易地修复这种问题。</p></li><li><p><code>Redis </code>可以在<code> AOF</code> 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 <code>AOF </code>文件包含了恢复当前数据集所需的最小命令集合。 <strong>整个重写操作是绝对安全的</strong>，因为<code>Redis</code>在创建新 <code>AOF </code>文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即<strong>使重写过程中发生停机，现有的 AOF 文件也不会丢失</strong>。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p></li><li><p>AOF 文件有序地保存了对数据库执行的所有写入操作。</p></li></ul><p><strong>缺点</strong></p><ul><li>对于具有相同数据的的 Redis，AOF 文件通常会比 RDF 文件体积更大。</li><li>虽然 AOF 提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能。但在 Redis 的负载较高时，RDB 比 AOF 具好更好的性能保证。</li></ul><h1 id="RDB和AOF如何选择"><a href="#RDB和AOF如何选择" class="headerlink" title="RDB和AOF如何选择"></a>RDB和AOF如何选择</h1><p>在介绍持久化策略之前，首先要明白无论是<code>RDB</code>还是<code>AOF</code>，<strong>持久化的开启都是要付出性能方面代价的</strong>。对于<code>RDB</code>持久化，一方面是<code>bgsave</code>在进行<code>fork</code>操作时<code>Redis</code>主进程会阻塞，另一方面，子进程向硬盘写数据也会带来<code>IO</code>压力；对于<code>AOF</code>持久化，向硬盘写数据的频率大大提高(everysec策略下为秒级)，<code>IO</code>压力更大，甚至可能造成<code>AOF</code>追加<strong>阻塞问题</strong>，此外，<code>AOF文件的重写</code>与<code>RDB的bgsave</code>类似，会有fork时的阻塞和子进程的IO压力问题。相对来说，由于AOF向硬盘中写数据的频率更高，因此对Redis主进程性能的影响会更大。</p><ul><li>如果<code>Redis</code>中的数据完全丢弃也没有关系，那么无论是单机，还是主从架构，都可以不进行任何持久化。</li><li>在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择<code>RDB</code>对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择<code>AOF</code>。</li><li>但在多数情况下，我们都会配置<strong>主从环境</strong>，slave的存在既可以实现<strong>数据的热备</strong>，也可以进行读写分离分担<code>Redis</code>读请求，以及在master宕掉后继续提供服务。</li></ul><p>在主从环境情况下，一种可行的做法是：</p><ul><li><strong>master</strong>：完全关闭持久化（包括RDB和AOF），这样可以让master的性能达到最好;</li><li><strong>slave</strong>：开启<code>AOF</code>（如果对数据安全要求不高，开启RDB关闭AOF也可以），并定时对持久化文件进行<code>备份</code>（如备份到其他文件夹，并标记好备份的时间）；然后关闭<code>AOF</code>的自动重写，然后添加定时任务，在每天<code>Redis</code>闲时（如凌晨12点）调用<code>bgrewriteaof</code>。</li></ul><p><strong>为什么开启了主从复制，可以实现数据的热备份，还需要设置持久化呢？</strong><br>因为在一些特殊情况下，主从复制仍然不足以保证数据的安全，例如：</p><ul><li><strong><code>master和slave</code>进程同时停止。考虑这样一种场景，如果<code>master</code>和<code>slave</code>在同一栋大楼或同一个机房，则一次停电事故就可能导致master和slave机器同时关机，如果没有持久化，则面临的是数据的完全丢失</strong>。</li><li><strong>master误重启</strong>：<code>master</code>服务因为故障宕掉，由于没有持久化文件，那么<code>master</code>重启后数据是空的，<code>slave</code>同步数据也变成了空的。</li><li><strong>异地灾备</strong>：如<strong>火灾地震，就需要进行异地灾备</strong>。例如对于单机的情形，可以定时将<code>RDB</code>文件或重写后的<code>AOF</code>文件，拷贝到远程机器；<strong>对于主从的情形，可以定时在master上执行bgsave，然后将RDB文件拷贝到远程机器，或者在slave上执行bgrewriteaof重写AOF文件后，将AOF文件拷贝到远程机器上</strong>。一般来说，由于<code>RDB</code>文件文件小、恢复快，因此灾难恢复常用RDB文件；异地备份的频率根据数据安全性的需要及其他条件来确定，但最好不要低于一天一次。</li></ul><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="fork阻塞：CPU的阻塞"><a href="#fork阻塞：CPU的阻塞" class="headerlink" title="fork阻塞：CPU的阻塞"></a>fork阻塞：CPU的阻塞</h2><p>众多因素限制了<code>Redis</code>单机的内存不能过大，例如：当面对请求的暴增，需要从库扩容时，Redis内存过大会导致扩容时间太长；当主机宕机时，切换主机后需要挂载从库，Redis内存过大导致挂载速度过慢；以及持久化过程中的fork操作，下面详细说明。<br>首先说明一下fork操作：父进程通过fork操作可以创建子进程；子进程创建后，<strong>父子进程共享代码段，不共享进程的数据空间</strong>，但是子进程会获得父进程的数据空间的副本。在操作系统fork的实际实现中，基本都采用了<strong>写时复制技术</strong>，即在父&#x2F;子进程试图修改数据空间之前，父子进程实际上共享数据空间；但是当父&#x2F;子进程的任何一个试图修改数据空间时，操作系统会为修改的那一部分(内存的一页)制作一个副本。<br>虽然fork时，子进程不会复制父进程的数据空间，但是会复制内存页表（页表相当于内存的索引、目录）；<strong>父进程的数据空间越大，内存页表越大，fork时复制耗时也会越多。</strong><br>在Redis中，<strong>无论是RDB持久化的bgsave，还是AOF重写的bgrewriteaof</strong>，都需要fork出子进程来进行操作。如果Redis内存过大，会导致fork操作时复制内存页表耗时过多；而<strong>Redis主进程在进行fork时，是完全阻塞的，也就意味着无法响应客户端的请求，会造成请求延迟过大</strong>。</p><h2 id="AOF追加阻塞：硬盘的阻塞"><a href="#AOF追加阻塞：硬盘的阻塞" class="headerlink" title="AOF追加阻塞：硬盘的阻塞"></a>AOF追加阻塞：硬盘的阻塞</h2><p>在<code>AOF</code>中，如果<code>AOF缓冲区</code>的文件同步策略为<code>everysec</code>，则：在主线程中，命令写入<code>aof_buf</code>后调用系统<code>write</code>操作，<code>write</code>完成后主线程返回；<strong>fsync同步文件操作由专门的文件同步线程每秒调用一次</strong>。<br><strong>这种做法的问题在于，如果硬盘负载过高，那么fsync操作可能会超过1s；如果Redis主线程持续高速向aof_buf写入命令，硬盘的负载可能会越来越大，IO资源消耗更快；如果此时Redis进程异常退出，丢失的数据也会越来越多，可能远超过1s。</strong><br>为此，Redis的处理策略是这样的：主线程每次进行AOF会对比上次fsync成功的时间；如果距上次不到2s，主线程直接返回；如果超过2s，则主线程阻塞直到fsync同步完成。因此，如果系统硬盘负载过大导致fsync速度太慢，会导致Redis主线程的阻塞；此外，使用everysec配置，AOF最多可能丢失2s的数据，而不是1s。</p><h1 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h1><p>配置可以开启混合持久化(必须先开启aof)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># aof‐use‐rdb‐preamble yes</span></span><br></pre></td></tr></table></figure><p><code>AOF</code>在重写时，不再是单纯将内存数据转换为<code>RESP</code>命令写入<code>AOF</code>文件，而是将重写这一刻之前的内存做<code>RDB</code>快照处理，并且将RDB快照内容和增量的<code>AOF</code>修改内存数据的命令存在一起，都写入新的<code>AOF</code>文件，新的文件一开始不叫appendonly.aof，等到重写完新的<code>AOF</code>文件才会进行改名，覆盖原有的<code>AOF</code>文件，完成新旧两个<code>AOF</code>文件的替换。<br>于是在 <code>Redis </code>重启的时候，<strong>可以先加载<code>RDB</code>的内容，然后再重放增量 AOF<code> 日志就可以完全替代之前的</code>AOF&#96; 全量文件重放，因此重启效率大幅得到提升。</strong><br>混合持久化AOF文件结构如下<br><img src="https://img-blog.csdnimg.cn/53438d24c0c549dc8483921497603df8.png" alt="在这里插入图片描述"></p><h1 id="Redis数据备份策略"><a href="#Redis数据备份策略" class="headerlink" title="Redis数据备份策略"></a>Redis数据备份策略</h1><ol><li>写crontab定时调度脚本，每小时都copy一份rdb或aof的备份到一个目录中去，仅仅保留最近48<br>小时的备份；</li><li>每天都保留一份当日的数据备份到一个目录中去，可以保留最近1个月的备份；</li><li>每次copy备份的时候，都把太旧的备份给删了；</li><li>每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏。</li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>别问我内存满了怎么办</title>
      <link href="/2022/10/27/redis/%E5%88%AB%E9%97%AE%E6%88%91%E5%86%85%E5%AD%98%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
      <url>/2022/10/27/redis/%E5%88%AB%E9%97%AE%E6%88%91%E5%86%85%E5%AD%98%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>分析:你redis只能存<strong>5G</strong>数据，可是你写了<strong>10G</strong>，那会删<strong>5G</strong>的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是<strong>时间到了，内存占用率还是比较高，有思考过原因么</strong>?</p><h1 id="先来回答第一个问题，怎么删数据？"><a href="#先来回答第一个问题，怎么删数据？" class="headerlink" title="先来回答第一个问题，怎么删数据？"></a>先来回答第一个问题，怎么删数据？</h1><p>内存满了，可以调大一点呀！！！</p><ul><li><code>Redis</code>中有配置参数<code>maxmemory</code>可以<strong>设置Redis内存的大小</strong>。<code>redis.conf</code>配置<code>maxmemory</code>的大小参数如下所示：</li></ul><blockquote><p>maxmemory 100G</p></blockquote><ul><li>通过命令修改,<code>Redis</code>支持运行时通过命令动态修改内存大小。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置Redis最大占用内存大小为100M</span><br><span class="line">127.0.0.1:6379&gt; config set maxmemory 100mb</span><br><span class="line">//获取设置的Redis能使用的最大内存大小</span><br><span class="line">127.0.0.1:6379&gt; config get maxmemory</span><br></pre></td></tr></table></figure></li></ul><p>但是实际的存储中超出了<code>Redis</code>的配置参数的大小时，Redis中有<code>淘汰策略</code>，把<code>需要淘汰的key给淘汰掉</code>，整理出干净的一块内存给新的key值使用。</p><h2 id="8-种淘汰策略"><a href="#8-种淘汰策略" class="headerlink" title="8 种淘汰策略"></a>8 种淘汰策略</h2><p>Redis 中提供了 8 种淘汰策略，可以通过参数 <code>maxmemory-policy </code>进行配置：</p><ul><li><strong>volatile-lru（最久未使用的）</strong>：根据<code>LRU</code>算法删除设置了<code>过期时间</code>的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错;</li><li><strong>volatile-lfu（最少使用的键值）</strong>根据 <code>LFU </code>算法删除设置了<code>过期时间</code>的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错;</li><li><strong>volatile-random</strong>随机删除设置了<code>过期时间</code>的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错;</li><li><strong>allkeys-lru</strong>： 根据 <code>LRU</code> 算法删除<code>所有</code>的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错;</li><li><strong>allkeys-lfu</strong>根据<code> LFU</code> 算法删除<code>所有</code>的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错;</li><li><strong>allkeys-random</strong>随机删除所有键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错;</li><li><strong>volatile-ttl</strong>根据键值对象的 ttl 属性， 删除最近将要过期数据。如果没有，则直接报错;</li><li><strong>noeviction</strong>默认策略，不作任何处理，直接报错。</li></ul><p>假如在Redis中的数据有<strong>一部分是热点数据，而剩下的数据是冷门数据</strong>，或者我们不太清楚我们应用的缓存访问分布状况，这时可以使用<code>allkeys-lru</code>。</p><p><strong>如何修改 Redis 内存淘汰策略？</strong></p><ul><li>淘汰策略也可以直接使用命令 <strong>config set maxmemory-policy &lt;策略&gt;</strong> 来进行动态配置。</li><li>通过修改 Redis 配置文件修改，设置<code>maxmemory-policy &lt;策略&gt;</code>，它的<strong>优点是重启 Redis 服务后配置不会丢失，缺点是必须重启 Redis 服务，设置才能生效</strong>。</li></ul><h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><p>LRU(Least Recently Used)即表示<strong>最近最少使用</strong>，算法根据数据的<strong>历史访问记录</strong>来进行淘汰数据。它的核心的思想就是：<strong>假如一个key值在最近很少被使用到，那么在将来也很少会被访问</strong>。<br>Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：</p><ul><li>需要用链表管理所有的缓存数据，这会带来额外的空间开销；</li><li>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li></ul><p>Redis使用的是近似的LRU算法，<strong>通过随机采集法淘汰key，每次都会随机选出5个key，然后淘汰里面最近最少使用的key</strong>。</p><blockquote><p>maxmemory-samples 5</p></blockquote><p>那么为了实现根据时间实现LRU算法，Redis必须为每个k<strong>ey中额外的增加一个内存空间用于存储每个key</strong>的时间，<strong>3字节</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS;<span class="comment">//记录对象最后一次被应用程序访问的时间（24位=3字节）</span></span><br><span class="line">    .....</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>Redis 实现的 LRU 算法的优点：</p><ul><li><strong>不用为所有的数据维护一个大链表，节省了空间占用</strong>；</li><li><strong>不用在每次数据访问时都移动链表项，提升了缓存的性能</strong>；</li></ul><p><code>lru 属性是创建对象的时候写入，对象被访问到时也会进行更新</code>。正常人的思路就是最后决定要不要删除某一个键肯定是用当前时间戳减去 <code>lru</code>，差值最大的就优先被删除。但是 <code>Redis </code>里面并不是这么做的，<strong>Redis 中维护了一个全局属性<code> lru_clock</code>，这个属性是通过一个全局函数<code> serverCron</code> 每隔 <code>100</code> 毫秒执行一次来更新的，记录的是当前<code> unix</code> 时间戳。最后决定删除的数据是通过 <code>lru_clock </code>减去对象的 <code>lru </code>属性而得出的</strong>。</p><p><strong>那么为什么 Redis 要这么做呢？直接取全局时间不是更准确吗？</strong></p><blockquote><p><strong>这是因为这么做可以避免每次更新对象的 lru 属性的时候可以直接取全局属性，而不需要去调用系统函数来获取系统时间，从而提升效率</strong>。</p></blockquote><p>不过这里还有一个问题，我们看到，redisObject 对象中的 <strong>lru 属性只有 24 位，24 位只能存储 194 天的时间戳大小，一旦超过 194 天之后就会重新从 0 开始计算</strong>，所以这时候就可能会出现 redisObject 对象中的 lru 属性大于全局的 lru_clock 属性的情况。</p><p>正因为如此，所以计算的时候也需要分为 2 种情况：</p><blockquote><p>当全局 lruclock &gt; lru，则使用 lruclock - lru 得到空闲时间。<br>当全局 lruclock &lt; lru，则使用 lruclock_max（即 194 天） - lru + lruclock 得到空闲时间。</p></blockquote><p><strong>Redis3.0对近似LRU的优化</strong><br>新算法会维护一个候选池（<strong>16</strong>），池中的数据根据访问时间进行排序，第一次<strong>随机选取的key都会放入池中</strong>，随后每次随机选取的key只有在<strong>访问时间小于池中最小的时间才会放入池中</strong>，直到候选池被放满。当放满后，如果有新的key需要放入，则将池中<strong>最近被访问</strong>的移除。当需要淘汰的时候，则直接从池中选取<strong>最近最久没被访问</strong>的key淘汰掉就行。</p><p><img src="https://img-blog.csdnimg.cn/6889b90b9a5b47e2930008f3314e32f1.png" alt="在这里插入图片描述"><br>你可以看到图中有三种不同颜色的点：</p><ul><li>浅灰色是被淘汰的数据。</li><li>灰色是没有被淘汰掉的老数据。</li><li>绿色是新加入的数据。</li></ul><p>LRU算法有一个弊端：</p><ul><li><strong>就是假如一个key值在以前都没有被访问到，然而最近一次被访问到了，那么就会认为它是热点数据，不会被淘汰</strong>。</li><li><strong>然而有些数据以前经常被访问到，只是最近的时间内没有被访问到，这样就导致这些数据很可能被淘汰掉，这样一来就会出现误判而淘汰热点数据</strong>。</li></ul><h2 id="LFU-算法"><a href="#LFU-算法" class="headerlink" title="LFU 算法"></a>LFU 算法</h2><p>LFU即表示<strong>最近最不常用的</strong>，以最近的时间段的被访问次数的频率作为一种判断标准。它的核心思想就是：<strong>根据key最近被访问的频率进行淘汰，比较少被访问的key优先淘汰。</strong><br>当我们采用<code>LFU</code>回收策略时，<code>lru</code> 属性的高<code>16</code>位用来记录访问时间(<code>ldt</code>)，低 <code>8 </code>位用来记录访问频率 (<code>logic</code>)。<br><img src="https://img-blog.csdnimg.cn/4bf15bc5423644a8b7f3f1af7a540a5f.png" alt="在这里插入图片描述"></p><ul><li><code>ldt</code> 是用来记录 key 的访问时间戳；</li><li><code>logc</code> 是用来记录 key 的访问频次，它的值越小表示使用频率越低，越容易淘汰，每个新加入的 key 的<strong>logc 初始值为 5</strong>。<code>logc</code> 是访问频次，因为<code>logc</code>会随时间<strong>推移而衰减</strong>的。</li></ul><p><strong>lfu算法 key 频率变化的流程</strong></p><ul><li>在每次<code> key</code> 被访问时，会先对<code>logc</code>做一个衰减操作，衰减的值跟前后<strong>访问时间的差距</strong>有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大。</li><li>对<code>logc</code>做完衰减操作后，就开始对<code>logc</code>进行增加操作，增加操作并不是单纯的 <code>+ 1</code>，而是根据概率增加，如果 <code>logc </code>越大的 <code>key</code>，它的 logc 就越难再增加。</li></ul><p><code>redis.conf </code>提供了两个配置项，用于调整<code>LFU </code>算法从而控制 <code>logc </code>的增长和衰减：</p><p><code>lfu-decay-time </code>用于调整 logc 的衰减速度，它是一个以分钟为单位的数值，默认值为1，<code>lfu-decay-time </code>值越大，衰减越慢；<br><code>lfu-log-factor</code> 用于调整 logc 的增长速度，<code>lfu-log-factor</code> 值越大，<code>logc</code>增长越慢。</p><h1 id="时间到了，内存占用率还是比较高"><a href="#时间到了，内存占用率还是比较高" class="headerlink" title="时间到了，内存占用率还是比较高?"></a>时间到了，内存占用率还是比较高?</h1><h2 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h2><p>使用Redis 服务时，为了防止数据一直占有内存，我们可以给键值对设置有效期。Redis 中可以通过 4 个独立的命令来给一个键设置过期时间：</p><blockquote><p>expire key ttl：将 key 值的过期时间设置为 ttl 秒。<br>   pexpire key ttl：将 key 值的过期时间设置为 ttl 毫秒。<br>   expireat key timestamp：将 key 值的过期时间设置为指定的 timestamp 秒数。<br>   pexpireat key timestamp：将 key 值的过期时间设置为指定的 timestamp 毫秒数。</p></blockquote><p>设置了有效期后，可以通过 ttl 和 pttl 两个命令来查询剩余过期时间（如果未设置过期时间则下面两个命令返回 -1，如果设置了一个非法的过期时间，则都返回 -2）：</p><blockquote><p>ttl key 返回 key 剩余过期秒数。<br>pttl key 返回 key 剩余过期的毫秒数。</p></blockquote><h2 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h2><ul><li><strong>定时删除</strong>：为每个键设置一个定时器，一旦过期时间到了，则将键删除。这种策略对内存很友好，但是对 CPU 不友好，因为每个定时器都会占用一定的 CPU 资源。</li><li><strong>惰性删除</strong>：不管键有没有过期都<strong>不主动删除</strong>，等到每次去获取键时再判断是否<strong>过期</strong>，如果过期就删除该键，否则返回键对应的值。这种策略对<strong>内存不够友好，可能会浪费很多内存</strong>。</li><li><strong>定期扫描</strong>：系统每隔一段时间就<strong>定期扫描一次</strong>，发现<strong>过期的键就进行删除</strong>。这种策略相对来说是上面两种策略的折中方案，需要注意的是这个定期的频率要结合实际情况掌控好，<strong>使用这种方案有一个缺陷就是可能会出现已经过期的键也被返回。</strong><br>在 Redis 当中，其选择的是<strong>惰性删除</strong>和<strong>定期扫描</strong>的综合使用。不过 Redis 的<strong>定期扫描只会扫描设置了过期时间的键</strong>，因为设置了过期时间的键 Redis 会单独存储。</li></ul><h2 id="如何判定-key-已过期了？"><a href="#如何判定-key-已过期了？" class="headerlink" title="如何判定 key 已过期了？"></a>如何判定 key 已过期了？</h2><p>   每当我们对一个 <code>key</code>设置了过期时间时，Redis 会把该<code>key</code>带上过期时间存储到一个<code>过期字典</code>中，也就是说<code>过期字典</code>保存了数据库中所有 key 的过期时间。</p><h1 id="过期删除策略和淘汰策略的区别？"><a href="#过期删除策略和淘汰策略的区别？" class="headerlink" title="过期删除策略和淘汰策略的区别？"></a>过期删除策略和淘汰策略的区别？</h1><ul><li><p>Redis 使用的<strong>过期删除策略</strong>是<strong>惰性删除+定期删除</strong>，删除的对象是<strong>已过期的 key</strong>；</p></li><li><p><strong>内存淘汰策略</strong>是解决<strong>内存过大</strong>的问题，当 Redis 的运行内存超过最大运行内存时，就会触发内存淘汰策略。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试必须要明白的三次握手，四次挥手</title>
      <link href="/2022/10/27/%E7%BD%91%E7%BB%9C/%E5%BF%85%E9%97%AE%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2022/10/27/%E7%BD%91%E7%BB%9C/%E5%BF%85%E9%97%AE%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近学习了计算机网络的知识，看了很多的视频，并参考了很多资料，写下了这篇文章，如果有什么写的并不准确的地方，还请大佬不吝赐教。</p><h3 id="什么是-TCP"><a href="#什么是-TCP" class="headerlink" title="什么是 TCP"></a>什么是 TCP</h3><p><img src="https://img-blog.csdnimg.cn/c446286813fe48a3a3c7fe20ddd29efd.png" alt="在这里插入图片描述"><br>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><ul><li><strong>面向连接</strong>：只能一对一才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息。</li><li><strong>可靠的</strong>：TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li><li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统<strong>分组成</strong>多个的 TCP 报文，并且 TCP 报文是<strong>有序的</strong>，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对<strong>重复的 TCP 报文</strong>会自动丢弃。</li></ul><h3 id="TCP-头格式"><a href="#TCP-头格式" class="headerlink" title="TCP 头格式"></a>TCP 头格式</h3><p><img src="https://img-blog.csdnimg.cn/f8b2af39818347b794c54a961feeb697.png" alt="在这里插入图片描述"></p><ul><li>源端口和目的端口，各占2个字节。</li><li>seq   Sequence Number 序列号，4字节，用来标识TCP发端向TCP收端发送的数据字节流。<strong>用来解决网络包乱序问题。</strong></li><li>ack  Acknowledgment Number，确认应答号，4字节，表示接收方期望收到发送方下一个报文段的第一个字节数据的序列号。<strong>用来解决丢包的问题</strong></li><li>控制位：<ul><li>ACK 表示应答，该位为 1 时，确认应答的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。 </li><li>RST：该位为 1 时，表示 TCP 连接中出现异常必须<strong>强制断开连接</strong>。</li><li>SYN：该位为 1 时，表示希望<strong>建立连接</strong>，并在其<strong>序列号 （seq）</strong>的字段进行序列号初始值的设定。</li><li>FIN：该位为 1 时，表示今后不会再有数据发送，<strong>希望断开连接</strong>。当通信结束希望断开连接时。</li><li>紧急URG，当URG&#x3D;1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</li><li>推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH&#x3D;1；</li></ul></li><li>数据偏移(首部长度)，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；<br>保留，占6位，保留今后使用，但目前应都位0；</li><li>检验和，占2字节，校验首部和数据这两部分；</li><li>紧急指针，占2字节，指出本报文段中的紧急数据的字节数；</li><li>窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；</li><li>选项，长度可变，定义一些其他的可选的参数。</li></ul><h3 id="什么是-TCP-连接？"><a href="#什么是-TCP-连接？" class="headerlink" title="什么是 TCP 连接？"></a>什么是 TCP 连接？</h3><p>用于保证<strong>可靠性和流量控制</strong>维护的某些状态信息，这些信息的组合，包括<strong>Socket、序列号和窗口大小</strong>称为TCP连接。<br><img src="https://img-blog.csdnimg.cn/96eed0d554034534a1eb4b75a1d046cf.png" alt="在这里插入图片描述"></p><ul><li>Socket：由 IP 地址和端口号组成</li><li>序列号：用来解决乱序问题等</li><li>窗口大小：用来做流量控制</li></ul><h3 id="如何唯一确定一个-TCP-连接呢？"><a href="#如何唯一确定一个-TCP-连接呢？" class="headerlink" title="如何唯一确定一个 TCP 连接呢？"></a>如何唯一确定一个 TCP 连接呢？</h3><ul><li><strong>源地址</strong></li><li><strong>源端口</strong></li><li><strong>目的地址</strong></li><li><strong>目的端口</strong></li></ul><p> <strong>源地址</strong>和<strong>目的地址</strong>的字段（32位）是在 IP 头部中，作用是<strong>通过 IP 协议发送报文给对方主机</strong>。<br><strong>源端口</strong>和<strong>目的端口</strong>的字段（16位）是在 TCP 头部中，作用是<strong>告诉 TCP 协议应该把报文发给哪个进程。</strong></p><h3 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a>TCP 连接建立</h3><h4 id="三次握手过程-重点"><a href="#三次握手过程-重点" class="headerlink" title="三次握手过程(重点)"></a>三次握手过程(重点)</h4><p>首先举一个生活中常见的例子:<br>此时<strong>蔡蔡和new出来的对象拨通了电话</strong>:<br><img src="https://img-blog.csdnimg.cn/addb2014a104450eacd887757c033338.png" alt="在这里插入图片描述"><br>你 ：“喂，能听到我说话吗?”<br>你对象 ：“亲爱的，我可以听到!，你听得到吗”<br>你 ：“当然啦。。。。。。”<br>然后就可以正常交流了。<br><img src="https://img-blog.csdnimg.cn/6f6f45b05ce24e27b0ec1a4cae8a2dfd.png" alt="在这里插入图片描述"></p><ul><li>一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态</li><li>客户端会<strong>随机初始化</strong>序号，将此序号置于 TCP 首部的序号seq字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，之后客户端处于 <strong>SYN-SENT</strong> 状态。<strong>TCP规定，（SYN&#x3D;1的报文段）不能携带数据，但需要消耗掉一个序号。</strong></li><li>服务端收到客户端的 <strong>SYN</strong> 报文后，首先服务端也<strong>随机初始化</strong>序号，将此序号填入 TCP 首部的<strong>序号seq字段</strong>中，其次把 TCP 首部的<strong>确认应答号</strong>ack字段填入<strong>客户端的seq+ 1</strong>, 接着把 <strong>SYN 和 ACK</strong> 标志位置为 1。最后把该报文发给客户端，之后服务端处于 SYN-RCVD 状态。<strong>这个报文也不能携带数据，但是同样要消耗一个序号。</strong></li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 <strong>TCP 首部 ACK 标志位置为 1</strong> ，其次确认应答号字段填入<strong>服务端的seq + 1</strong>，最后把报文发送给服务端，之后客户端处于 ESTABLISHED 状态。TCP规定，ACK报文段可以携带数据，<strong>但是如果不携带数据则不消耗序号。</strong></li></ul><h5 id="为什么是三次握手？不是两次、四次？（重点）"><a href="#为什么是三次握手？不是两次、四次？（重点）" class="headerlink" title="为什么是三次握手？不是两次、四次？（重点）"></a>为什么是三次握手？不是两次、四次？（重点）</h5><p><strong>1.确认双方具有接收和发送的能力</strong><br>第一次握手：服务端<strong>接受</strong>数据正常<br>第二次握手：客户端<strong>发送和接受</strong>数据正常<br>第二次握手：服务端<strong>发送和接受</strong>数据正常<br><strong>2.三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接。</strong></p><ul><li>避免历史连接<br><img src="https://img-blog.csdnimg.cn/d3e19ba18f734ba0b40fd3c4a74afde6.png" alt="在这里插入图片描述"></li><li>一个旧 SYN 报文比最新的 SYN  报文早到达了服务端；</li><li>那么此时服务端就会回一个 SYN + ACK 报文给客户端；</li><li>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。</li></ul><p>如果是<strong>两次握手连接</strong>，就无法阻止历史连接，那为什么 TCP 两次握手为什么无法阻止历史连接呢？</p><p><img src="https://img-blog.csdnimg.cn/a46706d8fcd1468e8440b4a7243a27ec.png" alt="在这里插入图片描述"><br>在两次握手的情况下，服务端没有<strong>中间状态（SYNC RECV)<strong>给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。两次握手的情况下，服务端在收到 SYN 报文后，就进入 <strong>ESTABLISHED</strong> 状态，意味着这时可以</strong>给对方发送数据</strong>，但是客户端此时还没有进入 ESTABLISHED 状态，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。</p><ul><li>同步双方初始序列号</li></ul><p>序列号是可靠传输的一个关键因素，它的作用：<br>1.接收方可以去除重复的数据；<br>2.接收方可以根据数据包的序列号按序接收；<br>3.可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；<br><img src="https://img-blog.csdnimg.cn/3a577132608844699bff3cfd49b57faa.png" alt="在这里插入图片描述"><br>四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成一步，所以就成了三次握手。而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p><p>TCP 建立连接时，通过三次握手能<strong>防止历史连接的建立</strong>，<strong>能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输</strong>。</p><p>不使用两次握手和四次握手的原因：<br>两次握手：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；<br>四次握手：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数</p><h5 id="第一次握手丢失了，会发生什么？"><a href="#第一次握手丢失了，会发生什么？" class="headerlink" title="第一次握手丢失了，会发生什么？"></a>第一次握手丢失了，会发生什么？</h5><p>如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且重传的 SYN 报文的序列号都是一样的。每次超时的时间是上一次的 2 倍。</p><h5 id="第二次握手丢失了，会发生什么？"><a href="#第二次握手丢失了，会发生什么？" class="headerlink" title="第二次握手丢失了，会发生什么？"></a>第二次握手丢失了，会发生什么？</h5><p>第二次握手的 SYN-ACK 报文其实有两个目的 ：</p><ul><li>第二次握手里的 ACK， 是对第一次握手的确认报文；</li><li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</li></ul><p> 因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是客<strong>户端就会触发超时重传机制，重传 SYN 报文</strong>。<br>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。<br>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p><h5 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="第三次握手丢失了，会发生什么？"></a>第三次握手丢失了，会发生什么？</h5><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 ESTABLISH 状态。</p><p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果<strong>服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文</strong>，直到收到第三次握手，或者达到最大重传次数<strong>。注意，ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。</strong></p><h4 id="半连接队列和全连接队列"><a href="#半连接队列和全连接队列" class="headerlink" title="半连接队列和全连接队列"></a>半连接队列和全连接队列</h4><p><img src="https://img-blog.csdnimg.cn/036732a5f3bc46dfb1b766cffcf7def9.png" alt="在这里插入图片描述"></p><p><strong>半连接队列(syn queue)</strong><br>客户端发送SYN包，服务端收到后回复SYN+ACK后，服务端进入SYN_RCVD状态，此时双方还没有完全建立连接，这个时候的socket会放到半连接队列。</p><p><strong>全连接队列(accept queue)</strong><br>当服务端收到客户端的ACK后，socket会从半连接队列移出到全连接队列。当调用accpet函数的时候，会从全连接队列的头部返回可用socket给用户进程。全连接队列中存放的是已完成TCP三次握手的过程，等待被处理的连接，在客户端及服务端的状态均为 ESTABLISHED。</p><p>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文。<br><strong>SYN 攻击</strong>方式最直接的表现就会把 <strong>TCP 半连接队列打满</strong>，这样当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃，导致客户端无法和服务端建立连接。</p><p>避免 SYN 攻击方式，可以有以下四种方法：</p><ul><li><strong>调大 netdev_max_backlog；</strong></li><li><strong>增大 TCP 半连接队列；</strong></li><li><strong>开启 tcp_syncookies：</strong>可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。 </li><li><strong>减少 SYN+ACK 重传次数</strong></li></ul><h4 id="什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击？"></a>什么是 SYN 攻击？如何避免 SYN 攻击？</h4><p>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的半连接队列，使得服务器不能为正常用户服务。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="https://img-blog.csdnimg.cn/817f4f775a7a4577bec0f9875c29d5cc.png" alt="在这里插入图片描述"></p><ul><li>刚开始客户端和服务端都处于ESTABLISHED状态，假如客户端主动发起关闭请求：</li><li>第一次挥手：TCP客户端向服务端发送一个FIN报文，用来关闭客户端到服务端的数据传送，其中包含一个序列号seq&#x3D;x，发送完后，客户端进入<strong>FIN_WAIT_1状态(不再发送数据，但是可以接收服务器发来的报文)<strong>。</strong>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</strong></li><li>第二次挥手：服务端接收到FIN报文后，会发回一个ACK，表明自己已经接收到了此报文，但是服务端可能还有数据要传），此时服务端进入CLOSE_WAIT关闭等待状态。这个时候TCP处于<strong>半关闭</strong>状态，当客户端接收到服务端的回复后，进入<strong>FIN_WAIT_2状态</strong>。</li><li>第三次挥手：服务器关闭客户端的连接，发送一个FIN报文给客户端，并且指定一个序列号，ack的值为x+1，此时服务器处于<strong>LAST_ACK</strong>最后确认状态，等待客户端回应。</li><li>第四次挥手 :客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack &#x3D; w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值,此时客户端处于 <strong>TIME_WAIT</strong>（时间等待状态）。TIME-WAIT状态是为了等待足够的时间以确保远程TCP接收到连接中断请求的确认。</li><li></li></ul><h5 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h5><p>第一次挥手：仅仅表示客户端不再发送数据了但是还能接收数据。<br>第二次挥手：服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送。<br>第三次挥手：等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。<br>第四次挥手：客户端收到服务端FIN报文。</p><h5 id="第一次挥手丢失了，会发生什么？"><a href="#第一次挥手丢失了，会发生什么？" class="headerlink" title="第一次挥手丢失了，会发生什么？"></a>第一次挥手丢失了，会发生什么？</h5><p>正常情况下： 如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 FIN_WAIT2状态。<br>第一次挥手丢失了：客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文。<br>客户端重传 FIN 报文的次数超过，就不再发送 FIN 报文，则会在等待一段时间，如果还是没能收到第二次挥手，那么直接进入到 close 状态。</p><h5 id="第二次挥手丢失了，会发生什么？"><a href="#第二次挥手丢失了，会发生什么？" class="headerlink" title="第二次挥手丢失了，会发生什么？"></a>第二次挥手丢失了，会发生什么？</h5><p>正常情况下： 服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 CLOSE_WAIT 状态。<br>但是<strong>ACK 报文是不会重传的</strong>，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p><h5 id="第三次挥手丢失了，会发生什么？"><a href="#第三次挥手丢失了，会发生什么？" class="headerlink" title="第三次挥手丢失了，会发生什么？"></a>第三次挥手丢失了，会发生什么？</h5><p>正常情况下：服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。<br>异常：服务端迟迟收不到这个 ACK，服务端就会重发 FIN 报文。</p><h5 id="第四次挥手丢失了，会发生什么？"><a href="#第四次挥手丢失了，会发生什么？" class="headerlink" title="第四次挥手丢失了，会发生什么？"></a>第四次挥手丢失了，会发生什么？</h5><p>正常：客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 TIME_WAIT 状态。TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。<br>异常：第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文。客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。</p><h4 id="为什么需要-TIME-WAIT-状态，为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么需要-TIME-WAIT-状态，为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么需要 TIME_WAIT 状态，为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么需要 TIME_WAIT 状态，为什么 TIME_WAIT 等待的时间是 2MSL？</h4><p><strong>主动发起关闭连接的一方，才会有 TIME-WAIT 状态。</strong><br>1、防⽌客户端最后⼀次发给服务器的确认在⽹络中丢失以⾄于客户端关闭，⽽服务端并未关闭，导致资源的浪费。<br>2、等待最⼤的2msl可以让本次连接的所有的⽹络包在链路上消失，以防造成不必要的⼲扰。<br>客户端直接closed，然后⼜向服务端发起了⼀个新连接，我们不能保证这个新连接和刚关闭的连接的端⼝号是不同的。假设新连接和已经关闭的⽼端⼝号是⼀样的，如果<strong>前⼀次滞留的某些数据仍然在⽹络中（防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中）</strong>，这些延迟数据会在新连接建⽴后到达服务端，所以socket就认为那个延迟的数据是属于新连接的，数据包就会发⽣混淆。所以客户端要在TIME_WAIT状态等待2倍的MSL，这样保证本次连接的所有数据都从⽹络中消失。</p><h5 id="TIME-WAIT-过多有什么危害？"><a href="#TIME-WAIT-过多有什么危害？" class="headerlink" title="TIME_WAIT 过多有什么危害？"></a>TIME_WAIT 过多有什么危害？</h5><p>第一是<strong>占用系统资源</strong>，比如文件描述符、内存资源、CPU 资源、线程资源等；（服务端）<br>第二是<strong>占用端口资源</strong>，端口资源也是有限的。（客户端）<br>客户端和服务端 TIME_WAIT 过多，造成的影响是不同的。<br>如果<strong>客户端的 TIME_WAIT 状态过多，占满了所有端口资源，那么就无法对目的 IP+ 目的 PORT都一样的服务器发起连接了</strong>。不过，只要<strong>连接的是不同的服务器</strong>，<strong>端口是可以重复使用的，所以客户端还是可以向其他服务器发起连接的</strong>，这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的。<br>如果服务端的 TIME_WAIT 状态过多，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如<strong>文件描述符、内存资源、CPU 资源、线程资源</strong>等。</p><h5 id="如何优化-TIME-WAIT？"><a href="#如何优化-TIME-WAIT？" class="headerlink" title="如何优化 TIME_WAIT？"></a>如何优化 TIME_WAIT？</h5><ul><li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；-有一点需要只能用客户端（连接发起方），因为开启了该功能，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br></pre></td></tr></table></figure><p>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps=1（默认即为 1）</span><br></pre></td></tr></table></figure><ul><li>net.ipv4.tcp_max_tw_buckets</li></ul><p>这个值默认为 18000，当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置，这个方法比较暴力。</p><ul><li>程序中使用 SO_LINGER<br>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</li></ul><p>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT。</p><p>文章到这里就结束了。如果您看完了此文章，觉得有什么不准确或者需要改进的地方，请大佬指正。或者有什么不懂的地方，都可以提出来，会耐心解答的。<br><img src="https://img-blog.csdnimg.cn/4b6825fe89744e15a71c117d94bf99df.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper学习（四）场景篇</title>
      <link href="/2022/10/27/zookeeper/zookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9C%BA%E6%99%AF%E7%AF%87/"/>
      <url>/2022/10/27/zookeeper/zookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9C%BA%E6%99%AF%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Zookeeper-的典型应用场景"><a href="#1-Zookeeper-的典型应用场景" class="headerlink" title="1.Zookeeper 的典型应用场景"></a>1.Zookeeper 的典型应用场景</h2><p><code>Zookeeper</code> 是一个典型的发布&#x2F;订阅模式的分布式数据管理与协调框架，开发人员可以使用它来进行分布式数据的发布和订阅。<br>通过对 <code>Zookeeper</code> 中丰富的数据节点进行交叉使用，配合 <code>Watcher</code> 事件通知机制，可以非常方便的构建一系列分布式应用中年都会涉及的核心功能，如：</p><ul><li>数据发布&#x2F;订阅</li><li>负载均衡</li><li>命名服务</li><li>分布式协调&#x2F;通知</li><li>集群管理</li><li>Master 选举</li><li>分布式锁</li><li>分布式队列</li></ul><h3 id="1-1数据发布-x2F-订阅"><a href="#1-1数据发布-x2F-订阅" class="headerlink" title="1.1数据发布&#x2F;订阅"></a>1.1数据发布&#x2F;订阅</h3><p>发布者将数据发布到<code>Zookeeper</code>的一个或一系列节点上，供订阅者进行数据订阅，进而达到动态获取数据的目的，实现配置信息的集中式管理和数据的动态更新<br>发布&#x2F;订阅系统的两种设计模式：</p><ul><li><code>PUSH</code>：服务端主动把数据更新发送给所有订阅者客户端</li><li><code>PULL</code>：客户端主动发起请求来获取最新数据，通常是定时轮训拉取方式</li><li><strong>Zookeeper采用推拉结合的方式</strong>：客户端向服务端注册自己需要关注的节点，一旦该节点的数据发生更改，那么服务端就会向相应的客户端发送Watcher事件通知，客户端接收到这个消息通知后，需要主动到服务端拉取最新的数据。</li></ul><p> 数据（配置信息）特性：<br>（1）数据量通常比较小<br>（2）数据内容在运行时会发生动态更新<br>（3）集群中各机器共享，配置一致</p><h3 id="1-2-负载均衡"><a href="#1-2-负载均衡" class="headerlink" title="1.2 负载均衡"></a>1.2 负载均衡</h3><p><img src="https://img-blog.csdnimg.cn/08ff0dd7eb614f8eb0652dd43b5ddc78.png" alt="在这里插入图片描述"></p><p>在分布式的环境中，我们常常使用集群部署的方式来提高某个服务的可用性，为了让高并发的请求能够平均的分配到集群中的每一个服务，避免有些服务压力过大，而有些服务处于空闲状态这样的情况，我们需要制定一些规则来把请求进行路由，这种分配请求的做法就叫做负载均衡，路由请求的规则就是负载均衡的策略。</p><h4 id="1-2-1常见的负载均衡策略："><a href="#1-2-1常见的负载均衡策略：" class="headerlink" title="1.2.1常见的负载均衡策略："></a>1.2.1常见的负载均衡策略：</h4><ul><li><code>Round Robin</code> 轮询策略</li><li><code>Random </code>随机策略<br>-<code> Consistent Hashing</code> 一致性哈希策略</li><li>加权随机策略</li><li>加权轮询策略</li></ul><h4 id="1-2-2-Zookeeper-实现负载均衡"><a href="#1-2-2-Zookeeper-实现负载均衡" class="headerlink" title="1.2.2 Zookeeper 实现负载均衡"></a>1.2.2 Zookeeper 实现负载均衡</h4><ul><li>服务注册：对于集群中的<code>server</code>（服务提供者）在启动过程中，把自身的地址信注册到<code>zookeeper</code>集群中（临时节点）</li><li>服务发现：针对服务消费者通过zookeeper来获得需要调用的服务名称节点下的机器列表节点。</li><li>服务调用：通过前面所介绍的负载均衡算法，选取其中一台服务器进行调用。<br>在这个过程中，服务消费者只有在第一次调用服务时需要查询<code>zookeeper</code>（服务配置中心），然后将查询到的服务信息缓存到本地，后面的调用直接使用本地缓存的服务地址列表信息，而不需要重新发起请求到服务配置中心去获取相应的服务地址列表，直到服务的地址列表有变更(机器上线或者下线)，变更行为会触发服务消费者注册的相应的<code>watcher</code>进行服务地址的重新查询。这种无中心化的结构，使得服务消费者在服务信息没有变更时，几乎不依赖配置中心，解决了之前负载均衡设备所导致的单点故障的问题，并且大大降低了服务配置中心的压力。</li></ul><p>通过Zookeeper来实现<strong>服务动态注册、机器上线与下线的动态感知，扩容方便，容错性好，且无中心化结构</strong>能够解决之前使用负载均衡设备所带来的单点故障问题。</p><p><strong>ZooKeeper负载均衡和Nginx负载均衡区别：</strong><br>ZooKeeper： <strong>不存在单点问题</strong>，zab机制保证单点故障可重新选举一个leader只负责服务的注册与发现，不负责转发，减少一次数据交换（消费方与服务方直接通信），<strong>需要自己实现相应的负载均衡算法</strong>。<br>Nginx： <strong>存在单点问题</strong>，单点负载高数据量大,需要通过 KeepAlived + LVS 备机实现高可用。每次负载，都充当一次中间人转发角色，增加网络负载量（消费方与服务方间接通信），<strong>自带负载均衡算法</strong>。</p><p>但是<strong>突然有一台服务器出现问题怎么办</strong>？<br>所以服务器提供负载均衡需要做到<strong>健康检测机制</strong>。</p><h4 id="1-2-3健康检查"><a href="#1-2-3健康检查" class="headerlink" title="1.2.3健康检查"></a>1.2.3健康检查</h4><p>健康检查用于检查服务器开放的各种服务的可用状态。<br>例如创建一个<code>HTTP</code>健康检查，<code>Get</code>一个页面回来，并且检查页面内容是否包含一个指定的字符串，如果包含，则服务是<strong>可用</strong>的，如果不包含或者取不回页面，就认为该服务器的<code>Web</code>服务是不可用（<code>DOWN</code>）的。<br>创建健康检查时可以设定<strong>检查的间隔时间和尝试次数</strong>，例如设定间隔时间为5秒，尝试次数为<code>3</code>，那么负载均衡设备每隔<code>5</code>秒发起一次健康检查，如果检查失败，则尝试<code>3</code>次，如果<code>3</code>次都检查失败，则把该服务标记为<code>DOWN</code>，然后服务器仍然会每隔<code>5</code>秒对<code>DOWN</code>的服务器进行检查，当某个时刻发现该服务器健康检查又成功了，则把该服务器重新标记为<code>UP</code>。健康检查的间隔时间和尝试次数要根据综合情况来设置，<code>**原则是既不会对业务产生影响，又不会对负载均衡设备造成较大负担**。 **健康检测两种方式：**         第一种：服务端主动发起心跳检测，这种方式需要服务端和客户端建立起一个</code>TCP&#96;长链接；<br>        第二种：客户端向服务端发起健康心跳检测。</p><h3 id="1-3-命名服务"><a href="#1-3-命名服务" class="headerlink" title="1.3 命名服务"></a>1.3 命名服务</h3><p>命名服务是指通过指定的名字来获取资源或者服务的地址，利用 <code>zk</code> 创建一个全局唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。<br><img src="https://img-blog.csdnimg.cn/f6f6e7bc0cfb4c12af13c40df7ae25a4.png" alt="在这里插入图片描述"></p><h3 id="1-4-分布式协调-x2F-通知"><a href="#1-4-分布式协调-x2F-通知" class="headerlink" title="1.4 分布式协调&#x2F;通知"></a>1.4 分布式协调&#x2F;通知</h3><ul><li>心跳检测：基于<code>Zookeeper</code>临时节点的特性，不同的机器在<code>Zookeeper</code>的一个指定节点下创建临时节点，不同机器根据临时节点判断客户端是否存活。通过这种方式：<strong>检测系统和被检测系统之间</strong>不需要直接关联，而是通过<code>Zookeeper</code>上某个节点进行关联，大大减少了系统耦合。</li><li>工作进度汇报：通过在一个节点下创建临时子节点实现两个功能：<ul><li>判断任务机是否存活</li><li>各个任务机器实时的将自己的任务执行进度写到这个临时节点</li></ul></li><li>系统调度：修改某些节点数据 ，以事件通知形式发送给对应的订阅端</li></ul><h3 id="1-5-集群管理"><a href="#1-5-集群管理" class="headerlink" title="1.5 集群管理"></a>1.5 集群管理</h3><p>所谓集群管理无在乎两点：是否有机器退出和加入、选举 <code>master</code>。<br>根据<code>Zookeeper</code>两大特性：<strong>注册watcher事件通知</strong> 和 <strong>临时节点特性</strong><br>对于第一点，所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与<code> zookeeper</code> 的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。<br>新机器加入也是类似，所有机器收到通知：新兄弟目录加入，<code>highcount</code> 又有了。<br>对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为 <code>master</code> 就好。</p><p>集群示例:</p><ul><li>分布式日志收集系统:收集器机器，根据不同的业务日志区分，对应创建节点，每个节点存储日志源机器列表，如果收集器节点宕机，新增收集器节点。</li></ul><h3 id="1-6-分布式锁"><a href="#1-6-分布式锁" class="headerlink" title="1.6 分布式锁"></a>1.6 分布式锁</h3><h4 id="1-6-1-分布式锁的特点"><a href="#1-6-1-分布式锁的特点" class="headerlink" title="1.6.1 分布式锁的特点"></a>1.6.1 分布式锁的特点</h4><p>顾名思义，分布式锁就是实现在分布式网络环境中的锁。也就是说，在锁的基础上加上分布式的特性，我们来分析一下分布式锁实现的必要条件：</p><ul><li>在分布式环境中，多个进程对资源的访问必须具有顺序性；</li><li>获取锁和释放锁的过程需要高可用和高性能；</li><li>具有锁失效的机制，避免死锁；</li><li>非阻塞的锁，没有获取到锁直接返回获取锁失败。</li></ul><h4 id="1-6-2-分布式锁的实现技术"><a href="#1-6-2-分布式锁的实现技术" class="headerlink" title="1.6.2 分布式锁的实现技术"></a>1.6.2 分布式锁的实现技术</h4><p>Redis： 使用 <code>setnx</code> 命令来添加<code> key</code>，<code>key</code> 添加成功说明当前无人使用此 <code>key</code>，也就是说无人使用此资源，相当于获取锁。再次使用 <code>setnx </code>命令来添加相同的<code> key</code> 时，此时 <code>key</code>已存在就会添加失败，说明有人已经使用了这个 key，也就是说此资源被人占用，相当于获取锁失败；<br>Zookeeper： 使用 <code>Zookeeper</code> 临时顺序节点的特性，实现分布式锁和锁的等待队列。</p><h4 id="1-6-3-分布式锁常用的类型"><a href="#1-6-3-分布式锁常用的类型" class="headerlink" title="1.6.3 分布式锁常用的类型"></a>1.6.3 分布式锁常用的类型</h4><p>分布式锁常用的类型有两种：一种是排他锁，一种是共享锁。<br><strong>排他锁</strong><br>排他锁也叫独占锁，顾名思义，也就是对资源进行独占。排他锁只允许获取了该锁的线程，对具有排他锁的资源进行访问，无论是写操作还是读操作，直到该线程主动释放掉排他锁。<br><strong>共享锁</strong><br>共享锁也就是把资源进行共享，当然共享的只有读操作。共享锁只对写操作进行加锁，其它线程的读操作不做加锁操作，这样的共享机制提高了对资源访问的性能。</p><p>排他锁：X锁<br>    1、定义锁：通过数据节点表示一个锁，例如：<code>/zookeeper_lock/lock</code>节点<br>    2、获取锁：所有的客户端<code>/zookeeper_lock/</code>下创建<strong>临时子节点</strong> <code>/zookeeper_lock/lock</code>。<code>Zookeeper</code>保证只有一个客户端能创建成功，为获取锁，同时，所有没有创建成功的客户端要在<code>/zookeeper_lock</code>节点注册一个子节点变更的<code>Watche</code>r监听。<br>    3、释放锁：当客户端宕机或者执行完成后，主动将自己的创建的临时节点删除。<code>Zookeeper</code>会将子节点变更通知给所有注册了该节点Watcher的客户端，客户端收到通知后，再次重新发起分布式锁获取。</p><p>共享锁：S锁<br><img src="https://img-blog.csdnimg.cn/ed8b2bf067d146359af4da69ab9f2c9a.png" alt="在这里插入图片描述"></p><ol><li>定义锁：通过数据节点表示一个锁，例如：”&#x2F;zookeeper_shared_lock&#x2F;请求类型-序号”的<strong>临时顺序节点</strong>，如：&#x2F;zookeeper_shared_lock&#x2F;R-000000001。</li><li>获取锁：在需要获取共享锁时，在&#x2F;zookeeper_shared_lock&#x2F;下创建临时节点。 </li><li>判断读写顺序：<br> 3.1.  获取&#x2F;shared_lock下的所有子节点，并对该节点注册子节点变更的Watcher监听 <br> 3.2.确定自己的节点序号顺序<br>3.3 分类逻辑：对于读请求：如果没有比自己更小的序号的子节点，或是所有比自己序号的小的子节点都是读请求，那么表明自己已经成功获取S锁，执行读逻辑，如果比自己序号小的请求中有写请求，那么等待对于写请求：如果自己不是序号最小的子节点，那么等待 。对于写请求：如果自己不是序号最小的子节点，那么等待。</li><li>接收到Watcher通知后，重复步骤1 4、释放锁：同上。</li></ol><p>羊群效应：在释放锁时客户端会收到大量的事件通知，绝大多数序号不紧邻，也会收到通知，称为羊群效应<br> 改进后的分布式锁实现：<strong>每个锁竞争者只需关注序号比自己小的那个节点。</strong><br>1、客户端创建锁。<br>2、客户端获取已创建的子节点列表，但不注册Watcher。<br>3、如果无法获取锁，对比自己小的节点注册Watcher事件。<br>4、等待Watcher通知。</p><h4 id="1-6-4-zooKeeper分布式锁的优点和缺点"><a href="#1-6-4-zooKeeper分布式锁的优点和缺点" class="headerlink" title="1.6.4 zooKeeper分布式锁的优点和缺点"></a>1.6.4 zooKeeper分布式锁的优点和缺点</h4><p>（1）优点：<code>ZooKeeper</code>分布式锁（如InterProcessMutex），能有效的解决分布式问题，不可重入问题，使用起来也较为简单。<br>（2）缺点：<code>ZooKeeper</code>实现的分布式锁，性能并不太高。为啥呢？<br>因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。大家知道，<code>ZK</code>中创建和删除节点只能通过<code>Leader</code>服务器来执行，然后<code>Leader</code>服务器还需要将数据同不到所有的<code>Follower</code>机器上，这样频繁的网络通信，性能的短板是非常突出的。<br>总之，在高性能，高并发的场景下，不建议使用<code>ZooKeeper</code>的分布式锁。而由于<code>ZooKeeper</code>的高可用特性，所以在并发量不是太高的场景，推荐使用<code>ZooKeeper</code>的分布式锁。</p><h3 id="1-7分布式队列"><a href="#1-7分布式队列" class="headerlink" title="1.7分布式队列"></a>1.7分布式队列</h3><p><strong>FIFO：先入先出，共享锁的数据节点</strong><br>        1、调用<code>getChildren（）</code>获取所有子节点，即所有元素<br>        2、确定自己的节点序号在所有子节点中的顺序<br>        3、如果自己不是最小的序号，那么等待，同时向比自己序号小的最后一个节点注册<code>Watcher</code>监听<br>        4、接收到Watcher&#96;通知后，重复步骤1。</p><p><strong>Barrier：分布式屏障</strong><br>        思想：<code>/queue_barrier</code>是一个存在的节点，并且该节点内容为<code>10</code>，数字类型n，表示：只有当<code>/queue_barrier</code>下的子节点个数达到<code>10</code>个，才会打开<code>Barrier</code>。<br>        临时节点<br>        1、通过<code>getData（）</code>获取节点内容，<code>n=10</code>。<br>        2、通过<code>getChildren（）</code>接口获取<code>/queue_barrier</code>节点下的所有子节点，同时注册对子节点列表变更的<code>Watcher</code>。<br>        3、统计子节点个数。<br>        4、如果子节点个数&lt;10，进入等待。<br>        5、接收到Watcher通知，重复2步骤。</p><h3 id="1-8注册中心"><a href="#1-8注册中心" class="headerlink" title="1.8注册中心"></a>1.8注册中心</h3><p>实现：<strong>依赖于临时节点和watch</strong></p><ul><li>消费者启动的时候，会先去注册中心中全量拉取服务的注册列表。</li><li>当<code>zk</code>上某个服务节点有变化的时候，通过监听机制做数据更新。</li><li><code>ZooKeeper</code>挂了，由于消费者本地有保存 不服务提供者信息，不影响消费者的服务调用。</li></ul><p><strong>作为注册中心的缺点分析</strong></p><ul><li>数据一致性需求分析：<code>ZK</code>是<code>CP</code>系统，注册中心更需要<code>AP</code>系统，优先保证可用性，服务保证最终一致性即可。</li><li>分区容忍及可用性：<code>ZK</code>当发生网络分区或者宕机会导致影响分区内的服务的可用性；在实践中，注册中心不能因为自身的任何原因破坏服务之间本身的可连通性，这是注册中心设计应该遵循的铁律。</li><li>服务规模：服务规模增长，写请求会导致整个注册中心长连接的压力；<code>ZooKeeper</code> 的写并不是可扩展的，不可以通过加节点解决水平扩展性问题。</li><li>持久化需求：注册中心不一定需要持久存储和事务日志；在服务发现中，服务调用发起方更关注的是其要调用的服务的实时的地址列表和实时健康状态，每次发起调用时，并不关心要调用的服务的历史服务地址列表、过去的健康状态。</li><li>健康检测问题：<code>zk</code>的健康检测只是简单的<code>TCP</code>长链接活性探测，监控检测逻辑过于简单。</li><li>复杂性：难以掌握的<code>Client/Session</code>状态机；难以承受的异常处理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据结构及对应的场景</title>
      <link href="/2022/10/27/redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84%E5%9C%BA%E6%99%AF/"/>
      <url>/2022/10/27/redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p><strong>Redis 为什么那么快？</strong><br>除了它是<strong>内存数据库</strong>，使得所有的操作都在内存上进行之外，还有一个重要因素，它实现的数据结构，使得我们对数据进行增删查改操作时，Redis 能高效的处理。</p><h1 id="一-redisObject对象头"><a href="#一-redisObject对象头" class="headerlink" title="一.redisObject对象头"></a>一.redisObject对象头</h1><p>Redis底层就是一个<strong>大map</strong>，key是字符串，value可能是字符串，哈希，列表等。<br><img src="https://img-blog.csdnimg.cn/6187d00384934a64bcc258d2fe9f4c73.png" alt="在这里插入图片描述"><br><code>编码方式type</code>和<code>对象头redisObject</code>有关，Redis中的每个对象底层的数据结构都是<strong>redisObject结构体</strong>，<strong>不同的场景同一个对象可能使用不同的底层编码</strong>，这样一个 <code>RedisObject </code>对象头需要占据 <code>16 </code>字节的存储空间。</p><blockquote><p>encoding：对应于object encoding命令，记录了对象使用的底层数据结构。<br>指令：object encoding key</p></blockquote><p>每种对象类型，有可能使用了多种**编码类型(encoding)**，具体的对应关系如下</p><table><thead><tr><th>对象类型  type</th><th>编码类型 encoding</th></tr></thead><tbody><tr><td>string</td><td>raw int embstr</td></tr><tr><td>list</td><td>quicklist(快速链表)</td></tr><tr><td>hash</td><td>dict（哈希表） ziplist（压缩列表）</td></tr><tr><td>set</td><td>intset(整数集合)    dict （哈希表）</td></tr><tr><td>zset</td><td>ziplist（压缩列表）  skiplist+dict（跳表）</td></tr></tbody></table><h1 id="二-字符串-string"><a href="#二-字符串-string" class="headerlink" title="二.字符串 string"></a>二.字符串 string</h1><h2 id="2-1-简单动态字符串-SDS"><a href="#2-1-简单动态字符串-SDS" class="headerlink" title="2.1.简单动态字符串(SDS)"></a>2.1.简单动态字符串(SDS)</h2><p><img src="https://img-blog.csdnimg.cn/0db5e6f2880449c888fce24c6449cf95.png" alt="SDS结构">          </p><p>Redis 中的字符串是可以<strong>修改的字符串</strong>，在内存中它是以<strong>字节数组</strong>的形式存在的。<br>相比较于C语言中的字符串:</p><ul><li>头部信息里面包含了字符串的实际长度 <code>len</code>，可以通过<code>O（1）</code>的时间复杂度得到。</li><li>C语言字符串的末尾之外，字符串里面不能含有 <code>“\0”</code> 字符，否则最先被程序读入的 <code>“\0” </code>字符将被误认为是字符串结尾，这个限制使得 C 语言的字符串只能保存<strong>文本数据</strong>，不能保存像图片、音频、视频文化这样的二进制数据。<code> SDS</code> 不需要用 <code>“\0” </code>字符来标识字符串结尾了，而是有个专门的<code>len</code>成员变量来记录长度，所以可存储包含 <code>“\0” </code>的数据。但是 <code>SDS </code>为了兼容部分 <code>C </code>语言标准库的函数， SDS 字符串结尾还是会加上<code>“\0”</code>字符。</li><li><code>capacity- len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小<strong>（小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容）</strong>。</li></ul><p><strong>问题：上面的 SDS 结构使用了范型 T，为什么不直接用 int 呢</strong><br>因为当字符串比较短时，len 和 capacity 可以使用 byte 和 short 来表示，Redis 为了对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。</p><h2 id="2-2-为什么要使用SDS？"><a href="#2-2-为什么要使用SDS？" class="headerlink" title="2.2.为什么要使用SDS？"></a>2.2.为什么要使用SDS？</h2><ul><li><strong>缓冲区溢出</strong><br>Redis提供的SDS内置的空间分配策略则可以完全杜绝这种事情的发生。当API需要对SDS进行修改时, API会首先会检查SDS的空间是否满足条件, 如果不满足, API会自动对它动态扩展, 然后再进行修改。</li><li><strong>空间预分配</strong><br>字符串之所以采用<strong>预分配</strong>的方式是防止修改操作需要不断重分配内存和字节数据拷贝。但同样也会造成内存的浪费。字符串预分配每次并不都是翻倍扩容，空间预分配规则如下:<ul><li>第一次创建<code>len</code>属性等于数据实际大小，free等于0，不做预分配。</li><li>修改后如果已有<code>free</code>空间不够且数据小于1M，每次预分配一倍容量。如原有<code>len=10byte，free=0</code>，再追加<code>10byte</code>，预分配<code>20byte</code>，总占用空间:10byte+10byte+20byte+1byte。</li><li>修改后如果已有<code>free</code>空间不够且数据大于<code>1MB</code>，每次预分配<code>1MB</code>数据。如原有<code>len=30MB，free=0</code>，当再追加<code>100byte</code> ,预分配<code>1MB</code>，总占用空间:<code>30MB+100byte+1MB+1byte</code>。</li></ul></li></ul><p><strong>开发提示:尽量减少字符串频繁修改操作如append，setrange, 改为直接使用set修改字符串，降低预分配带来的内存浪费和内存碎片化。</strong><br><img src="https://img-blog.csdnimg.cn/4b2dc8d3eefd4deb99778fe2845321cf.png" alt="在这里插入图片描述"></p><ul><li><strong>惰性空间释放</strong><br>惰性空间释放用于字符串缩短的操作。当字符串缩短是，程序并不是立即使用内存重分配来回收缩短出来的字节，而是使用<code>free</code>属性记录起来，并等待将来使用。Redis通过<strong>空间预分配和惰性空间释放策略</strong>在字符串操作中一定程度上减少了内存重分配的次数。</li><li>二进制安全     可用于保存字节数组，支持安全的二进制数据存储。</li></ul><h2 id="2-3-时间复杂度"><a href="#2-3-时间复杂度" class="headerlink" title="2.3.时间复杂度"></a>2.3.时间复杂度</h2><ul><li>获取<code>SDS</code>长度: 由于<code>SDS</code>中提供了<code>len</code>属性，因此我们可以直接获取时间复杂度为<code>O(1)</code>。</li><li>获取<code>SDS</code>未使用空间长度: 时间复杂度为<code>0(1)</code>。</li><li>清除<code>SDS</code>保存的内容:由于惰性空间分配策略，复杂度为<code>O(1)</code>。</li><li>创建一个长度为<code>N</code>的字符串:时间复杂度为<code>O(n)</code>。</li><li>拼接一个长度为<code>N</code>的<code>C</code>字符串:时间复杂度为<code>O(n)</code>。</li><li>拼接一个长度为<code>N</code>的<code>SDS</code>字符串:时间复杂度为<code>O(n)</code>。</li><li><code>Redis</code>在获取字符串长度上的时间复杂度为常数级<code>O(1)</code>。</li></ul><h2 id="2-4-编码方式（redisObject-encoding）"><a href="#2-4-编码方式（redisObject-encoding）" class="headerlink" title="2.4 编码方式（redisObject.encoding）"></a>2.4 编码方式（redisObject.encoding）</h2><ul><li><strong>int</strong><br>当存储的字符串<code>全是数字</code>的时候，此时使用<code>int</code>方式来存储</li><li><strong>embstr</strong><br>当存储的字符串长度<strong>小于等于44</strong>字符的时候，使用<code>embstr</code>方式来存储</li><li><strong>raw</strong><br>当存储的字符串长度<strong>大于等于44</strong>字符的时候，使用<code>raw</code>方式来存储<br><img src="https://img-blog.csdnimg.cn/f9326e04f80f412bb85edd62835c158e.png" alt="在这里插入图片描述"></li></ul><p><strong>为什么上面的阈值是44呢？</strong></p><ul><li>一个字符串包含RedisObject和SDS的数据结构，至少会占用19（16 + 3）个字节的空间大小。</li><li>C语言中的内存分配器分配内存大小的单位都是2的n次方，为了容纳一个完整的embstr对象，最少要分配32字节的空间。稍微长一些就是64字节了。所以定义大于64字节就属于大字符串。</li><li>64-19 &#x3D; 45.剩余可防存放字符串的空间45字节，而字符串又是以NULL结尾，占据了1个字节，所以阈值为44</li></ul><h2 id="2-5-应用场景："><a href="#2-5-应用场景：" class="headerlink" title="2.5.应用场景："></a>2.5.应用场景：</h2><ul><li>图片得二进制存储；</li><li>分布式锁；</li><li>统计微博数；</li><li>统计粉丝数。.</li></ul><h1 id="三-list"><a href="#三-list" class="headerlink" title="三. list"></a>三. list</h1><p>在Redis3.2版本以前列表类型的内部编码有两种，由<code>压缩列表 zipList</code>和<code>双向链表 LinkedList</code>实现的；在Redis3.2版本开始对列表数据结构进行了改造，使用 <code>quicklist</code> 代替了 <code>ziplist</code> 和<code>linkedlist</code>。</p><h2 id="3-1-双向链表linkedlist"><a href="#3-1-双向链表linkedlist" class="headerlink" title="3.1.双向链表linkedlist"></a>3.1.双向链表linkedlist</h2><p><img src="https://img-blog.csdnimg.cn/94631b3be05341cba91ff845e0fd8de0.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span><span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span><span class="comment">// 后置节点</span></span><br><span class="line">    <span class="type">void</span> *value;<span class="comment">// 存储的数据</span></span><br><span class="line">&#125; listNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;<span class="comment">// 链表头节点</span></span><br><span class="line">    listNode *tail; <span class="comment">// 链表尾节点</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);<span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);  <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);  <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len; <span class="comment">// 链表所有节点数量</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p><strong>链表的优势：</strong></p><ul><li><strong>双向</strong>：链表节点带有前驱、后继指针获取某个节点的前驱、后继节点的时间复杂度为<code>0(1)</code>。</li><li><strong>无环</strong>: 链表为非循环链表表头节点的前驱指针和表尾节点的后继指针都指向NULL，对链表的访问以NULL为终点。</li><li><strong>带表头指针和表尾指针</strong>：通过<code>list</code>结构中的head和tail指针，获取<strong>表头和表尾节点</strong>的时间复杂度都为<code>O(1)</code>。</li><li><strong>带链表长度计数器</strong>:通过<code>list</code>结构的<code>len</code>属性获取节点数量的时间复杂度为<code>O(1)</code>。</li><li><strong>多态</strong>：链表节点使用void*指针保存节点的值，并且可以通过list结构的<code>dup、free、match</code>三个属性为<strong>节点值设置类型特定函数，所以链表可以用来保存各种不同类型的值</strong>。</li></ul><p><strong>链表的缺点：</strong></p><ul><li>链表每个节点之间的内存都是不连续的，意味着无法很好利用 CPU 缓存;</li><li>保存一个链表节点的值都需要一个链表节点结构头的分配，内存开销较大。</li></ul><p><code>Redis 3.0 </code>的<code>List</code>对象在数据量比较少的情况下，会采用<strong>压缩列表</strong>作为底层数据结构的实现，它的优势是<strong>节省内存空间，并且是内存紧凑型的数据结构</strong>。</p><h2 id="3-2-压缩列表zipList"><a href="#3-2-压缩列表zipList" class="headerlink" title="3.2.压缩列表zipList"></a>3.2.压缩列表zipList</h2><p>设计初衷是为了<strong>节约内存</strong>。使用一块<strong>连续</strong>的内存空间存储。<strong>每个元素长度不同</strong>，采用<strong>变长编码</strong>。</p><ul><li>适用于长度较小的值，因为他是由连续的空间实现的;</li><li>存取的效率高，内存占用小，但由于内存是连续的，在修改的时候要重新分配内存;</li></ul><p>当<code>list</code>对象同时满足以下两个条件是，使用的<code>ziplist</code>编码;</p><blockquote><p>1.list对象保存的所有字符串元素长度都小于64字节<br> 2.list对象保存的元素数量小于512个</p></blockquote><h3 id="3-2-1压缩列表结构设计"><a href="#3-2-1压缩列表结构设计" class="headerlink" title="3.2.1压缩列表结构设计"></a>3.2.1压缩列表结构设计</h3><p>它是由<strong>连续内存块组成的顺序型数据结构</strong>，有点类似于数组。<br><img src="https://img-blog.csdnimg.cn/5b09d32837c9401a80005d2b181e50e4.png" alt="在这里插入图片描述"><br>变长编码体现在<code>prevrawlensize</code>属性，它记录的是<code>prerawlen</code>的大小，分为两种。</p><ul><li>若前一个结点的长度<code>小于254</code>字节，那么则使用<code>1</code>字节来存储<code>prerawlen</code>;</li><li>若前一个结点的长度<code>大于等于254</code>字节，那么将第一个字节设置为<code>254</code>，然后接下来的<code>4</code>个字节保存实际的长度。也就是用<code>5个字节来表示prerawlen</code>的长度。</li></ul><p><strong>注意：存在连锁更新问题</strong><br>假设现在存在一组压缩列表（ e1,e2,e3,e4,e5），长度都在250字节至253字节之间，采用第一种方式<strong>保存变长编码（prerawlen为1字节）</strong>。突然新增一新节点new在e1之前， 长度大于等于254字节，会出现：此时记录e1的前一个节点的编码方式就需要修改（多出4个字节）。e1整体长度变化，就引起之后所有的节点的prerawlen发送变化。删除节点，同理。<br>如下图:<br><img src="https://img-blog.csdnimg.cn/69be06faa9a84d88aa053084db3367a0.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/740ba80b990f4694b245ab506fe88626.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e93f1b667e8e48dbb041d8e4fbbbaffa.png" alt="在这里插入图片描述"></p><h3 id="3-2-2-压缩列表的缺陷"><a href="#3-2-2-压缩列表的缺陷" class="headerlink" title="3.2.2.压缩列表的缺陷"></a>3.2.2.压缩列表的缺陷</h3><ul><li>空间扩展操作也就是重新分配内存，因此连<strong>锁更新</strong>一旦发生，就会导致压缩列表占用的<strong>内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能</strong>;</li><li><strong>不能保存太大的元素</strong>的场景，只要节点数量足够小，即使发生连锁更新，也是能接受的;</li><li>不能保存太多的元素，不然访问性能会降低;</li></ul><p>应用场景： 发布订阅，消息队列，文章列表,记录帖子的相关文章 ID，根据内容推荐相关帖子 (list)。</p><h2 id="3-3-快速列表-quicklist"><a href="#3-3-快速列表-quicklist" class="headerlink" title="3.3.快速列表 quicklist"></a>3.3.快速列表 quicklist</h2><p><strong>双向链表</strong>的附加空间相对太高，<code>prev</code> 和 <code>next</code> 指针就要占去 <code>16 个字节</code> ，另外每个节点的内存都是<code>单独分配</code>，会加剧<code>内存的碎片化</code>，影响内存管理效率。因此Redis3.2版本开始对列表数据结构进行了改造，使用<code> quicklist</code> 代替了<code>ziplist</code>和 <code>linkedlist</code>。<br>quicklist 解决办法，<strong>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</strong></p><p><img src="https://img-blog.csdnimg.cn/83fdaa1bf4b3470c9909ec659a27f689.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">quicklistNode* head;</span><br><span class="line">quicklistNode* tail;</span><br><span class="line"><span class="type">long</span> count; <span class="comment">// 元素总数</span></span><br><span class="line"><span class="type">int</span> nodes; <span class="comment">// ziplist 节点的个数</span></span><br><span class="line"><span class="type">int</span> compressDepth; <span class="comment">// LZF 算法压缩深度</span></span><br><span class="line"><span class="type">int</span> fill <span class="comment">//ziplist大小设置，存放list-max-ziplist-size参数的值。</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">quicklistNode* prev;</span><br><span class="line">quicklistNode* next;</span><br><span class="line">ziplist* zl; <span class="comment">// 指向压缩列表</span></span><br><span class="line">int32 size; <span class="comment">// ziplist 的字节总数</span></span><br><span class="line">int16 count; <span class="comment">// ziplist 中的元素数量</span></span><br><span class="line">int2 encoding; <span class="comment">// 存储形式 2bit，原生字节数组还是 LZF 压缩存储</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>插入</strong><br>quicklist可以选择在<strong>头部或者尾部</strong>进行插入，而不管是在头部还是尾部插入数据，都包含两种情况：</p><ul><li>如果头节点（或尾节点）上ziplist大小没有超过限制，那么新数据被直接插入到ziplist中。</li><li>如果头节点（或尾节点）上ziplist太大了，那么新创建一个quicklistNode节点，然后把这个新创建的节点插入到quicklist双向链表中。</li></ul><p>也可以从<strong>任意指定</strong>的位置插入。这种在任意指定位置插入数据的操作，要比在头部和尾部的进行插入要复杂一些。</p><ul><li>当插入位置所在的ziplist大小没有超过限制时，直接插入到<code>ziplist</code>中就好了；</li><li>当插入位置所在的ziplist大小超过了限制，但插入的位置位于<code>ziplist</code>两端，并且相邻的<code>quicklist</code>链表节点的<code>ziplist</code>大小没有超过限制，那么就转而插入到相邻的那个<code>quicklist</code>链表节点的<code>ziplist</code>中；</li><li>当插入位置所在的<code>ziplist</code>大小超过了限制，但插入的位置位于<code>ziplist</code>两端，并且相邻的<code>quicklist</code>链表节点的<code>ziplist</code>大小也超过限制，这时需要新创建一个<code>quicklist</code>链表节点插入。</li><li>对于插入位置所在的ziplist大小超过了限制的其它情况（主要对应于在ziplist中间插入数据的情况），则需要把当前ziplist分裂为两个节点，然后再其中一个节点上插入数据。<br><strong>每个 ziplist 存多少元素 ？</strong><br><code>quicklist </code>内部默认单个 <code>ziplist </code>长度为 <code>8k</code>字节，超出了这个字节数，就会新起一个<code>ziplist</code>。<code>ziplist </code>的长度由配置参数<code>list-max-ziplist-size</code>决定。</li></ul><p><strong>quicklist为什么要这样设计呢？</strong><br><strong>大概是基于空间和效率的一个折中</strong><br><strong>双向链表</strong>:<strong>内存开销比较大</strong>，除了要保存数据，还要保存前后节点的指针。并且每个节点是单独的内存块，容易造成内存碎片;<br><strong>ziplist</strong>是一块连续的内存，<strong>节省内存</strong>。但是当进行修改操作时，会发生<strong>级联更新</strong>，降低性能;</p><p><strong>于是结合两者优点的quicklist诞生了，但这又会带来新的问题，每个ziplist存多少元素比较合适呢？</strong></p><p><code>ziplist</code>越短，内存碎片增多，影响存储效率。当一个<code>ziplist</code>只存一个元素时，<code>quicklist</code>又退化成双向链表了;<br><code>ziplist</code>越长，为<code>ziplist</code>分配大的连续的内存空间难度也就越大，会造成很多小块的内存空间被浪费，当<code>quicklist</code>只有一个节点，元素都存在一个<code>ziplist</code>上时，<code>quicklist</code>又退化成<code>ziplist</code>了。</p><h1 id="四-hashmap"><a href="#四-hashmap" class="headerlink" title="四.hashmap"></a>四.hashmap</h1><h2 id="4-1-散列冲突"><a href="#4-1-散列冲突" class="headerlink" title="4.1.散列冲突"></a>4.1.散列冲突</h2><p>散列函数具有确定性和不确定性。<br>确定性:哈希的散列值不同，那么哈希的原始输入也就不同。即:key1&#x3D;key2,那hash(key1)&#x3D;hash(key2)。<br>不确定性:同一个散列值很有可能对应多个不同的原始输入。即:key1≠key2，hash(key1)&#x3D;hash(key2)。<br>关于散列冲突也有很多解决办法，这里简单复习两种：开放寻址法和链表法。</p><ul><li><strong>开放寻址法</strong>:开放寻址法的核心思想是，如果出现了<strong>散列冲突，我们就重新探测一一个空闲位置</strong>，将其插入。比如，我们可以使用线性探测法。当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，如果遍历到尾部都没有找到空闲的位置，那么我们就再从表头开始找，直到找到为止。</li><li><strong>链表法</strong>:  链表法是一种比较常用的散列冲突解决办法**,Redis使用的就是链表法来解决散列冲突**。链表法的原理是:如果遇到冲突，他就会在原地址新建一个空间，然后以链表结点的形式插入到该空间。当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可。</li></ul><h2 id="4-2-hashtable"><a href="#4-2-hashtable" class="headerlink" title="4.2.hashtable"></a>4.2.hashtable</h2><p><img src="https://img-blog.csdnimg.cn/974cce46736742909888310f351d4714.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字典 数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span><span class="comment">//管理两个dictht，主要用于动态扩容。</span></span><br><span class="line">    <span class="comment">//类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">//其中一个ht[0]保存哈希表，ht[1]只会在对ht[0]进行rehash时使用</span></span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">// rehash索引，当rehash不再进行是，值为 -1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义一个hash桶，用来管理hashtable</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// hash表数组，所谓的桶</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// hash表大小，元素个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="comment">// hash表大小掩码，用于计算索引值，值总是size -1 ,决定了一个键应该放tabl数组的哪个索引上</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该hash表已有的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//hash节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> </span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下一个节点，解决碰撞冲突</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="4-3-Redis-rehash"><a href="#4-3-Redis-rehash" class="headerlink" title="4.3.Redis rehash"></a>4.3.Redis rehash</h2><p>rehash指的是重新<strong>计算键的哈希值和索引值</strong>，然后将键值对重排的过程。</p><p><strong>加载因子（load factor） &#x3D; ht[0].used &#x2F; ht[0].size。</strong></p><p><strong>扩容：</strong> 第一个大于等于ht[0].used * 2的2^n(2的n次方幂)。</p><ul><li>没有执行<code>BGSAVE</code>和<code>BGREWRITEAOF</code>指令的情况下，哈希表的<code>加载因子</code>大于等于<code>1</code>。</li><li>正在执行<code>BGSAVE</code>和<code>BGREWRITEAOF</code>指令的情况下，哈希表的<code>加载因子</code>大于等于<code>5</code>。</li></ul><p>Redis这么做的目的是基于操作系统创建子进程后写时复制技术，避免不必要的写入操作。</p><p> <strong>收缩:</strong> 第一个大于等于ht[0].used的2^n(2的n次方幂)。</p><ul><li>加载因子小于0.1时，程序自动开始对哈希表进行收缩操作。</li></ul><p><strong>实现过程</strong><br><img src="https://img-blog.csdnimg.cn/8a78db000c35404a97ccf971676ae784.png" alt="在这里插入图片描述"><br>1.为字典的<code>ht[1]</code>散列表分配空间，这个空间的大小取决于要执行的操作以及ht[0]当前包含的键值对数量 <strong>(即:ht[0].used的属性值)</strong></p><ul><li>扩展操作：<code>ht[1]</code>的大小为 第一个大于等于<code>ht[0].used*2</code>的<code>2</code>的<code>n</code>次方幂。如:<code>ht[0].used=3</code>则<code>ht[1]</code>的大小为<code>8</code>;</li><li>收缩操作: <code>ht[1]</code>的大小为 第一个大于等于<code>ht[0].used</code>的<code>2</code>的<code>n</code>次方幂。</li></ul><p>2.将保存在<code>ht[0]</code>中的键值对<strong>重新计算键的散列值和索引值</strong>，然后放到<code>ht[1]</code>指定的位置上。在字典中有一个参数<code>rehashidx</code>的值设置为<code>0</code>，表示开始<strong>rehash</strong>。</p><ul><li>在 rehash 进行期间， 每次对字典执行<strong>添加、删除、查找或者更新</strong>操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0] </code>哈希表在 <code>rehashidx</code> 索引上的所有键值对 <code>rehash </code>到<code> ht[1]</code> ， 当 <code>rehash </code>工作完成之后， 程序将 <code>rehashidx </code>属性的值增一。<br>3.将<code>ht[0]</code>包含的所有键值对都迁移到了<code>ht[1]</code>之后，这时程序将 <code>rehashidx </code>属性的值设为 <code>-1</code> ， 表示 <code>rehash </code>操作已完成，释放<code>ht[0]</code>,将<code>ht[1]</code>设置为<code>ht[0],</code>并创建一个新的<code>ht[1]</code>，哈希表为下一次<code>rehash</code>做准备。</li></ul><h3 id="4-3-1-渐进式-rehash"><a href="#4-3-1-渐进式-rehash" class="headerlink" title="4.3.1.渐进式 rehash"></a>4.3.1.渐进式 rehash</h3><p><code>rehash</code>到<code>ht[1]</code>，并不是一步完成的，而是分成N多步，循序渐进的完成的<strong>（有可能存放几千万甚至上亿个key，一次性将这些键值rehash的话，可能会导致服务器在一段时间内停止服务）</strong>。</p><p><strong>说明:</strong></p><ul><li>因为在进行渐进式<code>rehash</code>的过程中，字典会同时使用 <code>ht[0] </code>和 <code>ht[1] </code>两个哈希表，所以在渐进式 <code>rehash</code> 进行期间，<strong>字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行</strong>。</li><li>在渐进式 <code>rehash</code> 执行期间，<strong>新添加到字典的键值对一律会被保存到 ht[1] 里面</strong>，而<code>ht[0]</code>则不再进行任何<strong>添加操作</strong>：这一措施保证了 <strong>ht[0] 包含的键值对数量会只减不增</strong>，并随着 rehash 操作的执行而最终变成空表。</li></ul><h2 id="4-4-应用场景："><a href="#4-4-应用场景：" class="headerlink" title="4.4.应用场景："></a>4.4.应用场景：</h2><ul><li>购物车</li><li>计数器-</li><li>实时记录当天的在线的人数。</li><li>记录帖子的点赞数、评论数和点击数 </li><li>缓存近期热帖内容 (帖子内容空间占用比较大)，减少数据库压力</li><li>缓存用户行为历史，进行恶意行为过滤 (zset,hash)</li></ul><h1 id="五-set"><a href="#五-set" class="headerlink" title="五.set"></a>五.set</h1><p>set可以用<code>intset</code>或者<code>字典</code>实现。</p><ul><li>当存储的元素都是整数值，且数据量不大（小于512）时使用intset。</li><li>不满足<code>intset</code>使用条件的情况下都使用<code>字典</code>，使用字典时把value设置为<code>null</code>。</li></ul><h2 id="5-1-intset"><a href="#5-1-intset" class="headerlink" title="5.1.intset"></a>5.1.intset</h2><p>整数集合（intset）是Redis用于保存整数值的集合抽象数据类型，它可以保存类型为<strong>int16_t、int32_t 或者int64_t 的整数值</strong>，并且保证集合中不会出现重复元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">     <span class="comment">//编码方式</span></span><br><span class="line">     <span class="type">uint32_t</span> encoding;</span><br><span class="line">     <span class="comment">//集合包含的元素数量</span></span><br><span class="line">     <span class="type">uint32_t</span> length;</span><br><span class="line">     <span class="comment">//保存元素的数组</span></span><br><span class="line">     <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure><p>　　整数集合的每个元素都是<code>contents</code>数组的一个数据项，它们按照从<strong>小到大</strong>的顺序排列，并且不包含任何重复项。<br>　　<code>length 属性</code>记录了 <code>contents</code> 数组的大小。<br>　　<code>contents</code> 数组声明为 int8_t 类型，但是实际上contents 数组并不保存任何 int8_t 类型的值，其真正类型有<code>encoding</code>来决定。</p><ul><li><code>encoding </code>&#x3D;<code>INTSET_ENC_INT_16</code>、那么contents就是一个int16_t的数组;</li><li><code>encoding</code> &#x3D;<code>INTSET_ENC_INT_32</code>、那么contents就是一个int32_t的数组;</li><li><code>encoding</code>&#x3D;<code>INTSET_ENC_INT_64</code>、那么contents就是一个int64_t的数组。</li></ul><p><strong>整数集合的升级操作</strong><br>　　当我们<strong>新增的元素类型</strong>比<strong>原集合元素类型的长度要大</strong>时，需要对整数集合进行升级，才能将新元素放入整数集合中。<strong>整数集合升级的过程不会重新分配一个新类型的数组，而是在原本的数组上扩展空间，然后在将每个元素按间隔类型大小分割</strong>，如果 <code>encoding </code>属性值为 <code>INTSET_ENC_INT16</code>，则每个元素的间隔就是 <strong>16 位</strong>。<br>　　<img src="https://img-blog.csdnimg.cn/5c377fff13554ba383c42191b75fb8ca.png" alt="在这里插入图片描述"></p><p>具体步骤：<br>　　1、根据新元素类型，<strong>扩展整数集合底层数组的大小</strong>，<strong>并为新元素分配空间</strong>。<br>　　2、将<strong>底层数组现有的所有元素都转成与新元素相同类型的元素</strong>，并将<strong>转换后的元素放到正确的位置</strong>，放置过程中，维持整个元素顺序都是有序的。<br>　　3、将<strong>新元素添加到整数集合</strong>中（保证有序）。<br>　　<img src="https://img-blog.csdnimg.cn/0c49f75ded2d4f2a963406349312e7d3.png" alt="在这里插入图片描述"><br><strong>整数集合升级有什么好处呢？</strong></p><ul><li><strong>提升灵活性</strong>: C语言是静态类型语言,为了避免类型错误,我们通常不<strong>会将两种不同类型的值放在同一个数据结构里面</strong>。</li><li><strong>节约内存</strong>:要让一个数组可以同时保存<code>int16_t、int32_t、int64_t</code>三种类型的值,最简单的做法就是直接使用<code>int64t</code>类型的数组作为<strong>整数集合的底层实现</strong>。不过这样一来,即使添加到整数集合里面的都是<code>int16_t</code>类型或者<code>int32_t</code>类型的值,数组都需要使用<code>int64_t</code>类型的空间去保存它们**,从而出现浪费内存的情况。**<br><strong>整数集合升级缺点：</strong></li><li><strong>升级过程中消耗资源</strong></li><li>不支持降级</li></ul><p><strong>应该场景</strong></p><ul><li>用户标签</li><li>抽奖系统</li><li>社交需求</li></ul><h1 id="六-zset"><a href="#六-zset" class="headerlink" title="六.zset"></a>六.zset</h1><p><code>Redis</code> 只有<code>Zset</code>对象的底层实现用到了跳表，跳表的优势是能支持平均 <code>O(logN) </code>复杂度的节点查找。<br><img src="https://img-blog.csdnimg.cn/ca1bf61b70624d6b9910716d54267767.png" alt="在这里插入图片描述"></p><p><strong>zset底层实现原理：</strong><br><strong>元素数量小于128个 所有元素的长度都小于64字节的时候 使用ziplist数据结构</strong>。<code>ziplist</code>占用连续内存，每项元素都是<code>（数据+score）</code>的方式连续存储，按照<code>score</code>从小到大排序。<code>ziplist</code>为了节省内存，每个元素占用的空间可以不同，对于大的数据<code>（long long）</code>，就多用一些字节来存储，而对于小的数据<code>（short）</code>，就少用一些字节来存储。因此查找的时候需要按顺序遍历。<strong>ziplist省内存但是查找效率低</strong>。</p><p><strong>为什么元素数量比较多或者成员是比较长的字符串的时候Redis要使用跳跃表来实现？</strong><br>  跳跃表在链表的基础上增加了<strong>多级索引</strong>以提升查找的效率，但其是一个<code>空间换时间</code>的方案，必然会带来一个问题——<code>索引是占内存的</code>。原始链表中存储的有可能是很大的对象，而索引结点只需要存储<strong>关键值和几个指针</strong>，并不需要存储对象，因此当节点本身比较大或者元素数量比较多的时候，其优势必然会被放大，而缺点则可以忽略。</p><h2 id="6-1-Redis中跳跃表的实现"><a href="#6-1-Redis中跳跃表的实现" class="headerlink" title="6.1.Redis中跳跃表的实现"></a>6.1.Redis中跳跃表的实现</h2><p>  <img src="https://img-blog.csdnimg.cn/c926524dd2e242a48cebf016bc30cbc6.png" alt="在这里插入图片描述"><br>上图展示了一个跳跃表示例,其中最左边的是<code> skiplist</code>结构,该结构包含以下属性。</p><ul><li>header:指向跳跃表的表头节点，表头节点的时间复杂度就为<code>O(1)</code>;</li><li>tail:指向跳跃表的表尾节点,表尾节点的时间复杂度就为<code>O(1)</code>;</li><li>level:记录目前跳跃表内,<strong>层数最大的那个节点的层数</strong>，通过这个属性可以再<code>O(1)</code>的时间复杂度内获取层高最好的节点的层数。</li><li>length:<strong>记录跳跃表的长度</strong>,也即是,跳跃表目前包含节点的数量，通过这个属性，程序可以再<code>O(1)</code>的时间复杂度内返回跳跃表的长度。</li><li>表头：是链表的哨兵节点，不记录主体数据。</li></ul><p>结构右方的是四个<code> zskiplistNode</code>结构,该结构包含以下属性</p><ul><li><strong>层(level):</strong>:​ 节点中用<code>L1、L2、L3</code>等字样标记节点的各个层。​ 每个层都带有两个属性:<strong>前进指针和跨度</strong>。前进指针用于访问位于<strong>表尾方向的其他节点</strong>,而跨度则记录了<strong>前进指针所指向节点和当前节点的距离</strong>(跨度越大、距离越远)。​ 每次创建一个新跳跃表节点的时候,程序都根据幂次定律<strong>随机生成一个介于1和32之间的值</strong>作为<strong>level</strong>数组的大小,这个大小就是层的“高度”。</li><li><strong>后退(backward)指针：</strong>,它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li><strong>分值(score):</strong>:​各个节点中的<code>1.0、2.0</code>和<code>3.0</code>是节点所保存的分值。在跳跃表中,节点按各自所保存的分值从小到大排列。</li><li><strong>成员对象(oj):<strong>​ 各个节点中的<code>o1、o2</code>和<code>o3</code>是节点所保存的成员对象。在</strong>同一个跳跃表中,各个节点保存的成员对象必须是唯一的</strong>。</li></ul><h2 id="6-2-操作"><a href="#6-2-操作" class="headerlink" title="6.2.操作"></a>6.2.操作</h2><p><img src="https://img-blog.csdnimg.cn/074e2f547caa4320928c45953fe55ade.png" alt="在这里插入图片描述"><br><strong>查询过程</strong><br>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p><ul><li><strong>如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</strong></li><li><strong>如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</strong></li></ul><p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。<br><img src="https://img-blog.csdnimg.cn/06e5f9225b914d3590872bcb8d51b456.png" alt="在这里插入图片描述">查找元素：<strong>abcd，权重：4</strong>的节点，查找的过程是这样的：</p><ul><li>先从头节点的最高层开始，L2 指向了<strong>元素：abc，权重：3</strong>节点，这个节点的权重比要查找节点的小，所以要访问该层上的下一个节点；但是该层的下一个节点是<strong>空节点</strong>，于是就会跳到下一层去找，也就是<code> leve[1]</code>;</li><li>元素：<strong>abc，权重：3</strong>节点的 leve[1] 的下一个指针指向了<strong>元素：abcde，权重：4</strong>的节点，然后将其和要查找的节点比较。虽然<strong>元素：abcde，权重：4</strong>的节点的权重和要查找的权重相同，但是当前节点的 <strong>SDS 类型数据大于要查找的数据</strong>，所以会继续跳到<strong>元素：abc，权重：3</strong>节点的下一层去找，也就是 **leve[0]**；</li><li><strong>元素：abc，权重：3</strong>节点的 <strong>leve[0]</strong> 的下一个指针指向了<strong>元素：abcd，权重：4</strong>的节点，该节点正是要查找的节点，查询结束。</li></ul><h2 id="6-3-跳表节点层数设置"><a href="#6-3-跳表节点层数设置" class="headerlink" title="6.3.跳表节点层数设置"></a>6.3.跳表节点层数设置</h2><p>跳表的相邻两层的节点数量的比例会影响跳表的查询性能。<br><img src="https://img-blog.csdnimg.cn/8c5284ee0b024aa6a70c965d7b68e587.png" alt="在这里插入图片描述"><br>这时，如果想要查询<code>节点 6</code>，那基本就跟链表的查询复杂度一样，就需要在第一层的节点中依次顺序查找，复杂度就是 <code>O(N)</code> 了。所以，为了降低查询复杂度，我们就需要维持相邻层结点数间的关系。<br><strong>跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)。</strong><br>Redis 则采用一种巧妙的方法是，<strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。<br>    具体的做法是，跳表在创建节点时候，会生成范围为[0-1]的一个随机数，<strong>如果这个随机数小于 0.25，那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数。</strong></p><h2 id="6-4-参考REDIS中为什么使用跳表"><a href="#6-4-参考REDIS中为什么使用跳表" class="headerlink" title="6.4.参考REDIS中为什么使用跳表"></a>6.4.参考REDIS中为什么使用跳表</h2><p>理论上来讲，查找、插入、删除以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度和跳表是一样的。<br><strong>redis使用跳表而不是红黑树的原因</strong></p><ul><li><strong>在做范围查找的时候</strong>:按照区间查找数据这个操作，红黑树的效率没有跳表高。跳表可以在 O(logn)时间复杂度定位区间的起点，然后在原始链表中顺序向后查询就可以了。</li><li><strong>从算法实现难度上来比较</strong> : 相比于红黑树，跳表还具有代码更容易实现、可读性好、不容易出错、更加灵活等优点。</li><li>**从性能上来比较:**插入、删除时跳表只需要调整少数几个节点，红黑树需要颜色重涂和旋转，开销较大。</li><li><strong>从内存占用上来比较</strong>，跳表比平衡树更灵活一些。</li></ul><h2 id="6-5-应用场景"><a href="#6-5-应用场景" class="headerlink" title="6.5.应用场景"></a>6.5.应用场景</h2><ul><li>排行榜系统例如学生成绩的排名。</li><li>某视频(博客等)网站的用户点赞、播放排名。</li><li>电商系统中商品的销量排名等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper学习（一） 入门篇</title>
      <link href="/2022/10/27/zookeeper/zookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%20%E5%85%A5%E9%97%A8%E7%AF%87/"/>
      <url>/2022/10/27/zookeeper/zookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%20%E5%85%A5%E9%97%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="ZooKeeper简介"><a href="#ZooKeeper简介" class="headerlink" title="ZooKeeper简介"></a>ZooKeeper简介</h2><p>ZooKeeper 是一个开源的<strong>分布式协调框架</strong>，它的定位是为<strong>分布式应用提供一致性</strong>服务ZooKeeper 会封装好复杂易出错的关键服务，将高效、稳定、易用的服务提供给用户使用。</p><p><strong>ZooKeeper &#x3D; 文件系统 + 监听通知机制。</strong>（重点）</p><h3 id="1-zookeeper文件系统"><a href="#1-zookeeper文件系统" class="headerlink" title="1.zookeeper文件系统"></a>1.zookeeper文件系统</h3><p><img src="https://img-blog.csdnimg.cn/bb04ee5adabd4a4f9d79d54001d17bdd.png" alt="在这里插入图片描述"><br>Zookeeper 提供一个<strong>多层级</strong>的节点命名空间（节点称为 znode）。这些节点都可以设置<strong>关联的数据</strong>。<strong>每个znode都可以通过其路径唯一标识</strong>。<br>Zookeeper 为了保证<strong>高吞吐和低延迟</strong>，在<strong>内存</strong>中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放<strong>数据上限为1M</strong>。</p><h4 id="1-1节点类型"><a href="#1-1节点类型" class="headerlink" title="1.1节点类型"></a>1.1节点类型</h4><ul><li>持久化目录节点：客户端与zookeeper断开连接后，该节点依旧存在。</li><li>持久化顺序编号目录节点：客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号。</li><li>临时目录节点 ：客户端与zookeeper断开连接后，该节点被删除。</li><li>临时顺序编号目录节点 ：客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号。</li><li>容器 节点：3.5.3 版本新增，如果Container节点下面没有子节点，则Container节点在未来会被Zookeeper自动清除,定时任务默认60s 检查一次</li><li>TTL 节点： 默认禁用，只能通过系统配置  zookeeper.extendedTypesEnabled&#x3D;true  开启，不稳定。</li></ul><h4 id="1-2监听通知机制"><a href="#1-2监听通知机制" class="headerlink" title="1.2监听通知机制"></a>1.2监听通知机制</h4><p>Watcher 监听机制是 Zookeeper 中非常重要的特性，我们基于 Zookeeper上创建的<strong>节点</strong>，可以对这些节点绑定监听事件，比如可以监听节点<strong>数据变更、节点删除、子节点状态变更</strong>等事件，通过这个事件机制，可以基于 Zookeeper 实现<strong>分布式锁、集群管理</strong>等多种功能。<strong>客户端向服务端注册指定的 watcher ，当服务端符合了 watcher 的某些事件或要求则会 向客户端发送事件通知 ，客户端收到通知后找到自己定义的 Watcher 然后 执行相应的回调方法</strong> 。</p><p><strong>ZooKeeper 的 Watcher 机制，总的来说可以分为三个过程：</strong></p><p>客户端注册 Watcher，注册 watcher 有 3 种方式，getData、exists、getChildren。<br>服务器处理 Watcher 。<br>客户端回调 Watcher 客户端。<br><img src="https://img-blog.csdnimg.cn/66a697c4ce8d4ddc8b0f4a98e8515288.png" alt="在这里插入图片描述"></p><p><strong>Watcher 特性总结：</strong></p><ul><li>一次性：无论是服务端还是客户端，一旦一个 Watcher 被 触 发 ，Zookeeper 都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力。</li><li>客户端串行执行：客户端 Watcher 回调的过程是一个串行同步的过程。</li><li>轻量：<ul><li>Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。</li><li>客户端向服务端注册 Watcher 的时候，并不会把客户端真实的 Watcher 对象实体传递到服务端，仅仅是在客户端请求中使用 boolean 类型属性进行了标记。</li></ul></li><li>watcher event 异步发送 watcher 的通知事件从 server 发送到 client 是异步的，这就存在一个问题，不同的客户端和服务器之间通过 socket 进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于 Zookeeper 本身提供了 ordering guarantee，即客户端监听事件后，才会感知它所监视 znode发生了变化。所以我们使用 Zookeeper 不能期望能够监控到节点每次的变化。Zookeeper 只能保证最终的一致性，而无法保证强一致性。</li><li>注册 watcher getData、exists、getChildren</li><li>触发 watcher create、delete、setData</li><li>当一个客户端连接到一个新的服务器上时，watch 将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到 watch 的。而当 client 重新连接时，如果需要的话，所有先前注册过的 watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch 可能会丢失：对于一个未创建的 znode的 exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个 watch 事件可能会被丢失。</li></ul><p><strong>Zookeeper事件类型：</strong><br>            None: 连接建立事件<br>            NodeCreated： 节点创建<br>            NodeDeleted： 节点删除<br>            NodeDataChanged：节点数据变化<br>            NodeChildrenChanged：子节点列表变化<br>            DataWatchRemoved：节点监听被移除<br>            ChildWatchRemoved：子节点监听被移除</p><p><strong>Zookeeper 对节点的 watch 监听通知是永久的吗？为什么不是永久的?</strong><br>不是。如果服务端变动频繁，而监听的客户端很多情况下，每次变动都要通知到所有的客户端，给网络和服务器造成很大压力。在实际应用中，很多情况下，我们的客户端不需要知道服务端的每一次变动，我只要最新的数据即可。</p><h3 id="2-zk指令"><a href="#2-zk指令" class="headerlink" title="2.zk指令"></a>2.zk指令</h3><ul><li>创建zookeeper 节点命令</li></ul><blockquote><p> create [‐s] [‐e] [‐c] [‐t ttl] path [data] [acl]<br>   -s: 顺序节点   -e: 临时节点   -c: 容器节点<br>-t:  可以给节点添加过期时间，默认禁用，需要通过系统参数启用<br>&#x2F;&#x2F;举例<br>[zk: localhost:2181(CONNECTED) 10] create &#x2F;data-test data1   创建一个持久化节点<br> Created &#x2F;data-test</p></blockquote><ul><li><p>查看节点：</p><blockquote><p>  get [-s] [-w ]  path<br>  -s 查看节点状态<br>   -w<br>[zk: localhost:2181(CONNECTED) 1] get &#x2F;data-test<br>data1</p></blockquote></li><li><p>修改节点数据：</p></li></ul><blockquote><p>set [-v] path [data]<br>-v 当前cversion版本号  乐观锁机制<br>[zk: localhost:2181(CONNECTED) 2] set  &#x2F;data-test test</p></blockquote><ul><li>查看节点状态信息：</li></ul><blockquote><p>[zk: localhost:2181(CONNECTED) 1] stat &#x2F;data-test<br>cZxid &#x3D; 0x8   创建znode的事务ID（Zxid的值）。<br>ctime &#x3D; Fri Sep 23 10:23:59 UTC 2022  znode创建时间<br>mZxid &#x3D; 0xb  最后修改znode的事务ID。<br>mtime &#x3D; Mon Sep 26 08:56:12 UTC 2022  znode最近修改时间<br>pZxid &#x3D; 0x8 最后添加或删除子节点的事务ID（子节点列表发生变化才会发生改变）。<br>cversion &#x3D; 0   znode的子节点结果集版本（一个节点的子节点增加、删除都会影响这个版本）。<br>dataVersion &#x3D; 1   znode的当前数据版本。<br>aclVersion &#x3D; 0   表示对此znode的acl版本。<br>ephemeralOwner &#x3D; 0x0  znode是临时znode时，表示znode所有者的 session ID。 如果<br>znode不是临时znode，则该字段设置为零。<br>dataLength &#x3D; 4  znode数据字段的长度<br>numChildren &#x3D; 0  znode的子znode的数量</p></blockquote><ul><li>查看子节点信息</li></ul><blockquote><p>ls [-R][-w] &#x2F;<br>-R 子目录<br>-w 监听<br>[zk: localhost:2181(CONNECTED) 2] ls &#x2F;<br>[data-test, runoob0000000000, zookeeper]</p></blockquote><ul><li>注册监听的同时获取数据<blockquote><p>get ‐w &#x2F;path &#x2F;&#x2F; 注册监听的同时获取数据<br>[zk: localhost:2181(CONNECTED) 5] get -w &#x2F;data-test<br>test<br>[zk: localhost:2181(CONNECTED) 6] set &#x2F;data-test test2<br>WATCHER::<br>WatchedEvent state:SyncConnected type:NodeDataChanged path:&#x2F;data-test<br>监听根目录以其子目录变化<br>[zk: localhost:2181(CONNECTED) 7] ls ‐R ‐w &#x2F;<br>[data-test, runoob0000000000, zookeeper]<br>[zk: localhost:2181(CONNECTED) 8] delete data-test<br>Path must start with &#x2F; character<br>[zk: localhost:2181(CONNECTED) 9] delete &#x2F;data-test<br>WATCHER::<br>WatchedEvent state:SyncConnected type:NodeChildrenChanged path:&#x2F;</p></blockquote></li></ul><h3 id="3-Zookeeper特性"><a href="#3-Zookeeper特性" class="headerlink" title="3.Zookeeper特性"></a>3.Zookeeper特性</h3><p>上面我们说到ZooKeeper 是一个的<strong>分布式协调服务框架</strong>，为分布式系统提供一致性服务。<br>什么是分布式，什么是集群，为什么需要协调各服务？<br>将一套系统拆分成不同子系统部署在不同服务器上（这叫分布式），大的问题拆分为多个小的问题，并分别解决，最终协同合作，分布式的主要工作是<strong>分解任务，将职能拆解</strong>。<br> 然后部署多个相同的子系统在不同的服务器上（这叫集群）， 集群主要是简单加机器解决问题，对于问题本身不做任何分解，集群主要的使用场景是为了<strong>分担请求的压力</strong>。<br>大白话：<br>分布式 ：多个人在一起作不同的事 。<br>集群：多个人在一起作同样的事 。</p><p><strong>集群</strong><br><img src="https://img-blog.csdnimg.cn/f590f10729c049568a85d208b797696d.png" alt="集群"><br><strong>分布式</strong><br><img src="https://img-blog.csdnimg.cn/cb0e8dfaaf9144c3b1f33c1994a21887.png" alt="在这里插入图片描述"><br>对于集群来说，多加几台服务器就行（当然还得解决session共享，负载均衡等问题），而对于分布式来说，你首先需要将业务进行拆分，然后再加服务器，同时还要去解决分布式带来的一系列问题。比如各个分布式组件如何协调起来，如何减少各个系统之间的耦合度，如何处理<strong>分布式事务</strong>，如何去配置整个分布式系统，如何解决各分布式<strong>子系统的数据不一致问题</strong>等等。ZooKeeper 主要就是解决这些问题的。</p><h4 id="3-1-Zookeeper保证了如下分布式一致性特性"><a href="#3-1-Zookeeper保证了如下分布式一致性特性" class="headerlink" title="3.1 Zookeeper保证了如下分布式一致性特性:"></a>3.1 Zookeeper保证了如下分布式一致性特性:</h4><ul><li>顺序一致性：同一个客户端发起的事务请求，最终将会严格的按照其发起的顺序被应用到Zookeeper中，对于客户端的每个请求，Zookeeper都会分配一个全局唯一的递增编号，这个编号反应了所有事务操作的先后顺序。</li><li>原子性：所有事务的请求处理在整个集群中所有的机器上的应用情况是一致的。对于一个事务，要么集群中所有机器都成功应用，要么都没有应用，不会出现部分应用的情况。</li><li>单一视图：无论客户端连接哪个Zookeeper服务器，看到服务端的数据模型都一致的。</li><li>可靠性：一旦事务完成，就会被保留下来，除非另一个事务修改。</li><li>实时性：Zookeeper仅仅保证在一定的时间段内，客户端最终一定能从服务器端读取到最新数据。</li><li>有序性是zookeeper中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个 唯一的时间戳，这个时间戳称为zxid。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个zookeeper最新的zxid。</li></ul><h4 id="3-2-ZooKeeper-操作特性"><a href="#3-2-ZooKeeper-操作特性" class="headerlink" title="3.2 ZooKeeper 操作特性"></a>3.2 ZooKeeper 操作特性</h4><ul><li>Znode:包含ACL权限控制、修改&#x2F;访问时间、最后一次操作的事务Id(zxid)等等</li><li>所有运行时数据存储在内存中，在内存中维护这么一颗树</li><li>每次对Znode节点修改都是保证顺序和原子性的操作。写操作是原子性操作</li><li>生命周期：当客户端会话结束的时候，是否清理掉这个会话创建的节点，持久-不清理，临时-清理</li><li>会话节点：每一个会话，创建单独的节点。</li></ul><h4 id="3-3-ZooKeeper-数据持久化"><a href="#3-3-ZooKeeper-数据持久化" class="headerlink" title="3.3 ZooKeeper  数据持久化"></a>3.3 ZooKeeper  数据持久化</h4><p>由上面可知，zookeeper数据的组织形式为一个<strong>类似文件系统的数据结构</strong>，而这些数据都是存储在内存中的，所以我们可以认为，Zookeeper是一个基于<strong>内存的小型数据库</strong></p><p><strong>数据类型</strong>：内存数据库</p><p><strong>事务日志</strong>：每次数据写操作完成会保存到内存数据库的同时，会记录到事务日志中 ，频繁进行磁盘IO操作，事务日志的不断追加写操作会触发底层磁盘IO为文件开辟新的磁盘块，即磁盘Seek。因此，为了提升磁盘IO的效率，Zookeeper在创建事务日志文件的时候就进行文件空间的预分配- 即在创建文件的时候，就向操作系统申请一块大一点的磁盘块。<br><strong>快照日志</strong>：数据快照用于记录Zookeeper服务器上某一时刻的全量数据，并将其写入到指定的磁盘文件中。可以通过配置<strong>snapCount</strong>配置每间隔事务请求个数，生成快照，数据存储在dataDir 指定的目录中。<br><strong>有了事务日志，为啥还要快照数据。</strong>：快照数据主要时为了<strong>快速恢复</strong>， 事务日志文件是<strong>每次事务请求都会进行追加的操作</strong>，而快照是达到某种设定条件下的内存全量数据。所以通常快照数据是<strong>反应当时内存数据的状态</strong>。事务日志是<strong>更全面的数据，所以恢复数据的时候，可以先恢复快照数据，再通过增量恢复事务日志中的数据即可</strong>。<br><strong>完整流程</strong>：<br>1.接收写操作，ZooKeeper集群中的每个服务器节点每次接收到写操作请求时，都会先将这次请求发送给leader。<br>2.协调写操作，leader将这次写操作转换为带有状态的事务，然后leader会对这次写操作广播出去以便进行协调。<br>3.记录数据，当协调通过(大多数节点允许这次写)后，leader通知所有的服务器节点，让它们将这次写操作应用到内存数据库中，并将其记录到事务日志中<br>4.记录快照数据，当事务日志记录的次数达到一定数量后(默认10W次)，将内存数据库序列化一次，持久化保存到磁盘上，序列化后的文件为快照文件<br>5.基于事务日志和快照，就可以让任意节点恢复到任意时间点(只要没有清理事务日志和快照)</p><h4 id="3-4-Zookeeper会话（Session）"><a href="#3-4-Zookeeper会话（Session）" class="headerlink" title="3.4 Zookeeper会话（Session）"></a>3.4 Zookeeper会话（Session）</h4><p>Session 可以看作是 ZooKeeper 服务器与客户端的之间的一个 <strong>TCP 长连接</strong>，客户端与服务端之间的任何交互操作都和Session 息息相关，其中包含zookeeper的<strong>临时节点的生命周期、客户端请求执行以及Watcher通知机制</strong>等。</p><p><strong>session会话状态有：</strong></p><ul><li>connecting：<strong>连接中</strong>，session 一旦建立，状态就是 connecting 状态，时间很短。</li><li>connected：<strong>已连接</strong>，连接成功之后的状态。</li><li>closed：<strong>已关闭</strong>，发生在 session 过期，一般由于网络故障客户端重连失败，服务器宕机或者客户端主动断开。</li></ul><p><strong>作用：</strong></p><ul><li>tcp长连接</li><li>心跳检测</li><li>发送请求</li><li>接受watch事件</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>简介了介绍zookeeper数据模型，监听机制，持久化，指令以及一些特性。</p><ul><li>zk是基于<strong>内存</strong>进行读写操作的，有时候会进行消息广播，因此不建议在节点存取容量比较大的数据。</li><li>dataDir（快照）目录、dataLogDir（事务日志）两个目录会随着时间推移变得庞大，容易造成硬盘满了。</li><li>类似文件系统，一直存放在内存中，由一系列Znode组成，Znode之间的层级关系就像文件系统的目录结构一样。</li><li>监听节点<strong>数据变更、节点删除、子节点状态变更</strong>等事件，而且监听是一次性的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper学习（三）go-zookeeper</title>
      <link href="/2022/10/27/zookeeper/zookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89go-zookeeper/"/>
      <url>/2022/10/27/zookeeper/zookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89go-zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Zookeeper入门"><a href="#一、Zookeeper入门" class="headerlink" title="一、Zookeeper入门"></a>一、Zookeeper入门</h2><h3 id="1-1-Zookeeper简介"><a href="#1-1-Zookeeper简介" class="headerlink" title="1.1. Zookeeper简介"></a>1.1. Zookeeper简介</h3><p>Zookeeper是一个分布式数据库(程序协调服务)，Hadoop子项目；以树状方式维护节点方数据的增、删、改、查；通过监听可以获取相应消息事件；<br>节点类型：</p><ul><li>持久节点：一直存储在服务器上(0)</li><li>临时节点：会话失效、节点自动清理(FlagEphemeral)</li><li>顺序节点：节点创建时自动分配序列号(FlagSequence)</li></ul><h2 id="二-启动zookeeper"><a href="#二-启动zookeeper" class="headerlink" title="二.启动zookeeper"></a>二.启动zookeeper</h2><p><img src="https://img-blog.csdnimg.cn/4a2cf8d005f2420a94bc5a627febad64.png" alt="在这里插入图片描述"></p><h2 id="三-核心包"><a href="#三-核心包" class="headerlink" title="三.核心包"></a>三.核心包</h2><p>go-zookeeper</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/samuel/go-zookeeper/zk</span><br><span class="line">文档地址: http://godoc.org/github.com/samuel/go-zookeeper/zk</span><br></pre></td></tr></table></figure><h2 id="四-Golang实现Zookeeper核心功能"><a href="#四-Golang实现Zookeeper核心功能" class="headerlink" title="四.Golang实现Zookeeper核心功能"></a>四.Golang实现Zookeeper核心功能</h2><h3 id="4-1-建立连接"><a href="#4-1-建立连接" class="headerlink" title="4.1 建立连接"></a>4.1 建立连接</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetConnect</span><span class="params">(zkList []<span class="type">string</span>)</span></span> (conn *zk.Conn) &#123;</span><br><span class="line"><span class="comment">// 创建监听的option，用于初始化zk</span></span><br><span class="line">conn, _, err := zk.Connect(zkList, <span class="number">10</span>*time.Second)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2创建节点"><a href="#4-2创建节点" class="headerlink" title="4.2创建节点"></a>4.2创建节点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(conn *zk.Conn, path <span class="type">string</span>, data []<span class="type">byte</span>, flags <span class="type">int32</span>, acl <span class="type">int32</span>)</span></span> (val <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">//flags有4种取值：</span></span><br><span class="line"><span class="comment">//0:永久，除非手动删除</span></span><br><span class="line"><span class="comment">//zk.FlagEphemeral = 1:短暂，session断开则改节点也被删除</span></span><br><span class="line"><span class="comment">//zk.FlagSequence  = 2:会自动在节点后面添加序号</span></span><br><span class="line"><span class="comment">//3:Ephemeral和Sequence，即，短暂且自动添加序号</span></span><br><span class="line"><span class="comment">// 获取访问控制权限</span></span><br><span class="line"><span class="keyword">var</span> acls []zk.ACL</span><br><span class="line"><span class="keyword">if</span> acl == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">PermRead = 1 &lt;&lt; iota   1</span></span><br><span class="line"><span class="comment">PermWrite              2</span></span><br><span class="line"><span class="comment">PermCreate             4</span></span><br><span class="line"><span class="comment">PermDelete             8</span></span><br><span class="line"><span class="comment">PermAdmin             16</span></span><br><span class="line"><span class="comment">PermAll = 0x1f        31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">acls = zk.WorldACL(zk.PermAll)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">acls = zk.WorldACL(acl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val, err = conn.Create(path, data, flags, acls)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">zkList = []<span class="type">string</span>&#123;<span class="string">&quot;127.0.0.1:2181&quot;</span>&#125;</span><br><span class="line">path   = <span class="string">&quot;/root&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCreate</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">conn := GetConnect(zkList)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line">val, err := Create(conn, path, []<span class="type">byte</span>(<span class="string">&quot;root value&quot;</span>), <span class="number">0</span>, <span class="number">31</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;创建失败: %v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;创建: %s 成功&quot;</span>, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3查询节点"><a href="#4-3查询节点" class="headerlink" title="4.3查询节点"></a>4.3查询节点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(conn *zk.Conn, path <span class="type">string</span>)</span></span> (dataStr <span class="type">string</span>, stat *zk.Stat, err <span class="type">error</span>) &#123;</span><br><span class="line">data, stat, err := conn.Get(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">string</span>(data), stat, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGet</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">conn := GetConnect(zkList)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="comment">//查询节点</span></span><br><span class="line">val, _, err := Get(conn, path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;查询%s失败, err: %v\n&quot;</span>, path, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s 的值为 %s\n&quot;</span>, path, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-4-节点是否存在"><a href="#4-4-节点是否存在" class="headerlink" title="4.4 节点是否存在"></a>4.4 节点是否存在</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Exists</span><span class="params">(conn *zk.Conn, path <span class="type">string</span>)</span></span> (exist <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">exist, _, err = conn.Exists(path)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestExist</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">conn := GetConnect(zkList)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="comment">//是否存在</span></span><br><span class="line">val, err := Exists(conn, path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;查询%s失败, err: %v\n&quot;</span>, path, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> val &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s 存在\n&quot;</span>, path)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s 不存在\n&quot;</span>, path)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-5删除节点"><a href="#4-5删除节点" class="headerlink" title="4.5删除节点"></a>4.5删除节点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除 cas支持</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Del</span><span class="params">(conn *zk.Conn, path <span class="type">string</span>)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">_, sate, _ := Get(conn, path)</span><br><span class="line">fmt.Println(sate)</span><br><span class="line">err = conn.Delete(path, sate.Version)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">conn := GetConnect(zkList)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">err := Del(conn, path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;数据删除失败: %v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;数据删除成功&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-6-修改节点内容"><a href="#4-6-修改节点内容" class="headerlink" title="4.6 修改节点内容"></a>4.6 修改节点内容</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改 CAS支持</span></span><br><span class="line"><span class="comment">// 可以通过此种方式保证原子性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Modify</span><span class="params">(conn *zk.Conn, path <span class="type">string</span>, newData []<span class="type">byte</span>)</span></span> (sate *zk.Stat, err <span class="type">error</span>) &#123;</span><br><span class="line">_, sate, _ = conn.Get(path)</span><br><span class="line">fmt.Println(sate)</span><br><span class="line">sate, err = conn.Set(path, newData, sate.Version)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestModify</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">conn := GetConnect(zkList)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">newData := []<span class="type">byte</span>(<span class="string">&quot;hello zookeeper&quot;</span>)</span><br><span class="line">stat, err := Modify(conn, path, newData)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;数据修改失败: %v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;数据修改成功,stat %v\n&quot;</span>, stat)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-7获取目录信息"><a href="#4-7获取目录信息" class="headerlink" title="4.7获取目录信息"></a>4.7获取目录信息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Children</span><span class="params">(conn *zk.Conn, path <span class="type">string</span>)</span></span> (data []<span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">data, _, err = conn.Children(path)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestChildren</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">conn := GetConnect(zkList)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">data, err := Children(conn, <span class="string">&quot;/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;获取数据失败: %v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;获取数据成功,data %v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="五-watch"><a href="#五-watch" class="headerlink" title="五.watch"></a>五.watch</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callback</span><span class="params">(event zk.Event)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;path:&quot;</span>, event.Path)</span><br><span class="line">    fmt.Println(<span class="string">&quot;type:&quot;</span>, event.Type.String())</span><br><span class="line">    fmt.Println(<span class="string">&quot;state:&quot;</span>, event.State.String())</span><br><span class="line">    fmt.Println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ZKOperateWatchTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;ZKOperateWatchTest\n&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    option := zk.WithEventCallback(callback)</span><br><span class="line">    <span class="keyword">var</span> hosts = []<span class="type">string</span>&#123;<span class="string">&quot;localhost:2181&quot;</span>&#125;</span><br><span class="line">    conn, _, err := zk.Connect(hosts, time.Second*<span class="number">5</span>, option)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> path1 = <span class="string">&quot;/zk_test_go1&quot;</span></span><br><span class="line">    <span class="keyword">var</span> data1 = []<span class="type">byte</span>(<span class="string">&quot;zk_test_go1_data1&quot;</span>)</span><br><span class="line">    exist, s, _, err := conn.ExistsW(path1)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fmt.Printf(<span class="string">&quot;path[%s] exist[%t]\n&quot;</span>, path1, exist)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;state:\n&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, ZkStateStringFormat(s))</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// try create</span></span><br><span class="line">    <span class="keyword">var</span> acls = zk.WorldACL(zk.PermAll)</span><br><span class="line">    p, err_create := conn.Create(path1, data1, zk.FlagEphemeral, acls)</span><br><span class="line">    <span class="keyword">if</span> err_create != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err_create)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;created path[%s]\n&quot;</span>, p)</span><br><span class="line"> </span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">    exist, s, _, err = conn.ExistsW(path1)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fmt.Printf(<span class="string">&quot;path[%s] exist[%t] after create\n&quot;</span>, path1, exist)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;state:\n&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, ZkStateStringFormat(s))</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// delete</span></span><br><span class="line">    conn.Delete(path1, s.Version)</span><br><span class="line"> </span><br><span class="line">    exist, s, _, err = conn.ExistsW(path1)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;path[%s] exist[%t] after delete\n&quot;</span>, path1, exist)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;state:\n&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, ZkStateStringFormat(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不止会打印watch监听的节点信息，还有打印session会话的状态</p>]]></content>
      
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper学习（二）zab协议</title>
      <link href="/2022/10/27/zookeeper/zookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89zab%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/10/27/zookeeper/zookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89zab%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前介绍了zookeeper是分布式协调框架<a href="https://blog.csdn.net/weixin_42128977/article/details/127010824?spm=1001.2014.3001.5502">添加链接描述</a>，一个分布式系统必然会存在一个问题：因为<strong>分区容忍性</strong>（partition tolerance）的存在，就必定要求我们需要在系统<strong>可用性</strong>（availability）和<strong>数据一致性</strong>（consistency）中做出权衡 。这就是著名的 CAP 定理。CAP理论中，P（分区容忍性）是必然要满足的，因为毕竟是分布式，不能把所有的应用全放到一个服务器里面，这样服务器是吃不消的。所以，只能从AP（可用性）和CP（一致性）中找平衡。后者就 ZooKeeper 的处理方式，它保证了<strong>CP</strong>（数据一致性）。<br><img src="https://img-blog.csdnimg.cn/40bf242f145646e98eed041b22198c40.png" alt="在这里插入图片描述"><br><strong>一致性</strong></p><ul><li>强一致性：时刻保证客户端看到的数据都是一致的。</li><li>最终一致性：允许存在中间状态，只要求经过一段时间后，数据最终是一致的。</li><li>弱一致性：允许存在部分数据不一致。</li></ul><h2 id="ZooKeeper集群"><a href="#ZooKeeper集群" class="headerlink" title="ZooKeeper集群"></a>ZooKeeper集群</h2><h3 id="ZooKeeper集群角色"><a href="#ZooKeeper集群角色" class="headerlink" title="ZooKeeper集群角色"></a>ZooKeeper集群角色</h3><p>Zookeeper 集群模式一共有三种类型的角色<br>Leader :ZooKeeper集群同一时间只会有一个实际工作的Leader，它会发起并维护与各<strong>Follwer及Observer</strong>间的心跳。所有的写操作必须要通<strong>过Leader</strong>完成再由Leader将写操作广播给其它服务器。只要有超过半数节点（不包括 observeer 节点）写入成功，该写请求就会被提交（类 2PC 协议）。<br>Follower:一个ZooKeeper集群可能同时存在多个Follower，它会<strong>响应Leader的心跳</strong>。Follower可直接处理并返回客户端的读请求，同时会将<strong>写请求转发给Leader处理</strong>，并且负责在Leader处理写请求时对请求进行投票。<br>Observer：角色与 Follower 类似，但是无投票权。Zookeeper 需保证高可用和强一致性，为了支持更多的客户端，需要增加更多 Server；Server 增多，投票阶段延迟增大，影响性能；引入 Observer，Observer 不参与投票； Observers 接受客户端的连接，并将写请求转发给 leader 节点； 加入更多 Observer 节点，提高伸缩性，同时不影响吞吐率。</p><h3 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h3><ul><li>LOOKING 不确定Leader状态。该状态下的服务器认为当前集群中没有Leader，会发起Leader选举。</li><li>FOLLOWING 跟随者状态。表明当前服务器角色是Follower，并且它知道Leader是谁。</li><li>LEADING 领导者状态。表明当前服务器角色是Leader，它会维护与Follower间的心跳。</li><li>OBSERVING 观察者状态。表明当前服务器角色是Observer，与Folower唯一的不同在于不参与选举，也不参与集群写操作时的投票。</li></ul><p><img src="https://img-blog.csdnimg.cn/8213bf242a63497798682cec13420726.png" alt="在这里插入图片描述"></p><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>为了保证写操作的一致性与可用性，ZooKeeper专门设计了一种名为<strong>原子广播</strong>（ZAB）的支持<strong>崩溃恢复</strong>的一致性协议。基于该协议，ZooKeeper实现了一种主从模式的系统架构来保持集群中各个副本之间的数据一致性。</p><h3 id="ZAB特性"><a href="#ZAB特性" class="headerlink" title="ZAB特性"></a>ZAB特性</h3><ul><li><strong>一致性保证</strong>：一个事务 A 被server提交(committed)了，那么它最终一定会被所有的server提交</li><li><strong>全局有序</strong>：假设有A、B两个事务，有一台server先执行A再执行B，那么可以保证所有server上A始终都被在B之前执行</li><li><strong>因果有序</strong>：如果发送者在事务A提交之后再发送B,那么B必将在A之后执行</li><li>只要大多数节点启动，系统就行正常运行</li><li>当节点下线后重启，它必须保证能恢复到当前正在执行的事务</li></ul><h3 id="ZAB的具体实现"><a href="#ZAB的具体实现" class="headerlink" title="ZAB的具体实现"></a>ZAB的具体实现</h3><ul><li>ZooKeeper由client、server两部分构成</li><li>client可以在任何一个server节点上进行读操作</li><li>client可以在任何一个server节点上发起写请求，非leader节点会把此次写请求转发到leader节点上。由leader节点执行</li><li>ZooKeeper使用<strong>改编的两阶段提交协议</strong>来保证server节点的事务一致性</li></ul><h3 id="ZXID"><a href="#ZXID" class="headerlink" title="ZXID"></a>ZXID</h3><p><img src="https://img-blog.csdnimg.cn/054dd4072e87466687a21036b60e3aa3.png" alt="在这里插入图片描述"><br>ZooKeeper会为每一个事务生成一个唯一且递增长度为64位的ZXID,ZXID由两部分组成：低32位表示计数器(counter)和高32位的纪元号(epoch)。epoch为当前leader在成为leader的时候生成的，且保证会比前一个leader的epoch大</p><p>实际上当新的leader选举成功后，会拿到当前集群中最大的一个ZXID(因为数据最新)，并去除这个ZXID的epoch,并将此epoch进行加1操作，作为自己的epoch。</p><h3 id="myid"><a href="#myid" class="headerlink" title="myid"></a>myid</h3><p>每个ZooKeeper服务器，都需要在数据文件夹下创建一个名为myid的文件，该文件包含整个ZooKeeper集群唯一的ID（整数）。例如，某ZooKeeper集群包含三台服务器，hostname分别为zoo1、zoo2和zoo3，其myid分别为1、2和3，则在配置文件中其ID与hostname必须一一对应，如下所示。在该配置文件中，server.后面的数据即为myid</p><blockquote><p>server.1&#x3D;zoo1:2888:3888<br>server.2&#x3D;zoo2:2888:3888<br>server.3&#x3D;zoo3:2888:3888</p></blockquote><h3 id="历史队列"><a href="#历史队列" class="headerlink" title="历史队列"></a>历史队列</h3><p>每一个follower节点都会有一个先进先出（FIFO)的队列用来存放收到的事务请求，保证执行事务的顺序。所以：</p><ul><li><strong>可靠提交</strong>由<strong>ZAB</strong>的事务一致性协议保证</li><li><strong>全局有序</strong>由TCP协议保证</li><li><strong>因果有序</strong>由follower的历史队列(history queue)保证</li></ul><h2 id="ZAB工作模式"><a href="#ZAB工作模式" class="headerlink" title="ZAB工作模式"></a>ZAB工作模式</h2><p>ZAB 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持<strong>崩溃恢复</strong>的<strong>原子广播</strong>协议。在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性。ZAB协议两种模式：消息广播和崩溃恢复。根据ZAB协议，<strong>所有的写操作都必须通过Leader完成，Leader写入本地日志后再复制到所有的Follower节点。一旦Leader节点无法工作，ZAB协议能够自动从Follower节点中重新选出一个合适的替代者，即新的Leader，该过程即为领导选举。该领导选举过程，是ZAB协议中最为重要和复杂的过程</strong>。基于该协议，Zookeeper 实现了一种 主备模式 的系统架构来保持集群中各个副本之间数据一致性。</p><h3 id="消息广播模式"><a href="#消息广播模式" class="headerlink" title="消息广播模式"></a>消息广播模式</h3><p>当新的Leader出来了，同时已有<strong>过半机器完成同步</strong>之后，ZAB协议将退出恢复模式。进入<strong>消息广播</strong>模式。如果有一台遵守Zab协议的服务器加入集群，因为此时集群中已经存在一个Leader服务器在广播消息，那么该新加入的服务器自动进入恢复模式：找到Leader服务器，并且完成数据同步。同步完成后，作为新的Follower一起参与到消息广播流程中。<br>如下图所示<br><img src="https://img-blog.csdnimg.cn/98bf9a3c223248f2aa6ca0e66ec0df38.png" alt="在这里插入图片描述"></p><p>由上图可见，通过Leader进行写操作，主要分为五步：</p><ol><li>客户端向zookeeper服务器发起写请求。<br>1.1 如果服务器是<strong>Follower&#x2F;Observer</strong>，转发到<strong>Leader</strong>服务器上。<br>1.2 leader生成一个<strong>新的事务Proposal并为这个事务生成一个唯一的ZXID</strong>。</li><li>Leader将写请求以<strong>Proposal（事务）</strong>的形式发给所有<strong>Follower</strong>并等待ACK。</li><li>Follower收到Proposal后，follower节点将收到的Proposal请求加入到<strong>历史队列</strong>(history queue)中，然后写入本地事务日志，根据自身情况(是否故障)，和zxid的有效性(是否大于本地最大zxid),回复是否同意该事务的ACK。</li><li>Leader得到过<strong>半数的ACK(Leader对自己默认有一个ACK)</strong> ，自己先添加事务。然后向所有的<strong>Follower和Observer发送Commmit</strong>,当follower收到commit请求时，会判断该事务的ZXID是不是比历史队列中的任何事务的ZXID都小，如果是则提交，如果不是则等待比它更小的事务的commit(保证顺序性)。</li><li>Leader将处理结果返回给客户端。</li></ol><p><strong>总结：</strong></p><ol><li>所有客户端写入数据都是写入到<strong>主进程Leader</strong>中，然后，由 Leader 复制到<strong>备份进程Follower</strong>中。从而保证数据一致性。</li><li>复制过程类似 <strong>2PC</strong>，Z<strong>AB 只需要 Follower 有</strong>一半以上<strong>返回 Ack 信息就可以执行提交</strong>，大大减小了同步阻塞。也提高了可用性。</li><li>Leader并不需要得到<strong>Observer的ACK</strong>。</li><li>Observer虽然无投票权，但仍须同步Leader的数据从而在处理读请求时可以返回尽可能新的数据。</li><li>Follower&#x2F;Observer接受写请求以后，不能直接处理，而需要将写请求转发给Leader处理， 除了多了一步请求转发，其它流程与直接写Leader无任何区别。</li><li>Leader处理写请求是通过上面的<strong>消息广播</strong>模式，实质上所有的zkServer都要执行<strong>写操作</strong>，这样数据才会一致。</li><li>ZAB协议规定了如果一个事务在一台机器上被处理(commit)成功，那么应该在所有的机器上都被处理成功，哪怕机器出现故障崩溃。</li></ol><h3 id="崩溃恢复模式"><a href="#崩溃恢复模式" class="headerlink" title="崩溃恢复模式"></a>崩溃恢复模式</h3><p><strong>恢复模式大致可以分为四个阶段  选举、发现、同步、广播。</strong></p><ul><li>当leader崩溃后，集群进入选举阶段，开始选举出潜在的新leader(一般为集群中拥有最大ZXID的节点)</li><li>进入发现阶段，follower与潜在的新leader进行沟通，如果发现超过法定人数的follower同意，则潜在的新leader将epoch加1，进入新的纪元。</li><li>集群间进行数据同步，保证集群中各个节点的事务一致</li><li>集群恢复到广播模式，开始接受客户端的写请求</li></ul><p><strong>两个确保</strong></p><ul><li><p>ZAB协议需要确保已经在Leader提交的事务最终被所有服务器提交。<br><img src="https://img-blog.csdnimg.cn/4a2db044089f478a93e6b6063bef3085.png" alt="在这里插入图片描述"><br>Leader (server2) 发送 commit 请求，他发送给了 server3，然后要发给 server1 的时候突然挂了。这个时候重新选举的时候我们如果把 server1 作为 Leader 的话，那么肯定会产生数据不一致性，因为 server3 肯定会提交刚刚 server2 发送的 commit 请求的提案，而 server1 根本没收到所以会丢弃。</p></li><li><p>ZAB协议需要确保丢弃只在Leader服务器上被提出的事务。<br><img src="https://img-blog.csdnimg.cn/1e7b66ce91074f9aa85f7bbaadeb83d5.png" alt="在这里插入图片描述"><br> Leader (server2) 此时同意了提案N1，自身提交了这个事务并且要发送给所有 Follower 要 commit 的请求，却在这个时候挂了，此时肯定要重新进行 Leader 的选举，假如此时选 server1 为 Leader 。但是过了一会，这个 挂掉的 Leader 又重新恢复了 ，此时它肯定会作为 Follower 的身份进入集群中，需要注意的是刚刚 server2 已经同意提交了提案N1，但其他 server 并没有收到它的 commit 信息，所以其他 server 不可能再提交这个提案N1了，这样就会出现数据不一致性问题了，所以 该提案N1最终需要被抛弃掉 。</p></li></ul><p><strong>脑裂问题</strong><br>脑裂问题：一个“大脑”被拆分了两个或多个“大脑”。通俗的说，就是比如当你的 cluster 里面有两个节点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master，于是 cluster 里面就会有两个 master。<br>ZAB为解决脑裂问题，要求集群内的节点数量为2N+1, 当网络分裂后，始终有一个集群的节点数量过半数，而另一个集群节点数量小于N+1（即小于半数）, 因为选主需要过半数节点同意，所以任何情况下集群中都不可能出现大于一个leader的情况。<br>因此，有了过半机制，对于一个Zookeeper集群，要么没有Leader，要没只有1个Leader，这样就避免了脑裂问题。</p><p><strong>选举原则</strong><br>    Leader选举算法保证新选举出来的Leader服务器拥有集群中所有机器最高编号（ZXID最大）的事务Proposal，那么就能保证新的Leader 一定具有已提交的所有提案，更重要是，如果这么做，可以省去Leader服务器检查Proposal的提交和丢弃工作的这一步。</p><p><strong>触发条件</strong><br>当整个集群启动过程中，或者当 Leader 服务器出现网络中弄断、崩溃退出或重启等异常时，Zab协议就会 进入崩溃恢复模式，选举产生新的Leader。</p><p><strong>选票数据结构</strong><br>每个服务器在进行领导选举时，会发送如下关键信息：</p><blockquote><p>logicClock 每个服务器会维护一个自增的整数，名为logicClock，它表示这是该服务器发起的第多少轮投票<br>state 当前服务器的状态<br>self_id 当前服务器的myid<br>self_zxid 当前服务器上所保存的数据的最大zxid<br>vote_id被推举的服务器的myid<br>vote_zxid 被推举的服务器上所保存的数据的最大zxid</p></blockquote><p><strong>投票流程</strong></p><ol><li><p><strong>自增选举轮次</strong>：ZooKeeper规定所有有效的投票都必须在同一轮次中。每个服务器在开始新一轮投票时，会先对自己维护的logicClock进行自增操作。</p></li><li><p><strong>初始化选票</strong>：每个服务器在广播自己的选票前，会将自己的投票箱清空。该投票箱记录了所收到的选票。例：服务器2投票给服务器3，服务器3投票给服务器1，则服务器1的投票箱为(2, 3), (3, 1), (1, 1)。票箱中只会记录每一投票者的最后一票，如投票者更新自己的选票，则其它服务器收到该新选票后会在自己票箱中更新该服务器的选票。</p></li><li><p><strong>发送初始化选票</strong>：每个服务器最开始都是通过广播把票投给自己。</p></li><li><p><strong>接收外部投票</strong>：服务器会尝试从其它服务器获取投票，并记入自己的投票箱内。如果无法获取任何外部投票，则会确认自己是否与集群中其它服务器保持着有效连接。如果是，则再次发送自己的投票；如果否，则马上与之建立连接。</p></li><li><p><strong>判断选举轮次</strong>：收到外部投票后，首先会根据投票信息中所包含的logicClock来进行不同处理：<br> 5.1. 外部投票的logicClock大于自己的logicClock。说明该服务器的选举轮次落后于其它服务器的选举轮次，立即清空自己的投票箱并将自己的logicClock更新为收到的logicClock，然后再对比自己之前的投票与收到的投票以确定是否需要变更自己的投票，最终再次将自己的投票广播出去。<br>  5.2. 外部投票的logicClock小于自己的logicClock。当前服务器直接忽略该投票，继续处理下一个投票。<br>  5.3. 外部投票的logickClock与自己的相等。当时进行选票PK。</p></li><li><p><strong>选票PK</strong><br>选票PK是基于(self_id, self_zxid)与(vote_id, vote_zxid)的对比：<br>6.1 外部投票的logicClock大于自己的logicClock，则将自己的logicClock及自己的选票的logicClock变更为收到的logicClock。<br>  6.2 若logicClock一致，则对比二者的vote_zxid，若外部投票的vote_zxid比较大，则将自己的票中的vote_zxid与vote_myid更新为收到的票中的vote_zxid与vote_myid并广播出去，另外将收到的票及自己更新后的票放入自己的票箱。如果票箱内已存在(self_myid, self_zxid)相同的选票，则直接覆盖。<br>  6.3 若二者vote_zxid一致，则比较二者的vote_myid，若外部投票的vote_myid比较大，则将自己的票中的vote_myid更新为收到的票中的vote_myid并广播出去，另外将收到的票及自己更新后的票放入自己的票箱.</p></li><li><p><strong>统计选票</strong><br>如果已经确定有过半服务器认可了自己的投票（可能是更新后的投票），则终止投票。否则继续接收其它服务器的投票。</p></li><li><p><strong>更新服务器状态</strong><br>投票终止后，服务器开始更新自身状态。若过半的票投给了自己，则将自己的服务器状态更新为LEADING，否则将自己的状态更新为FOLLOWING。</p></li></ol><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>当崩溃恢复之后，需要在正式工作之前（接收客户端请求），Leader 服务器首先确认事务是否都已经被过半的 Follwer 提交了，即是否完成了数据同步。目的是为了保持数据一致。<br>当 Follwer 服务器成功同步之后，Leader 会将这些服务器加入到可用服务器列表中。<br>实际上，Leader 服务器处理或丢弃事务都是依赖着 ZXID 的，那么这个 ZXID 如何生成呢？<br>答：在 ZAB 协议的事务编号 ZXID 设计中，ZXID 是一个 64 位的数字，其中低 32 位可以看作是一个简单的递增的计数器，针对客户端的每一个事务请求，Leader 都会产生一个新的事务 Proposal 并对该计数器进行 + 1 操作。而高 32 位则代表了 Leader 服务器上取出本地日志中最大事务 Proposal 的 ZXID，并从该 ZXID 中解析出对应的 epoch 值(leader选举周期)，当一轮新的选举结束后，会对这个值加一，并且事务id又从0开始自增。<br><img src="https://img-blog.csdnimg.cn/44ae907056ef45ba83235c47722337b2.png" alt="在这里插入图片描述"></p><p>高 32 位代表了每代 Leader 的唯一性，低 32 代表了每代 Leader 中事务的唯一性。同时，也能让 Follwer 通过高 32 位识别不同的Leader。简化了数据恢复流程。<br>基于这样的策略：当 Follower 连接上 Leader 之后，Leader 服务器会根据自己服务器上最后被提交的 ZXID 和 Follower 上的 ZXID 进行比对，比对结果要么回滚，要么和 Leader 同步。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><pre><code>ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃回复的原子广播协议。</code></pre></li><li>整个 Zookeeper 就是在这两个模式之间切换。 简而言之，当 Leader 服务可以正常使用，就进入消息广播模式，当 Leader 不可用时，则进入崩溃恢复模式。</li><li>Zookeeper使用单一的主进程来接收并处理客户端的所有事务请求，并采用ZAB的原子广播协议，将服务器数据的状态变更以事务Proposal的形式广播到所有副本进程上去。ZAB协议的主备模型架构保证了同一时刻集群中只能够有一个主进程来广播服务器的状态变更，因此能够更好的处理客户端大量的并发请求。</li><li>消息广播，类似2PC，Leader和每个Follower之间维护一个FIFO队列。</li><li>Leader崩溃，或者Leader失去与过半Follower的联系，集群转入崩溃回复模式，回复后重新选举Leader。</li><li>ZAB特性需要确保那些已经在Leader服务器上提交的事务最终被所有服务器都提交</li><li>ZAB协议需要确保丢弃那些只在Leader服务器上被提出的事务</li></ul>]]></content>
      
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> 中间件 </tag>
            
            <tag> zab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis的持久化方式</title>
      <link href="/2022/10/27/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2022/10/27/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis持久化方式"><a href="#Redis持久化方式" class="headerlink" title="Redis持久化方式"></a>Redis持久化方式</h1><h2 id="1-为什么要持久化"><a href="#1-为什么要持久化" class="headerlink" title="1.为什么要持久化"></a>1.为什么要持久化</h2><p>Redis是内存数据库，宕机后数据会消失，Redis重启后快速恢复数据，要提供持久化机制。Redis持久化不保证数据的完整性，有可能会丢数据。当下次Redis重启时，利用持久化文件实现数据恢复。除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。</p><h2 id="2-RDB-默认"><a href="#2-RDB-默认" class="headerlink" title="2.RDB(默认)"></a>2.RDB(默认)</h2><p>RDB方式是通过快照完成的。它保存的是某一时刻的数据并不关注过程。RDB保存redis某一时刻的数据的快照。</p><h3 id="2-1触发条件"><a href="#2-1触发条件" class="headerlink" title="2.1触发条件"></a>2.1触发条件</h3><ul><li>执行save命令              （会在主进程执行RDB，导致其他命令阻塞）</li><li>执行bgsave命令            (会开启独立进程异步执行RDB,主进程可以持续处理请求)</li><li>shutdown指令： （redis通过shutdown指令接受到关闭服务器的请求时，会触发一次SAVE命令，阻塞所有的客户端）</li><li>执行主从复制操作 (第一次)。</li><li>符合自定义配置的快照规则；<br><img src="https://img-blog.csdnimg.cn/7e3fbb9b8e2b40bca00c0ed9cd1ad35e.png" alt="在这里插入图片描述"></li></ul><h3 id="2-2-执行流程"><a href="#2-2-执行流程" class="headerlink" title="2.2.执行流程"></a>2.2.执行流程</h3><p><img src="https://img-blog.csdnimg.cn/6cc66ba03bac44deb4b75b034bbdb358.png" alt="在这里插入图片描述"><br><strong>写时复制机制(cow机制)</strong><br>原因：在服务执行请求的同时，<code>Redis</code>还需要进行快照<strong>（文件IO操作）</strong>，所以<code>文件IO</code>操作不能进行多路复用。单线程同时在服务线上的请求还要进行<code>文件 IO </code>操作，<code>文件 IO</code> 操作会严重拖垮服务器请求的性能。</p><p>原理：<code>Redis </code>在持久化时<strong>fork 产生一个子进程</strong>，快照持久化完全交给子进程来处理，子进程刚刚产生时，它和父进程共享内存里面的<strong>代码段和数据段（上图共享内存）</strong>。这是 Linux 操作系统的机制，为了节约内存资源，所以尽可能让它们共享起来。在进程分离的一瞬间，内存的增长几乎没有明显变化。这时父进程持续服务客户端请求，然后对内存数据结构进行不间断的修改。这个时候就会使用操作系统的 <code>COW </code>机制来进行数据段页面的分离（<strong>对数据页进行复制，子进程读取不变</strong>）。父进程修改操作的持续进行，越来越多的共享页面被分离出来，内存就会持续增长。但是也不会超过原有数据内存的 2 倍大小。</p><p><strong>执行流程</strong></p><ol><li><code>Redis</code>父进程首先判断：当前是否在执行<strong>save，或bgsave&#x2F;bgrewriteaof</strong>的子进程，如果在执行则<code>bgsave</code>命令直接返回。<code>bgsave/bgrewriteaof </code>的子进程不能同时执行，主要是基于性能方面的考虑：两个并发的子进程同时执行大量的<strong>磁盘写操作</strong>，可能引起严重的性能问题;</li><li>父进程执行<code>fork</code>操作创建子进程，这个过程中<strong>父进程是阻塞</strong>的，<code>Redis</code><strong>不能</strong> 执行来自客户端的任何命令;</li><li>父进程<code>fork</code>后，<code>bgsave</code>命令不再阻塞父进程，并可以响应其他命令;</li><li>子进程创建<code>RDB</code>文件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换;</li><li>子进程发送信号给父进程表示完成，父进程更新统计信息。</li></ol><p><strong>save与bgsave对比：</strong></p><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>是否阻塞redis其它命令</td><td>是</td><td>否(在生成子进程执行调用fork函数时会有短暂阻塞)</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fork子进程，消耗内存</td></tr></tbody></table><h3 id="2-3-在执行BGSAVE命令时，服务器BGSAVE-，SAVAE-BGREWRITEAOF-异同。-了解"><a href="#2-3-在执行BGSAVE命令时，服务器BGSAVE-，SAVAE-BGREWRITEAOF-异同。-了解" class="headerlink" title="2.3.在执行BGSAVE命令时，服务器BGSAVE ，SAVAE ,BGREWRITEAOF 异同。(了解)"></a>2.3.在执行BGSAVE命令时，服务器BGSAVE ，SAVAE ,BGREWRITEAOF 异同。(了解)</h3><p>1.<code>BGSAVE</code>执行期间，客户端发送<code>SAVE</code>命令全部拒绝。避免父子进程同时调用<code>rdbSave</code>，防止竞争。<br>2.<code>BGSAVE</code>执行期间，客户端发送<code>BGSAVE</code>命令全部拒绝，同理。<br>3.<code>BGSAVE</code>和<code>BGWRITEAOF</code>不能同时执行。如果执行<code>BGSAVE</code>期间，客户端发送<code>BGWRITEAOF</code>指令，延迟到<code>BGSAVE</code>指令完成之后执行。如果<code>BGWRITEAOF</code>正在执行，客户端发送<code>BGSAVE</code>会被拒绝。两个指令都是子进程完成，出于性能考虑不能同时执行，并且两个指令进行大量写入磁盘的操作。</p><h3 id="2-4-RDB优缺点"><a href="#2-4-RDB优缺点" class="headerlink" title="2.4 RDB优缺点"></a>2.4 RDB优缺点</h3><h2 id="3-AOF"><a href="#3-AOF" class="headerlink" title="3.AOF"></a>3.AOF</h2><p><code>Redis</code>默认情况下是不开启的。开启<code>AOF</code>持久化后<code>Redis </code>将所有对数据库进行过<strong>写入的命令记录</strong>到 <code>AOF </code>文件， 这样当Redis重启后只要按顺序回放这些命令就会恢复到原始状态了。<strong>AOF会记录过程，RDB只管结果</strong>。<br>通过修改配置文件来打开 AOF 功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># appendonly yes</span></span><br></pre></td></tr></table></figure><p>可以配置 Redis 多久才将数据 fsync 到磁盘一次。<br>有三个选项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always：每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。</span><br><span class="line">appendfsync everysec：每秒 fsync 一次，足够快，并且在故障时只会丢失 <span class="number">1</span> 秒钟的数据。</span><br><span class="line">appendfsync no：从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。</span><br></pre></td></tr></table></figure><p>推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。</p><h3 id="3-1执行流程"><a href="#3-1执行流程" class="headerlink" title="3.1执行流程"></a>3.1执行流程</h3><p><img src="https://img-blog.csdnimg.cn/bee4eadf269c40f49e73c7c508e9aa0c.png" alt="在这里插入图片描述"><br>1.<code>Redis</code>父进程首先判断当前是否存在正在执行 <code>bgsave/bgrewriteaof</code>的子进程，如果存在则<code>bgrewriteaof</code>命令直接返回，如果存在<code>bgsave</code>命令则等<code>bgsave</code>执行完成后再执行。前面曾介绍过，这个主要是基于性能方面的考虑。<br>2. 父进程执行<code>fork</code>操作创建子进程，这个过程中父进程是阻塞的。<br>3.1:父进程<code>fork</code>后，<code>bgrewriteaof</code>命令返回并不再阻塞父进程，并可以响应其他命令。<code>Redis</code>的所有写命令依然写入<strong>AOF缓冲区(aof_buf)<strong>。<br>3.2. 由于<code>fork</code>操作使用写时复制技术，子进程只能共享<code>fork</code>操作时的内存数据。由于父进程依然在响应命令，因此<code>Redis</code>使用<code>AOF</code>重写缓冲区(图中的<code>aof_rewrite_buf)</code>保存这部分数据，防止新AOF文件生成期间丢失这部分数据。也就是说，<code>bgrewriteaof</code>执行期间，Redis的写命令同时追加到</strong>aof_buf和aof_rewirte_buf两个缓冲区</strong>。（<code>aof_buf</code>定时写入aof文件，<code>aof_rewirte_buf</code>写入新的aof文件）<br>4. 子进程根据内存快照，按照命令合并规则写入到新的<code>AOF</code>文件。<br>5.1.子进程写完新的<code>AOF</code>文件后，向父进程发信号。<br>5.2.父进程把<code>AOF</code>重写缓冲区的数据写入到新的AOF文件，这样就保证了新AOF文件所保存的数据库状态和服务器当前状态一致。<br>5.3.使用新的<code>AOF</code>文件替换老文件，完成AOF重写。</p><p>AOF的执行流程包括：</p><ul><li>命令追加(append)：Redis的所有写命令依然写入<code>AOF缓冲区(aof_buf)</code>。（主要是为了避免每次有写命令都直接写入硬盘，导致硬盘IO成为Redis负载的瓶颈。）</li><li>文件写入(write)和文件同步(sync)：根据不同的同步策略将<code>aof_buf</code>中的内容同步到硬盘；操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到硬盘里。这样的操作虽然提高了效率，但也带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失；因此系统同时提供了<strong>fsync、fdatasync（appendfsync控制）等同步函数</strong>，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保数据的安全性。</li><li>文件重写(rewrite)：定期重写<code>AOF</code>文件，达到压缩的目的。</li></ul><h3 id="3-2-AOF重写"><a href="#3-2-AOF重写" class="headerlink" title="3.2.AOF重写"></a>3.2.AOF重写</h3><p>如下两个配置可以控制AOF自动重写频率</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta"># auto‐aof‐rewrite‐min‐size 64mb <span class="comment">//aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就</span></span></span><br><span class="line">很快，重写的意义不大</span><br><span class="line"><span class="number">2</span> <span class="meta"># auto‐aof‐rewrite‐percentage 100 <span class="comment">//aof文件自上一次重写后文件大小增长了100%则再次触发重写</span></span></span><br></pre></td></tr></table></figure><p>当然AOF还可以手动重写，进入redis客户端执行命令<strong>bgrewriteaof</strong>重写AOF。<br>注意，<code>AOF</code>重写<code>redis</code>会<code>fork</code>出一个子进程去做(与bgsave命令类似)，不会对<code>redis</code>正常命令处理有太多<br>影响。</p><p><code>Redis</code>可以在<code> AOF</code>体积变得过大时，自动地在后台（Fork子进程）对 AOF进行重写。重写后的新 <code>AOF</code>文件包含了恢复当前数据集所需的最小命令集合。 <strong>AOF 重写并不需要对原有的 AOF 文件进行任何写入和读取</strong>， 它针对的是数据库中键的当前值。<br>Redis 不希望 AOF 重写造成服务器无法处理请求， 所以<code>Redis</code>决定将 AOF 重写程序放到（后台）子进程里执行， 这样处理的最大好处是：<br>1、子进程进行 <code>AOF</code> 重写期间，主进程可以继续处理命令请求。<br>2、子进程带有主进程的数据副本，使用子进程而不是线程，可以在避免锁的情况下，保证数据的安全性。<br>不过， 使用子进程也有一个问题需要解决： <strong>因为子进程在进行 AOF 重写期间， 主进程还需要继续处理命令， 而新的命令可能对现有的数据进行修改， 这会让当前数据库的数据和重写后的 AOF 文件中的数据不一致。</strong><br>为了解决这个问题，<code>Redis</code>增加了一个 <code>AOF </code>重写缓存， 这个缓存在 <code>fork </code>出子进程之后开始启用，Redis 主进程在接到新的写命令之后， 除了会将这个写命令的协议内容追加到现有的 AOF 文件之外，还会追加到这个缓存中。</p><p>当子进程在执行 <code>AOF </code>重写时， 主进程需要执行以下三个工作：<br>1.处理命令请求；<br>2.将写命令追加到现有的 <code>AOF </code>文件中；<br>3.将写命令追加到<code>AOF</code>重写缓存中。<br>当子进程完成<code>AOF</code>重写之后， 它会向父进程发送一个完成信号， 父进程在接到完成信号之后， 会调用一个信号处理函数， 并完成以下工作：<br>1、 将 AOF 重写缓存中的内容全部写入到新 <code>AOF</code> 文件中；<br>2、 对新的 AOF 文件进行改名，覆盖原有的 <code>AOF </code>文件；<br><strong>Redis数据库里的+AOF重写过程中的命令——-&gt;新的AOF文件—-&gt;覆盖老的AOF文件</strong><br>这个信号处理函数执行完毕之后， 主进程就可以继续像往常一样接受命令请求了。 在整个<code>AOF</code>后台重写过程中， 只有最后的<strong>写入缓存和改名操作会造成主进程阻塞</strong>， 在其他时候，<code>AOF</code>后台重写都不会对主进程造成阻塞， 这将 AOF 重写对性能造成的影响降到了最低。</p><h2 id="4-RDB和AOF如何选择"><a href="#4-RDB和AOF如何选择" class="headerlink" title="4.RDB和AOF如何选择"></a>4.RDB和AOF如何选择</h2><h3 id="4-1-RDB和AOF的优缺点"><a href="#4-1-RDB和AOF的优缺点" class="headerlink" title="4.1.RDB和AOF的优缺点"></a>4.1.RDB和AOF的优缺点</h3><p><strong><code>RDB</code>持久化</strong><br><strong>优点</strong></p><ul><li>使用<code>RDB</code>文件来恢复大型数据较快，恢复数据远远快于<code>AOF</code>；</li><li>主进程<code>fork</code>子进程，可以最大化<code>Redis</code>性能；</li><li>RDB是二进制压缩文件，占用空间小，便于传输（传给slaver）适合备份、全量复制等场景；<br><strong>缺点</strong></li><li>数据安全性低。<code>RDB</code>是间隔一段时间进行持久化，如果持久化之间<code>redis</code>发生故障，会发生数据丢失。<br>同步时可能会影响<code>redis</code>工作。<code>fork</code>子进程这个过程和redis的数据量有很大关系，数据量越大，时间越久。</li><li>兼容性差（如老版本的Redis不兼容新版本的RDB文件）。</li></ul><p><strong>AOF持久化</strong><br><strong>优点</strong></p><ul><li><p>AOF 的默认策略为每秒钟<code>fsync</code>一次，在这种配置下，<code>Redis </code>仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据，也可以根据实际情况设置fsync的策略。</p></li><li><p><code>AOF</code> 文件是一个只进行追加操作的日志文件，  即使日志因为某些原因而包含了未写入完整的命令， redis-check-aof 工具也可以轻易地修复这种问题。</p></li><li><p><code>Redis </code>可以在<code> AOF</code> 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 <code>AOF </code>文件包含了恢复当前数据集所需的最小命令集合。 <strong>整个重写操作是绝对安全的</strong>，因为<code>Redis</code>在创建新 <code>AOF </code>文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即<strong>使重写过程中发生停机，现有的 AOF 文件也不会丢失</strong>。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p></li><li><p>AOF 文件有序地保存了对数据库执行的所有写入操作。</p></li></ul><p><strong>缺点</strong></p><ul><li>对于具有相同数据的的 Redis，AOF 文件通常会比 RDF 文件体积更大。</li><li>虽然 AOF 提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能。但在 Redis 的负载较高时，RDB 比 AOF 具好更好的性能保证。</li></ul><h3 id="4-2-持久化策略选择"><a href="#4-2-持久化策略选择" class="headerlink" title="4.2.持久化策略选择"></a>4.2.持久化策略选择</h3><p>在介绍持久化策略之前，首先要明白无论是RDB还是AOF，<strong>持久化的开启都是要付出性能方面代价的</strong>。对于RDB持久化，一方面是<code>bgsave</code>在进行<code>fork</code>操作时<code>Redis</code>主进程会阻塞，另一方面，子进程向硬盘写数据也会带来<code>IO</code>压力；对于<code>AOF</code>持久化，向硬盘写数据的频率大大提高(everysec策略下为秒级)，<code>IO</code>压力更大，甚至可能造成<code>AOF</code>追加<strong>阻塞问题</strong>，此外，<code>AOF文件的重写</code>与<code>RDB的bgsave</code>类似，会有fork时的阻塞和子进程的IO压力问题。相对来说，由于AOF向硬盘中写数据的频率更高，因此对Redis主进程性能的影响会更大。<br>（1）如果<code>Redis</code>中的数据完全丢弃也没有关系，那么无论是单机，还是主从架构，都可以不进行任何持久化。<br>（2）在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择<code>RDB</code>对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择<code>AOF</code>。<br>（3）但在多数情况下，我们都会配置<strong>主从环境</strong>，slave的存在既可以实现<strong>数据的热备</strong>，也可以进行读写分离分担<code>Redis</code>读请求，以及在master宕掉后继续提供服务。<br>在这种情况下，一种可行的做法是：</p><ul><li><strong>master</strong>：完全关闭持久化（包括RDB和AOF），这样可以让master的性能达到最好;</li><li><strong>slave</strong>：开启<code>AOF</code>（如果对数据安全要求不高，开启RDB关闭AOF也可以），并定时对持久化文件进行<code>备份</code>（如备份到其他文件夹，并标记好备份的时间）；然后关闭<code>AOF</code>的自动重写，然后添加定时任务，在每天<code>Redis</code>闲时（如凌晨12点）调用<code>bgrewriteaof</code>。<br>这里需要解释一下，为什么开启了主从复制，可以实现数据的热备份，还需要设置持久化呢？因为在一些特殊情况下，主从复制仍然不足以保证数据的安全，例如：**<code>master和slave</code>进程同时停止。考虑这样一种场景，如果<code>master</code>和<code>slave</code>在同一栋大楼或同一个机房，则一次停电事故就可能导致master和slave机器同时关机，Redis进程停止；如果没有持久化，则面临的是数据的完全丢失**。</li><li><strong>master误重启</strong>：考虑这样一种场景，master服务因为故障宕掉了，如果系统中有自动拉起机制将<strong>master自动重启</strong>，由于没有持久化文件，那么master重启后数据是空的，slave同步数据也变成了空的；如果master和slave都没有持久化，同样会面临数据的完全丢失。</li><li><strong>异地灾备</strong>：上述讨论的几种持久化策略，针对的都是一般的系统故障，如进程异常退出、宕机、断电等，这些故障不会损坏硬盘。但是对于一些可能导致硬盘损坏的灾难情况，如<strong>火灾地震，就需要进行异地灾备</strong>。例如对于单机的情形，可以定时将<code>RDB</code>文件或重写后的<code>AOF</code>文件，通过scp拷贝到远程机器，如阿里云、AWS等；<strong>对于主从的情形，可以定时在master上执行bgsave，然后将RDB文件拷贝到远程机器，或者在slave上执行bgrewriteaof重写AOF文件后，将AOF文件拷贝到远程机器上</strong>。一般来说，由于RDB文件文件小、恢复快，因此灾难恢复常用RDB文件；异地备份的频率根据数据安全性的需要及其他条件来确定，但最好不要低于一天一次。</li></ul><h2 id="5-其他问题"><a href="#5-其他问题" class="headerlink" title="5. 其他问题"></a>5. 其他问题</h2><h3 id="5-1-fork阻塞：CPU的阻塞"><a href="#5-1-fork阻塞：CPU的阻塞" class="headerlink" title="5.1. fork阻塞：CPU的阻塞"></a>5.1. fork阻塞：CPU的阻塞</h3><p>众多因素限制了<code>Redis</code>单机的内存不能过大，例如：当面对请求的暴增，需要从库扩容时，Redis内存过大会导致扩容时间太长；当主机宕机时，切换主机后需要挂载从库，Redis内存过大导致挂载速度过慢；以及持久化过程中的fork操作，下面详细说明。<br>首先说明一下fork操作：父进程通过fork操作可以创建子进程；子进程创建后，<strong>父子进程共享代码段，不共享进程的数据空间</strong>，但是子进程会获得父进程的数据空间的副本。在操作系统fork的实际实现中，基本都采用了<strong>写时复制技术</strong>，即在父&#x2F;子进程试图修改数据空间之前，父子进程实际上共享数据空间；但是当父&#x2F;子进程的任何一个试图修改数据空间时，操作系统会为修改的那一部分(内存的一页)制作一个副本。<br>虽然fork时，子进程不会复制父进程的数据空间，但是会复制内存页表（页表相当于内存的索引、目录）；<strong>父进程的数据空间越大，内存页表越大，fork时复制耗时也会越多。</strong><br>在Redis中，<strong>无论是RDB持久化的bgsave，还是AOF重写的bgrewriteaof</strong>，都需要fork出子进程来进行操作。如果Redis内存过大，会导致fork操作时复制内存页表耗时过多；而<strong>Redis主进程在进行fork时，是完全阻塞的，也就意味着无法响应客户端的请求，会造成请求延迟过大</strong>。</p><h3 id="5-2-AOF追加阻塞：硬盘的阻塞"><a href="#5-2-AOF追加阻塞：硬盘的阻塞" class="headerlink" title="5.2. AOF追加阻塞：硬盘的阻塞"></a>5.2. AOF追加阻塞：硬盘的阻塞</h3><p>在<code>AOF</code>中，如果<code>AOF缓冲区</code>的文件同步策略为<code>everysec</code>，则：在主线程中，命令写入<code>aof_buf</code>后调用系统<code>write</code>操作，<code>write</code>完成后主线程返回；<strong>fsync同步文件操作由专门的文件同步线程每秒调用一次</strong>。<br><strong>这种做法的问题在于，如果硬盘负载过高，那么fsync操作可能会超过1s；如果Redis主线程持续高速向aof_buf写入命令，硬盘的负载可能会越来越大，IO资源消耗更快；如果此时Redis进程异常退出，丢失的数据也会越来越多，可能远超过1s。</strong><br>为此，Redis的处理策略是这样的：主线程每次进行AOF会对比上次fsync成功的时间；如果距上次不到2s，主线程直接返回；如果超过2s，则主线程阻塞直到fsync同步完成。因此，如果系统硬盘负载过大导致fsync速度太慢，会导致Redis主线程的阻塞；此外，使用everysec配置，AOF最多可能丢失2s的数据，而不是1s。</p><h2 id="6-混合持久化"><a href="#6-混合持久化" class="headerlink" title="6.混合持久化"></a>6.混合持久化</h2><p>配置可以开启混合持久化(必须先开启aof)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># aof‐use‐rdb‐preamble yes</span></span><br></pre></td></tr></table></figure><p><code>AOF</code>在重写时，不再是单纯将内存数据转换为<code>RESP</code>命令写入<code>AOF</code>文件，而是将重写这一刻之前的内存做<code>RDB</code>快照处理，并且将RDB快照内容和增量的<code>AOF</code>修改内存数据的命令存在一起，都写入新的<code>AOF</code>文件，新的文件一开始不叫appendonly.aof，等到重写完新的<code>AOF</code>文件才会进行改名，覆盖原有的<code>AOF</code>文件，完成新旧两个<code>AOF</code>文件的替换。<br>于是在 <code>Redis </code>重启的时候，<strong>可以先加载<code>RDB</code>的内容，然后再重放增量 AOF<code> 日志就可以完全替代之前的</code>AOF&#96; 全量文件重放，因此重启效率大幅得到提升。</strong><br>混合持久化AOF文件结构如下<br><img src="https://img-blog.csdnimg.cn/53438d24c0c549dc8483921497603df8.png" alt="在这里插入图片描述"></p><h2 id="7-Redis数据备份策略"><a href="#7-Redis数据备份策略" class="headerlink" title="7.Redis数据备份策略"></a>7.Redis数据备份策略</h2><ol><li>写crontab定时调度脚本，每小时都copy一份rdb或aof的备份到一个目录中去，仅仅保留最近48<br>小时的备份；</li><li>每天都保留一份当日的数据备份到一个目录中去，可以保留最近1个月的备份；</li><li>每次copy备份的时候，都把太旧的备份给删了；</li><li>每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏。</li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你是不是认为Singleflight是单例模式</title>
      <link href="/2022/10/27/golang/%E5%B8%B8%E7%94%A8%E5%8C%85%E5%AD%A6%E4%B9%A0/singleflight/"/>
      <url>/2022/10/27/golang/%E5%B8%B8%E7%94%A8%E5%8C%85%E5%AD%A6%E4%B9%A0/singleflight/</url>
      
        <content type="html"><![CDATA[<h3 id="一-为什么需要Singleflight"><a href="#一-为什么需要Singleflight" class="headerlink" title="一.为什么需要Singleflight?"></a>一.为什么需要Singleflight?</h3><p>一般情况下我们在写对外的服务的时候都会有一层 cache 作为缓存，用来减少底层数据库的压力，但是在遇到例如 redis 抖动或者其他情况可能会导致大量的 cache 失效出现，导致大量请求打入数据库，造成数据库压力。</p><h3 id="二-使用场景"><a href="#二-使用场景" class="headerlink" title="二.使用场景"></a>二.使用场景</h3><p>这个库的主要作用就是: <strong>将一组相同的请求合并成一个请求，实际上只会去请求一次，然后对所有的请求返回相同的结果。</strong></p><p>主要场景：用在对指定资源频繁操作(高并发下的缓存击穿)</p><h3 id="三-原理解析"><a href="#三-原理解析" class="headerlink" title="三.原理解析"></a>三.原理解析</h3><h4 id="1-内部结构介绍"><a href="#1-内部结构介绍" class="headerlink" title="1.内部结构介绍"></a>1.内部结构介绍</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据结构是用来记录key相关数据，即请求当前key的个数和请求结果</span></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">wg sync.WaitGroup</span><br><span class="line">    <span class="comment">// 请求返回结果，会在sync.WaitGroup为Done的时候执行</span></span><br><span class="line">val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err <span class="type">error</span></span><br><span class="line">    <span class="comment">// 可以理解为请求key的个数，每增加一个请求，则值加1 </span></span><br><span class="line">dups  <span class="type">int</span></span><br><span class="line">    <span class="comment">// 存储所有key对应的 Result&#123;&#125;, 一个请求对应一个 Result</span></span><br><span class="line">chans []<span class="keyword">chan</span>&lt;- Result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SingleFlight 的主结构体 </span></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.Mutex       <span class="comment">// 并发锁</span></span><br><span class="line">m  <span class="keyword">map</span>[<span class="type">string</span>]*call <span class="comment">// 懒加载 用来存储key与请求的关系</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// Do 执行函数, 对同一个 key 多次调用的时候，在第一次调用没有执行完的时候</span></span><br><span class="line"><span class="comment">// 只会执行一次 fn 其他的调用会阻塞住等待这次调用返回</span></span><br><span class="line"><span class="comment">// v, err 是传入的 fn 的返回值</span></span><br><span class="line"><span class="comment">// shared 表示当前返回结果是否为多个请求结果</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Do(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)) (v <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>, shared <span class="type">bool</span>)</span><br><span class="line"><span class="comment">// DoChan 和 Do 类似，只是 DoChan 返回一个 channel，也就是同步与异步的区别</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> DoChan(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)) &lt;-<span class="keyword">chan</span> Result</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Forget 用于通知 Group 删除某个key这样后面继续这个key的调用的时候就不会在阻塞等待了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Forget(key <span class="type">string</span>)</span><br></pre></td></tr></table></figure><h4 id="2-常用Do方法解析（Dochan逻辑类似）"><a href="#2-常用Do方法解析（Dochan逻辑类似）" class="headerlink" title="2.常用Do方法解析（Dochan逻辑类似）"></a>2.常用Do方法解析（Dochan逻辑类似）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Do(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)) (v <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>, shared <span class="type">bool</span>) &#123;</span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">      g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*call)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">      <span class="comment">// 存在相同的key, 增加计数</span></span><br><span class="line">      c.dups++</span><br><span class="line">      g.mu.Unlock()</span><br><span class="line">      c.wg.Wait() <span class="comment">//等待这个key对应的fn调用完成</span></span><br><span class="line">      <span class="keyword">return</span> c.val, c.err, <span class="literal">true</span> <span class="comment">// 返回fn调用的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    c := <span class="built_in">new</span>(call) <span class="comment">// 不存在key, 是第一个请求, 创建一个call结构体</span></span><br><span class="line">    c.wg.Add(<span class="number">1</span>)</span><br><span class="line">    g.m[key] = c <span class="comment">//加入到映射表中</span></span><br><span class="line">    g.mu.Unlock()</span><br><span class="line">    g.doCall(c, key, fn) <span class="comment">// 调用方法</span></span><br><span class="line">    <span class="keyword">return</span> c.val, c.err, c.dups &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SingleFlight 定义一个call结构体，每个结构体都保存了fn调用对应的信息。</p><p>1.每次调用Do方法都会先去获取互斥锁，随后判断在映射表里是否已经有Key对应的<code>fn</code>函数调用信息的<code>call</code>结构体。</p><p>2.当key不存在时，证明是这个Key的第一次请求，那么会初始化一个<code>call</code>结构体指针，增加<code>SingleFlight</code>内部持有的<code>sync.WaitGroup</code>计数器到1。释放互斥锁，然后阻塞的等待doCall方法执行<code>fn</code>函数的返回结果</p><p>3.当key存在时，增加<code>call</code>结构体内代表<code>fn</code>重复调用次数的计数器<code>dups</code>，释放互斥锁，然后使用<code>WaitGroup</code>等待<code>fn</code>函数执完成。</p><p>4.卡在第2步的方法得到执行，返回结果</p><p>5.<code>call</code>结构体的<code>val</code> 和 <code>err</code> 两个字段只会在 <code>doCall</code>方法中执行<code>fn</code>有返回结果后才赋值。</p><h3 id="四-简单使用"><a href="#四-简单使用" class="headerlink" title="四.简单使用"></a>四.简单使用</h3><h4 id="1-示例介绍"><a href="#1-示例介绍" class="headerlink" title="1.示例介绍"></a>1.示例介绍</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;golang.org/x/sync/singleflight&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟调用1000次 实际1000次</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getArticle</span><span class="params">(id <span class="type">int</span>)</span></span> (article <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// 假设这里会对数据库进行调用, 模拟不同并发下耗时不同</span></span><br><span class="line">atomic.AddInt32(&amp;count, <span class="number">1</span>)</span><br><span class="line">fmt.Println(count)</span><br><span class="line">time.Sleep(time.Duration(count) * time.Millisecond)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;article: %d&quot;</span>, id), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟调用1000次，实际接近1次</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleFlightGetArticle</span><span class="params">(sg *singleflight.Group, id <span class="type">int</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">v, err, _ := sg.Do(fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, id), <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getArticle(id)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> v.(<span class="type">string</span>), err</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 模拟1000请求访问</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">wg  sync.WaitGroup</span><br><span class="line">now = time.Now()</span><br><span class="line">n   = <span class="number">1000</span></span><br><span class="line">sg  = &amp;singleflight.Group&#123;&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">res, _ := singleFlightGetArticle(sg, <span class="number">1</span>)</span><br><span class="line"><span class="comment">//res, _ := getArticle(1)</span></span><br><span class="line"><span class="keyword">if</span> res != <span class="string">&quot;article: 1&quot;</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;err&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Printf(<span class="string">&quot;同时发起 %d 次请求，耗时: %s&quot;</span>, n, time.Since(now))</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------</span><br><span class="line"><span class="comment">//getArticle 同时发起 1000 次请求，耗时: 1.0786589s 相当于1000个相同请求打入数据库</span></span><br><span class="line"><span class="comment">//singleFlightGetArticle方法 同时发起 1000 次请求，耗时: 4.2138ms </span></span><br></pre></td></tr></table></figure><h4 id="2-泛型版本"><a href="#2-泛型版本" class="headerlink" title="2.泛型版本"></a>2.泛型版本</h4><p>Do 方法返回的 v 是 interface{}，我们做了类型断言：<code>v.(string)</code>。</p><p> Go1.18 有了泛型，可以有泛型版本的 singleflight，不需要做类型断言了。GitHub 已经有人实现并开源：<a href="https://github.com/marwan-at-work/singleflight%E3%80%82">https://github.com/marwan-at-work/singleflight。</a></p><p>可以使用泛型的singleflight不需要做类型断言</p><h3 id="五-注意事项"><a href="#五-注意事项" class="headerlink" title="五.注意事项"></a>五.注意事项</h3><h4 id="1-一个阻塞，全员等待"><a href="#1-一个阻塞，全员等待" class="headerlink" title="1.一个阻塞，全员等待"></a>1.一个阻塞，全员等待</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改上面的singleFlightGetArticle方法，新增select阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleFlightGetArticle2</span><span class="params">(sg *singleflight.Group, id <span class="type">int</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">v, err, _ := sg.Do(fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, id), <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// 模拟阻塞</span></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line"><span class="keyword">return</span> getArticle2(id)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> v.(<span class="type">string</span>), err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;结果：导致整个程序阻塞</p><p><strong>解决方法: context + DoChan + select</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用一个含超时限制的context</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleflightGetArticle</span><span class="params">(ctx context.Context, sg *singleflight.Group, id <span class="type">int</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">result := sg.DoChan(fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, id), <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// 模拟出现问题，hang 住</span></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line"><span class="keyword">return</span> getArticle(id)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> r := &lt;-result:</span><br><span class="line"><span class="keyword">return</span> r.Val.(<span class="type">string</span>), r.Err</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-一个出错，全部出错"><a href="#2-一个出错，全部出错" class="headerlink" title="2.一个出错，全部出错"></a>2.一个出错，全部出错</h4><p>因为singleflight就是这么设计的。如果1s尝试10次，但是用了singleflight之后只能尝试一次。只要出错这段时间内的所有请求都会收到影响。</p><h3 id="六-总结"><a href="#六-总结" class="headerlink" title="六.总结"></a>六.总结</h3><p>1.Do方法和DoChan方法，分别提供了同步和异步的调用方式，这让我们使用起来也更加灵活；</p><p>2.如果调用Forget方法 可以通知 Group 在持有的映射表中删除某个键，接下来对该键的调用就不会等待前面的函数返回了；</p><p>3.一旦调用的函数返回了错误，所有在等待的 Goroutine 也都会接收到同样的错误；</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang-常量</title>
      <link href="/2022/10/27/golang/%E5%9F%BA%E7%A1%80/golang%E5%B8%B8%E9%87%8F/"/>
      <url>/2022/10/27/golang/%E5%9F%BA%E7%A1%80/golang%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>常量：常量标识恒定不变的值，区别于变量var。var-变量不赋值存在默认值，但是常量声明是必须显示赋值。<br>常量关键字：const<br>常量不能使用 “:&#x3D;(**在函数内部， 声明并初始化变量)**” 语法定义。</p><p><strong>定义单个常量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1000</span></span><br><span class="line"><span class="keyword">const</span> b <span class="type">float64</span> = <span class="number">1.0</span></span><br></pre></td></tr></table></figure><p><strong>批量定义常量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   statusOk = <span class="number">200</span></span><br><span class="line">   notFound = <span class="number">404</span></span><br><span class="line">   serverError = <span class="number">500</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p><strong>批量声明常量时，如果某一行没有写&#x3D;，那么就和上一行一致</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   n1 = <span class="number">100</span>      <span class="comment">//100</span></span><br><span class="line">   n2  <span class="comment">//100</span></span><br><span class="line">   n3  <span class="comment">//100</span></span><br><span class="line">   d, e = <span class="number">100</span>, <span class="number">200</span>  <span class="comment">//100 200</span></span><br><span class="line">   a, b         <span class="comment">//100 200</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><p>1.在const关键字出现时将被重置为0；<br>2.const中每增加<strong>一行</strong>常量声明，将使 iota 计数一次<br>3.iota作用于itoa使用前的最近的const，如果itoa后续后又出现const</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">a2</span><br><span class="line">a3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">b1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">b2</span><br><span class="line">b3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(a1)  <span class="comment">//0</span></span><br><span class="line">fmt.Println(a2)  <span class="comment">//1</span></span><br><span class="line">fmt.Println(a3)  <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">fmt.Println(b1)  <span class="comment">//0</span></span><br><span class="line">fmt.Println(b2) <span class="comment">//1</span></span><br><span class="line">fmt.Println(b3)  <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iota特殊用法"><a href="#iota特殊用法" class="headerlink" title="iota特殊用法"></a>iota特殊用法</h3><p>使用 ‘_’忽略某一生成的计数器值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a0 = <span class="number">100</span></span><br><span class="line">a1 = <span class="literal">iota</span> <span class="comment">//1</span></span><br><span class="line">a2        <span class="comment">//2</span></span><br><span class="line">_         <span class="comment">//3</span></span><br><span class="line">a3        <span class="comment">//4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>itoa插队(个人理解为覆盖掉itoa的计数值，计数器还在继续)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">a2        <span class="comment">//1</span></span><br><span class="line">a0 = <span class="number">100</span></span><br><span class="line">_         <span class="comment">//3</span></span><br><span class="line">a3        <span class="comment">//100</span></span><br><span class="line">a4 = <span class="literal">iota</span> <span class="comment">//5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>分析：a3的值为100,因为itoa计数在a0被赋值100后，后续常量的值以字面值常量100为准，但是itoa计数器还在计数，只是没有赋值给常量，需要显示的通过iota恢复</p><p>多常量并列定义<br>在同一个常量组里，可以再多个常量定义中使用iota，多个常量按照列单独计数。互不干涉。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">aa, a = <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">// aa = 0 b=0</span></span><br><span class="line">bb, _              <span class="comment">//bb = 0, _忽略当前计数 增加</span></span><br><span class="line">cc, c              <span class="comment">//计数增加</span></span><br><span class="line">dd, d = <span class="literal">iota</span>, <span class="number">100</span>  <span class="comment">//dd = 3, d 被重新赋值为100，继续计数</span></span><br><span class="line">ee, e              <span class="comment">// ee = 4, e = 100, 打断计数复制动作，但是并没有中短计数，</span></span><br><span class="line">ff, f = <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//ff = 5, f = 5 显式恢复计数赋值</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>const和itoa模拟枚举<br>go语言没有关键字enum，一般是通过一组常量（等差、等比-有规则）来模拟实现枚举类型，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Su = <span class="literal">iota</span></span><br><span class="line">Mo</span><br><span class="line">Tu</span><br><span class="line">We</span><br><span class="line">Th</span><br><span class="line">Fr</span><br><span class="line">Sa</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(Su, Mo, Tu, We, Th, Fr, Sa) <span class="comment">//0 1 2 3 4 5 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量和变量的区别"><a href="#常量和变量的区别" class="headerlink" title="常量和变量的区别"></a>常量和变量的区别</h2><p>常量是只读，声明赋值后无法修改，变量可以重复修改其内容值。常量通产会被编译器在预处理阶段直接展开，作为指令数据使用。<br>常量在运行时不分配存储地址，变量会分配地址</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-你不知道的切片</title>
      <link href="/2022/10/27/golang/%E5%9F%BA%E7%A1%80/go%E5%88%87%E7%89%87/"/>
      <url>/2022/10/27/golang/%E5%9F%BA%E7%A1%80/go%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h3 id="切片概念"><a href="#切片概念" class="headerlink" title="切片概念"></a>切片概念</h3><p>Slice又称动态数组，依托数组实现，可以方便的进行扩容、传递等，实际使用中比数组更灵活。<br>正因为灵活，如果不了解其内部实现机制，有可能遭遇莫名的异常现象。Slice的实现原理很简单，本节试图根据真实的使用场景，在源码中总结实现原理。</p><p>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。</p><p>数组和slice之间有着紧密的联系。一个slice是一个轻量级的数据结构，提供了访问数组子序列元素的功能，而且slice的底层确实引用一个数组对象。一个slice由三个部分构成：<strong>指针、长度和容量</strong>。指针指向第一个slice元素对应的底层数组元素的地址。<br>注意的是<strong>slice的第一个元素并不一定就是数组的第一个元素</strong>。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。<strong>内置的len和cap函数分别返回slice的长度和容量</strong>。</p><p>切片的底层源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切片的结构体由3部分构成，</span></span><br><span class="line"><span class="comment">//Pointer 是指向一个数组的指针，len代表当前切片的长度，cap是当前切片的容量。cap总是大于等于len的。</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line"><span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/55fab33aaf4a48e8a1b2a20ef46768db.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/97b02064da034f4d98464a4595abe023.png" alt="在这里插入图片描述"></p><h3 id="创建切片的方式"><a href="#创建切片的方式" class="headerlink" title="创建切片的方式"></a>创建切片的方式</h3><p><strong>1.声明空切片(nil)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明切片</span></span><br><span class="line"><span class="keyword">var</span> s1 []<span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> s1 == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;是空&quot;</span>)    <span class="comment">//是空</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;不是空&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))  <span class="comment">//[] 0 0</span></span><br></pre></td></tr></table></figure><p>** 2.make切片**</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s3 []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(s3, <span class="built_in">len</span>(s3), <span class="built_in">cap</span>(s3))  <span class="comment">//[0 0 0 0 0 0 0 0 0 0] 10 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s4 []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(s4, <span class="built_in">len</span>(s4), <span class="built_in">cap</span>(s4)) <span class="comment">//[] 0 10</span></span><br></pre></td></tr></table></figure><p><strong>3.从数组中切片</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s6 []<span class="type">int</span></span><br><span class="line"><span class="comment">// 前包后不包</span></span><br><span class="line">s6 = arr[<span class="number">1</span>:<span class="number">4</span>]  </span><br><span class="line">fmt.Println(s6, <span class="built_in">len</span>(s6), <span class="built_in">cap</span>(s6)) <span class="comment">//[2 3 4] 3 4</span></span><br><span class="line">s6 = arr[<span class="number">1</span>:<span class="number">4</span>:<span class="number">4</span>]  </span><br><span class="line">fmt.Println(s6, <span class="built_in">len</span>(s6), <span class="built_in">cap</span>(s6))<span class="comment">//[2 3 4] 3 3</span></span><br></pre></td></tr></table></figure><p>发现：通过 s6 &#x3D; arr[1:4]   操作后，我们发现s6的切片的len&#x3D;3,cap&#x3D;4。 s6的指针指向了s数组索引为2的数组位置，s6切片所指向的数据为{2,3,4} 这也是<strong>左闭右开</strong>原则，所以长度len&#x3D;3, 但因为指针指向s数组索引位置2，<strong>其当前切片的可用的容量是从当前指针位置往后数</strong>，即当前指针到最后有4个位置空间。即cap&#x3D;4。 说明了arr数组的len和cap并没有因此改变。</p><h3 id="切片的初始化操作"><a href="#切片的初始化操作" class="headerlink" title="切片的初始化操作"></a>切片的初始化操作</h3><table><thead><tr><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>s[n]</td><td>切片s中索引位置为n的项</td></tr><tr><td>s[:]</td><td>从切片s的索引位置0到len(s)-1处所获取的切片</td></tr><tr><td>s[low:]</td><td>从切片s的索引位置low到len(s)-1处所获取的切片</td></tr><tr><td>s[:high]</td><td>从切片s的索引位置0到high处所获取的切片 ，len&#x3D;high</td></tr><tr><td>s[low:high]</td><td>从切片s的索引位置low到high处所获取的切片,len&#x3D;high-low</td></tr><tr><td>s[low:high:max]</td><td>从切片s的索引位置low到high处所获取的切片,len&#x3D;high-low ,cap&#x3D;max-high</td></tr><tr><td>len(s)</td><td>切片s中长度总是&lt;&#x3D;cap(s)</td></tr><tr><td>cap(s)</td><td>切片s中容量总是&gt;&#x3D;len(s)</td></tr></tbody></table><h3 id="Slice-扩容"><a href="#Slice-扩容" class="headerlink" title="Slice 扩容"></a>Slice 扩容</h3><p>使用append向Slice追加元素时，如果Slice空间不足，将会触发Slice扩容，扩容实际上是重新分配一块更大的内存，将原Slice数据拷贝进新Slice，然后返回新Slice，扩容后再将数据追加进去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">newSlice := <span class="built_in">append</span>(slice, <span class="number">50</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Before slice = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, slice, &amp;slice, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">fmt.Printf(<span class="string">&quot;Before newSlice = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, newSlice, &amp;newSlice, <span class="built_in">len</span>(newSlice), <span class="built_in">cap</span>(newSlice))</span><br><span class="line">newSlice[<span class="number">1</span>] += <span class="number">10</span></span><br><span class="line">slice[<span class="number">3</span>] += <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;After slice = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, slice, &amp;slice, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">fmt.Printf(<span class="string">&quot;After newSlice = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, newSlice, &amp;newSlice, <span class="built_in">len</span>(newSlice), <span class="built_in">cap</span>(newSlice))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Before slice = [<span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span>], Pointer = <span class="number">0xc4200b0140</span>, <span class="built_in">len</span> = <span class="number">4</span>, <span class="built_in">cap</span> = <span class="number">4</span></span><br><span class="line">Before newSlice = [<span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span>], Pointer = <span class="number">0xc4200b0180</span>, <span class="built_in">len</span> = <span class="number">5</span>, <span class="built_in">cap</span> = <span class="number">8</span></span><br><span class="line">After slice = [<span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">50</span>], Pointer = <span class="number">0xc4200b0140</span>, <span class="built_in">len</span> = <span class="number">4</span>, <span class="built_in">cap</span> = <span class="number">4</span></span><br><span class="line">After newSlice = [<span class="number">10</span> <span class="number">30</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span>], Pointer = <span class="number">0xc4200b0180</span>, <span class="built_in">len</span> = <span class="number">5</span>, <span class="built_in">cap</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure><p>例如，当向一个capacity为4，且length也为4的Slice再次追加1个元素时，就会发生扩容，如下图所示：<br><img src="https://img-blog.csdnimg.cn/24db7391f5c0497bbba81219d312e262.png" alt="在这里插入图片描述"></p><p>扩容操作只关心容量，会把原Slice数据拷贝到新Slice，追加数据由append在扩容结束后完成。上图可见，扩容后新的Slice长度仍然是4，但容量由4提升到了8，原Slice的数据也都拷贝到了新Slice指向的数组中。扩容之前，新旧数组互不影响。<br>扩容容量的选择遵循以下规则：<br>如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍；<br>如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍；<br>使用append()向Slice添加一个元素的实现步骤如下：<br>假如Slice容量够用，则将新元素追加进去，Slice.len++，返回原Slice<br>原Slice容量不够，则将Slice先扩容，扩容后得到新Slice，将新元素追加进新Slice，Slice.len++，返回新的Slice。</p><p><strong>扩容之后的数组一定是新的么</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">array := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">slice2 := array[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">newSlice2 := <span class="built_in">append</span>(slice2, <span class="number">50</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Before slice2 = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, slice2, &amp;slice2, <span class="built_in">len</span>(slice2), <span class="built_in">cap</span>(slice2))</span><br><span class="line">fmt.Printf(<span class="string">&quot;Before newSlice2 = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, newSlice2, &amp;newSlice2, <span class="built_in">len</span>(newSlice2), <span class="built_in">cap</span>(newSlice2))</span><br><span class="line">newSlice2[<span class="number">1</span>] += <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;After slice2 = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, slice2, &amp;slice2, <span class="built_in">len</span>(slice2), <span class="built_in">cap</span>(slice2))</span><br><span class="line">fmt.Printf(<span class="string">&quot;After newSlice2 = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, newSlice2, &amp;newSlice2, <span class="built_in">len</span>(newSlice2), <span class="built_in">cap</span>(newSlice2))</span><br><span class="line">fmt.Printf(<span class="string">&quot;After array = %v\n&quot;</span>, array)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Before slice2 = [10 20], Pointer = 0xc000004108, len = 2, cap = 4</span></span><br><span class="line"><span class="comment">//Before newSlice2 = [10 20 50], Pointer = 0xc000004120, len = 3, cap = 4</span></span><br><span class="line"><span class="comment">//After slice2 = [10 30], Pointer = 0xc000004108, len = 2, cap = 4</span></span><br><span class="line"><span class="comment">//After newSlice2 = [10 30 50], Pointer = 0xc000004120, len = 3, cap = 4</span></span><br><span class="line"><span class="comment">//After array = [10 30 50 40]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/47c587d021e04c659cee9b6a5d6db731.png" alt="在这里插入图片描述"></p><p>在这种情况下，扩容以后并没有新建一个新的数组，<strong>扩容前后的数组都是同一个</strong>，<strong>这也就导致了新的切片修改了一个值</strong>，也影响到了老的切片了。并且 append() 操作也改变了原来数组里面的值。一个 append() 操作影响了这么多地方，如果原数组上有多个切片，那么这些切片都会被影响！无意间就产生了莫名的 bug！这种情况，由于原数组还有容量可以扩容，所以执行 append() 操作以后，会在原数组上直接操作，所以这种情况下，扩容以后的数组还是指向原来的数组。</p><h3 id="切片拷贝"><a href="#切片拷贝" class="headerlink" title="切片拷贝"></a>切片拷贝</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//copy 函数将数据从源 Slice复制到目标 Slice。它返回复制的元素数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copy</span>（<span class="title">dst</span>，<span class="title">src</span> [] <span class="title">T</span>）<span class="title">int</span></span></span><br></pre></td></tr></table></figure><p>copy 函数支持在不同长度的 Slice 之间进行复制，若出现长度不一致，在复制时会按照最少的 Slice 元素个数进行复制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dst := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">src := []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Before dst = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, dst, &amp;dst, <span class="built_in">len</span>(dst), <span class="built_in">cap</span>(dst))</span><br><span class="line">fmt.Printf(<span class="string">&quot;Before src = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, src, &amp;src, <span class="built_in">len</span>(src), <span class="built_in">cap</span>(src))</span><br><span class="line">n := <span class="built_in">copy</span>(dst, src)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n = %d After dst = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, n, dst, &amp;dst, <span class="built_in">len</span>(dst), <span class="built_in">cap</span>(dst))</span><br><span class="line">fmt.Printf(<span class="string">&quot;n = %d After src = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, n, src, &amp;src, <span class="built_in">len</span>(src), <span class="built_in">cap</span>(src))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Before dst = [1 2 3], Pointer = 0xc000004078, len = 3, cap = 3</span></span><br><span class="line"><span class="comment">//Before src = [4 5 6 7 8], Pointer = 0xc000004090, len = 5, cap = 5</span></span><br><span class="line"><span class="comment">//n = 3 After dst = [4 5 6], Pointer = 0xc000004078, len = 3, cap = 3</span></span><br><span class="line"><span class="comment">//n = 3 After src = [4 5 6 7 8], Pointer = 0xc000004090, len = 5, cap = 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(to, fm slice, width <span class="type">uintptr</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 如果源切片或者目标切片有一个长度为0，那么就不需要拷贝，直接 return </span></span><br><span class="line">    <span class="keyword">if</span> fm.<span class="built_in">len</span> == <span class="number">0</span> || to.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// n 记录下源切片或者目标切片较短的那一个的长度</span></span><br><span class="line">    n := fm.<span class="built_in">len</span></span><br><span class="line">    <span class="keyword">if</span> to.<span class="built_in">len</span> &lt; n &#123;</span><br><span class="line">        n = to.<span class="built_in">len</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果入参 width = 0，也不需要拷贝了，返回较短的切片的长度</span></span><br><span class="line">    <span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    size := <span class="type">uintptr</span>(n) * width</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">1</span> &#123;</span><br><span class="line">   <span class="comment">// 如果只有一个元素，那么指针直接转换即可</span></span><br><span class="line">        *(*<span class="type">byte</span>)(to.array) = *(*<span class="type">byte</span>)(fm.array) </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 如果不止一个元素，那么就把 size 个 bytes 从 fm.array 地址开始，拷贝到 to.array 地址之后</span></span><br><span class="line">        memmove(to.array, fm.array, size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>若源 Slice 或目标 Slice 存在长度为 0 的情况，则直接返回 0（因为压根不需要执行复制行为）</li><li>通过对比两个 Slice，获取最小的 Slice 长度。便于后续操作</li><li>若 Slice 只有一个元素，则直接利用指针的特性进行转换</li><li>若 Slice 大于一个元素，则从 fm.array 复制 size 个字节到 to.array 的地址处（会覆盖原有的值）</li><li>还有一个拷贝的方法，这个方法原理和 slicecopy 方法类似，不在赘述了，注释写在代码里面了。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicestringcopy</span><span class="params">(to []<span class="type">byte</span>, fm <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 如果源切片或者目标切片有一个长度为0，那么就不需要拷贝，直接 return </span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(fm) == <span class="number">0</span> || <span class="built_in">len</span>(to) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n 记录下源切片或者目标切片较短的那一个的长度</span></span><br><span class="line">    n := <span class="built_in">len</span>(fm)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(to) &lt; n &#123;</span><br><span class="line">        n = <span class="built_in">len</span>(to)</span><br><span class="line">    &#125;</span><br><span class="line">   .....</span><br><span class="line">    <span class="comment">// 拷贝字符串至字节数组</span></span><br><span class="line">    memmove(unsafe.Pointer(&amp;to[<span class="number">0</span>]), stringStructOf(&amp;fm).str, <span class="type">uintptr</span>(n))</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Before dst = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, slice, &amp;slice, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">n := <span class="built_in">copy</span>(slice, <span class="string">&quot;abcdef&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;n = %d After src = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, n, slice, &amp;slice, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Before dst = [0 0 0], Pointer = 0xc000004078, len = 3, cap = 3</span></span><br><span class="line"><span class="comment">// n = 3 After src = [97 98 99], Pointer = 0xc000004078, len = 3, cap = 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="遍历切片"><a href="#遍历切片" class="headerlink" title="遍历切片"></a>遍历切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">b := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;  b = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, b, &amp;b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> b &#123;</span><br><span class="line">b[i] -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;  b = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, b, &amp;b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line"></span><br><span class="line">a := [...]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, prime := <span class="keyword">range</span> a &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;value = %d , value-addr = %x , slice-addr = %x\n&quot;</span>, prime, &amp;prime, &amp;a[i])</span><br><span class="line">prime -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;  a = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, a, &amp;a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> a &#123;</span><br><span class="line">a[i] -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;  a = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, a, &amp;a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b = [2 3 5 7 11], Pointer = 0xc00000a3c0, len = 5, cap = 5</span></span><br><span class="line"><span class="comment">//  b = [1 2 4 6 10], Pointer = 0xc00000a3c0, len = 5, cap = 5</span></span><br><span class="line"><span class="comment">//value = 2 , value-addr = c0000120d0 , slice-addr = c00000a450</span></span><br><span class="line"><span class="comment">//value = 3 , value-addr = c0000120d0 , slice-addr = c00000a458</span></span><br><span class="line"><span class="comment">//value = 5 , value-addr = c0000120d0 , slice-addr = c00000a460</span></span><br><span class="line"><span class="comment">//value = 7 , value-addr = c0000120d0 , slice-addr = c00000a468</span></span><br><span class="line"><span class="comment">//value = 11 , value-addr = c0000120d0 , slice-addr = c00000a470</span></span><br><span class="line"><span class="comment">//  a = [2 3 5 7 11], Pointer = 0xc00000a450, len = 5, cap = 5</span></span><br><span class="line"><span class="comment">//  a = [1 2 4 6 10], Pointer = 0xc00000a450, len = 5, cap = 5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d690a3a73b8c448cbc0df3840bc3c48a.png" alt="在这里插入图片描述"></p><p>从上面结果我们可以看到，如果用 range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝。所以每次打印 Value 的地址都不变。由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的，需要通过 &amp;a[i] 获取真实的地址。</p><ul><li>被遍历的容器值是aContainer的一个副本。 注意，只有aContainer的直接部分被复制了。 此副本是一个匿名的值，所以它是不可被修改的。</li><li>如果aContainer是一个<strong>数组</strong>，那么在遍历过程中对此数组元素的修改不会体现到循环变量中。 原因是此数组的副本（被真正遍历的容器）和此数组不共享任何元素。</li><li>如果aContainer是一个<strong>切片</strong>（或者映射），那么在遍历过程中对此切片（元素的修改将体现到循环变量中。 原因是此切片的副本和此切片（或者映射）共享元素。在遍历中的每个循环步，aContainer副本中的一个键值元素对将被赋值给循环变量。 所以对循环变量的直接修改将不会体现在aContainer中的对应元素中。 （因为这个原因，并且for-range循环是遍历映射条目的唯一途径，所以最好不要使用大尺寸的映射键值和元素类型，以避免较大的复制负担。）</li><li>所有被遍历的键值对将被赋值给同一对循环变量实例。</li></ul><p>遍历一个nil映射或者nil切片是允许的。这样的遍历可以看作是一个空操作。<br>一些关于遍历映射条目的细节：</p><ul><li>映射中的条目的遍历顺序是不确定的。或者说，同一个映射中的条目的两次遍历中，条目的顺序很可能是不一致的，即使在这两次遍历之间，此映射并未发生任何改变。</li><li>如果在一个映射中的条目的遍历过程中，一个还没有被遍历到的条目被删除了，则此条目保证不会被遍历出来。</li><li>如果在一个映射中的条目的遍历过程中，一个新的条目被添加入此映射，则此条目并不保证将在此遍历过程中被遍历出来。</li></ul><p><strong>把数组指针当做数组来使用</strong><br>对于某些情形，我们可以把数组指针当做数组来使用。<br>我们可以通过在range关键字后跟随一个数组的指针来遍历此数组中的元素。<br>对于大尺寸的数组，这种方法比较高效，因为复制一个指针比复制一个大尺寸数组的代价低得多。<br>下面的例子中的两个循环是等价的，它们的效率也基本相同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">100</span>]<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i, n := <span class="keyword">range</span> &amp;a &#123; <span class="comment">// 复制一个指针的开销很小</span></span><br><span class="line">        fmt.Println(i, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, n := <span class="keyword">range</span> a[:] &#123; <span class="comment">// 复制一个切片的开销很小</span></span><br><span class="line">        fmt.Println(i, n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-slice-遇到的”坑”"><a href="#使用-slice-遇到的”坑”" class="headerlink" title="使用 slice 遇到的”坑”"></a>使用 slice 遇到的”坑”</h3><p>使用 slice 时，如果不清楚 slice 的底层原理，还是会遇到一些意想不到的问题，而有些问题有时会很隐蔽，这里总结下，避免踩坑。</p><p><strong>slice 初始化的”坑”</strong><br>初始化一个 slice 有两种方式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接声明: 比如 <span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">使用 <span class="built_in">make</span> 关键字，比如: s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这两种方式有什么区别呢？在日常 coding 中应该如何选择，这是一个容易被忽视的问题。<br>首先，先说下区别：<br><strong>直接声明 slice 的方式内部是不申请内存空间的，slice 内部 array 指针指向nil。<br>使用 make 关键字会申请包含 0 个元素的内存空间，底层 array 指针指向申请的内存。</strong><br><img src="https://img-blog.csdnimg.cn/13454bb327464b2a85ba2a27ef03eebe.png" alt="在这里插入图片描述"><br>清楚两者的区别后，再说下遇到的”坑”。有次在开发服务接口声明 slice 之后，然后通过 json.Marshal 序列化 slice，但是序列化的结果是有区别的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">json.Marshal(直接声明): 返回 null</span><br><span class="line">json.Marshal(<span class="built_in">make</span>关键字初始化): 返回 []</span><br></pre></td></tr></table></figure><p><strong>slice 扩容的”坑”</strong></p><p>这个坑在面试中经常会遇到，当 slice 作为函数参数时，如果在函数内部发生了扩容，这时再修改 slice 中的值是不起作用的，因为修改发生在新的 array 内存中，对老的 array 内存不起作用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">modifySlice(s)</span><br><span class="line">fmt.Println(s) <span class="comment">// 打印 [1 2 3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>)</span><br><span class="line">s[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>创建切片时可根据实际需要预分配容量，尽量避免追加过程中扩容操作，有利于提升性能<br>切片拷贝时需要判断实际拷贝的元素个数<br>谨慎使用多个切片操作同一个数组，以防读写冲突<br>每个切片都指向一个底层数组<br>每个切片都保存了当前切片的长度、底层数组可用容量<br>使用len()、cap()计算切片长度、容量时，时间复杂度均为O(1)，不需要遍历切片<br>通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而矣<br>使用 append() 向切片追加元素时有可能触发扩容，扩容后将会生成新的切片</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 切片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang-数据类型</title>
      <link href="/2022/10/27/golang/%E5%9F%BA%E7%A1%80/golang-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/10/27/golang/%E5%9F%BA%E7%A1%80/golang-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>每一门语言都有自己的数据结构，Go 语言也不例外，总共有两大类，值类型（基础类型、聚合类型）、引用类型。本文简单介绍一下这些类型。<br><img src="https://img-blog.csdnimg.cn/b9089782b51645598d522106a4cfdf54.png" alt="在这里插入图片描述"><br><strong>聚合类型</strong><br>聚合类型的值由内存中的一组变量构成。数组和结构体都是聚合类型，数组和结构体的长度都是固定的。数组中的的元素类型必须都相同，而结构体中的元素可以不同。<br><strong>引用类型</strong><br>引用是另外一种数据类型，引用都间接指向变量或者状态，通过引用来操作数据会让该数据的全部引用都受影响。</p><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>值类型：变量直接存储值，<strong>内存通常在栈上分配</strong>，栈在函数调用完会被释放。<br>引用类型： 变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配，通过GC回收。</p><p>在 Go 语言中，<strong>函数的参数传递只有值传递</strong>，而且传递的实参都是原始数据的一份拷贝。如果拷贝的内容是值类型的，那么在函数中就无法修改原始数据；如果拷贝的内容是指针（或者可以理解为引用类型 map、chan 等），那么就可以在函数中修改原始数据。</p><h2 id="类型比较"><a href="#类型比较" class="headerlink" title="类型比较"></a>类型比较</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>比较的两个变量类型必须相等。而且，golang没有隐式类型转换，比较的两个变量必须类型完全一样，类型定义也不行。如果要比较，先做类型转换再比较。</p><ul><li>类型完全不一样的，不能比较</li><li>类型再定义关系，不能比较，可以强转比较</li><li>类型别名关系，可以比较</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b A = <span class="number">1</span></span><br><span class="line"><span class="comment">//fmt.Println(a == b)      //invalid operation: a == b (mismatched types int and A)</span></span><br><span class="line">fmt.Println(a == <span class="type">int</span>(b)) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C = <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> c C = <span class="number">1</span></span><br><span class="line">fmt.Println(a == c) <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复合类型的变量比较"><a href="#复合类型的变量比较" class="headerlink" title="复合类型的变量比较"></a>复合类型的变量比较</h3><p>复合类型是逐个字段，逐个元素比较的。需要注意的是，array 或者struct中每个元素必须要是可比较的，如果某个array的元素 or struct的成员不能比较(比如是后面介绍的slice，map等)，则此复合类型也不能比较。</p><p><strong>数组类型变量比较</strong><br>数组的长度是类型的一部分，如果数组长度不同，无法比较<br>逐个元素比较类型和值。每个对应元素的比较遵循基本类型变量的比较规则。跟struct一样，如果item是不可比较的类型，则array也不能做比较。<br><strong>struct类型变量比较</strong><br>逐个成员比较类型和值。每个对应成员的比较遵循基本类型变量的比较规则。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := Student&#123;<span class="string">&quot;minping&quot;</span>, <span class="number">30</span>&#125;</span><br><span class="line">b := Student&#123;<span class="string">&quot;minping&quot;</span>, <span class="number">30</span>&#125;</span><br><span class="line">fmt.Println(a == b)   <span class="comment">//true</span></span><br><span class="line">fmt.Println(&amp;a == &amp;b) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student2 <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">Info []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a2 := Student2&#123;</span><br><span class="line">Name: <span class="string">&quot;minping&quot;</span>,</span><br><span class="line">Age:  <span class="number">30</span>,</span><br><span class="line">&#125;</span><br><span class="line">b2 := Student2&#123;</span><br><span class="line">Name: <span class="string">&quot;minping&quot;</span>,</span><br><span class="line">Age:  <span class="number">30</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a2 == b2) <span class="comment">//invalid operation: a == b (struct containing []string cannot be compared)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，struct中有slice这种不可比较的成员时，整个struct都不能做比较，即使没有对slice那个成员赋值(slice默认值为nil)</p><h3 id="引用类型的变量比较"><a href="#引用类型的变量比较" class="headerlink" title="引用类型的变量比较"></a>引用类型的变量比较</h3><p><strong>普通的变量引用类型&amp;val和channel的比较规则</strong></p><p>引用类型变量存储的是某个变量的内存地址。所以引用类型变量的比较，判断的是这两个引用类型存储的是不是同一个变量。</p><ul><li>如果是同一个变量，则内存地址肯定也一样，则引用类型变量相等，用”&#x3D;&#x3D;“结果为true。</li><li>如果不是同一个变量，则内存地址肯定不一样，”&#x3D;&#x3D;”结果为false。</li></ul><p><strong>slice，map这种引用类型的比较</strong><br>map类型和slice一样，不能比较，只能与nil做比较。</p><p><strong>interface{}类型变量的比较</strong><br>接口类型的变量，包含该接口变量存储的值和值的类型两部分组成，分别称为<strong>接口的动态类型和动态值</strong>。<strong>只有动态类型和动态值都相同时，两个接口变量才相同:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">    getName() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Teacher)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(s, t Person)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s == t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    s1 := Student&#123;<span class="string">&quot;minping&quot;</span>&#125;</span><br><span class="line">    s2 := Student&#123;<span class="string">&quot;minping&quot;</span>&#125;</span><br><span class="line">    t := Teacher&#123;<span class="string">&quot;minping&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(compare(s1, s2)) <span class="comment">//true</span></span><br><span class="line">    fmt.Println(compare(s1, t))  <span class="comment">//false,类型不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且接口的动态类型必须要是可比较的，如果不能比较(比如slice，map)，则运行时会报panic。因为编译器在编译时无法获取接口的动态类型，所以编译能通过，但是运行时直接panic:</p><p><strong>函数类型的比较</strong><br>golang的func作为一等公民，也是一种类型，而且不可比较。</p><h3 id="slice和map的特殊比较"><a href="#slice和map的特殊比较" class="headerlink" title="slice和map的特殊比较"></a>slice和map的特殊比较</h3><p><strong>[]byte类型的变量，使用工具包byte提供的函数就可以做比较</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="type">byte</span>&#123;<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line">s2 := []<span class="type">byte</span>&#123;<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line">fmt.Println(bytes.Equal(s1, s2)) <span class="comment">// true</span></span><br><span class="line">s2 = []<span class="type">byte</span>&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;</span><br><span class="line">fmt.Println(bytes.Equal(s1, s2)) <span class="comment">// false</span></span><br><span class="line">s2 = []<span class="type">byte</span>&#123;<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>&#125;</span><br><span class="line">fmt.Println(bytes.EqualFold(s1, s2)) <span class="comment">// true</span></span><br><span class="line">s1 = []<span class="type">byte</span>(<span class="string">&quot;źdźbło&quot;</span>)</span><br><span class="line">s2 = []<span class="type">byte</span>(<span class="string">&quot;źdŹbŁO&quot;</span>)</span><br><span class="line">fmt.Println(bytes.EqualFold(s1, s2)) <span class="comment">// true</span></span><br><span class="line">s1 = []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">s2 = <span class="literal">nil</span></span><br><span class="line">fmt.Println(bytes.Equal(s1, s2)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>使用反射</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">m1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;foo&quot;</span>: <span class="number">1</span>, <span class="string">&quot;bar&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;foo&quot;</span>: <span class="number">1</span>, <span class="string">&quot;bar&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">// fmt.Println(m1 == m2) // map can only be compared to nil</span></span><br><span class="line">fmt.Println(reflect.DeepEqual(m1, m2)) <span class="comment">// true</span></span><br><span class="line">m2 = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;foo&quot;</span>: <span class="number">1</span>, <span class="string">&quot;bar&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(reflect.DeepEqual(m1, m2)) <span class="comment">// false</span></span><br><span class="line">m3 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;foo&quot;</span>: [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;&#125;</span><br><span class="line">m4 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;foo&quot;</span>: [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;&#125;</span><br><span class="line">fmt.Println(reflect.DeepEqual(m3, m4)) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> m5 <span class="keyword">map</span>[<span class="type">float64</span>]<span class="type">string</span></span><br><span class="line">fmt.Println(reflect.DeepEqual(m5, <span class="literal">nil</span>)) <span class="comment">// false</span></span><br><span class="line">fmt.Println(m5 == <span class="literal">nil</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1，复合类型，只有每个元素(成员)可比较，而且类型和值都相等时，两个复合元素才相等<br>2，slice，map不可比较，但是可以用reflect或者cmp包来比较<br>3，func作为golnag的一等公民，也是一个类型，也不能比较。<br>4，引用类型的比较是看指向的是不是同一个变量<br>5，类型再定义(type A string)不可比较，是两种不同的类型<br>6，类型别名(type A &#x3D; string)可比较，是同一种类型。</p><h2 id="拓展-类型别名与类型定义"><a href="#拓展-类型别名与类型定义" class="headerlink" title="拓展-类型别名与类型定义"></a>拓展-类型别名与类型定义</h2><p><strong>类型别名</strong><br>类型别名需要在别名和原类型之间加上赋值符号 &#x3D; ，使用<strong>类型别名定义的类型与原类型等价</strong>，Go 语言内建的基本类型中就存在两个别名类型。</p><ul><li>byte 是 uint8 的别名类型；</li><li>rune 是 int32 的别名类型；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString = <span class="type">string</span></span><br></pre></td></tr></table></figure><p>定义 string 类型的别名，示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> MyString = <span class="type">string</span></span><br><span class="line">str := <span class="string">&quot;hello&quot;</span></span><br><span class="line">a := MyString(str)</span><br><span class="line">b := MyString(<span class="string">&quot;A&quot;</span> + str)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str type is %T\n&quot;</span>, str)  <span class="comment">//str type is string</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a type is %T\n&quot;</span>, a)    <span class="comment">//a type is string</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a == str is %t\n&quot;</span>, a == str)  <span class="comment">//a == str is true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;b &gt; a is %t\n&quot;</span>, b &gt; a)  <span class="comment">//b &gt; a is false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别名类型与源类型是完全相同的；<br>别名类型与源类型可以在源类型支持的条件下进行相等判断、比较判断、与 nil 是否相等判断一致；</p><p><strong>类型定义</strong><br>类型定义是定义一种新的类型，它与源类型是不一样的。看下面代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">unc main() &#123;</span><br><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span></span><br><span class="line">str := <span class="string">&quot;hello&quot;</span></span><br><span class="line">a := MyString(str)</span><br><span class="line">b := MyString(<span class="string">&quot;A&quot;</span> + str)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str type is %T\n&quot;</span>, str)  <span class="comment">//str type is string</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a type is %T\n&quot;</span>, a)    <span class="comment">//a type is main.MyString</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a value is %#v\n&quot;</span>, a)  <span class="comment">//a value is &quot;hello&quot; </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;b value is %#v\n&quot;</span>, b)  <span class="comment">//b value is &quot;Ahello&quot;</span></span><br><span class="line"><span class="comment">// fmt.Printf(&quot;a == str is %t\n&quot;, a == str)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;b &gt; a is %t\n&quot;</span>, b &gt; a)   <span class="comment">//b &gt; a is false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到 MyString 类型为 main.MyString 而原有的 str 类型为 string，两者是不同的类型，如果使用下面的判断相等语句</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;a == str is %t\n&quot;</span>, a == str)</span><br></pre></td></tr></table></figure><p>会有编译错误提示</p><p><img src="https://img-blog.csdnimg.cn/0ab7a6d00c5d4635976b1fa122c46d00.png" alt="在这里插入图片描述"><br>对于这里的类型再定义来说，string 可以被称为 MyString2 的潜在类型。潜在类型的含义是，某个类型在本质上是哪个类型。潜在类型相同的不同类型的值之间是可以进行类型转换的。</p><p>因此，MyString2 类型的值与 string 类型的值可以使用类型转换表达式进行互转。但对于集合类的类型[]MyString2 与 []string 来说这样做却是不合法的，因为 []MyString2 与 []string 的潜在类型不同，分别是 []MyString2 和 []string 。<br><strong>另外，即使两个不同类型的潜在类型相同，它们的值之间也不能进行判等或比较，它们的变量之间也不能赋值。</strong></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始go接口</title>
      <link href="/2022/10/27/golang/%E5%9F%BA%E7%A1%80/%E5%88%9D%E5%A7%8Bgo%E6%8E%A5%E5%8F%A3/"/>
      <url>/2022/10/27/golang/%E5%9F%BA%E7%A1%80/%E5%88%9D%E5%A7%8Bgo%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一-其他语言"><a href="#一-其他语言" class="headerlink" title="一.其他语言"></a>一.其他语言</h2><p>其他语言中所提供的接口概念：接口主要作为不同组件之间的契约存在。对契约的实现是强制的（侵入式接口），你必须声明你的确实现了该接口。为了实现一个接口，你需要从该接口继承。</p><blockquote><p>interface IFoo {<br>void Bar();<br>}<br>&#x2F;&#x2F; Java文法 &#x2F;&#x2F; …<br>class Foo implements IFoo {<br>}<br>&#x2F;&#x2F; C++文法 &#x2F;&#x2F; …<br>class Foo : public IFoo {<br>}    </p></blockquote><p>“侵入式”的主要表现在于实现类需要明确声明自己实现了 某个接口。</p><h2 id="二-go语言"><a href="#二-go语言" class="headerlink" title="二.go语言"></a>二.go语言</h2><p>go语言中接口与其他语言的接口也略有不同，是一种非侵入式接口，实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才 合理。接口由使用方按需定义，而不用事前规划。一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">   call()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Nokia <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口的实现是隐式的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phone Nokia)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;我是 Nokia，是一台电话&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三.go接口实现多态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="keyword">type</span> Good <span class="keyword">interface</span> &#123;</span><br><span class="line">    settleAccount() <span class="type">int</span></span><br><span class="line">    orderInfo() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    quantity <span class="type">int</span></span><br><span class="line">    price <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phone Phone)</span></span> settleAccount() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> phone.quantity * phone.price</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phone Phone)</span></span> orderInfo() <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;您要购买&quot;</span> + strconv.Itoa(phone.quantity)+ <span class="string">&quot;个&quot;</span> +</span><br><span class="line">        phone.name + <span class="string">&quot;计：&quot;</span> + strconv.Itoa(phone.settleAccount()) + <span class="string">&quot;元&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FreeGift <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    quantity <span class="type">int</span></span><br><span class="line">    price <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gift FreeGift)</span></span> settleAccount() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gift FreeGift)</span></span> orderInfo() <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;您要购买&quot;</span> + strconv.Itoa(gift.quantity)+ <span class="string">&quot;个&quot;</span> +</span><br><span class="line">        gift.name + <span class="string">&quot;计：&quot;</span> + strconv.Itoa(gift.settleAccount()) + <span class="string">&quot;元&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateAllPrice</span><span class="params">(goods []Good)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> allPrice <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _,good := <span class="keyword">range</span> goods&#123;</span><br><span class="line">        fmt.Println(good.orderInfo())</span><br><span class="line">        allPrice += good.settleAccount()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allPrice</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    iPhone := Phone&#123;</span><br><span class="line">        name:     <span class="string">&quot;iPhone&quot;</span>,</span><br><span class="line">        quantity: <span class="number">1</span>,</span><br><span class="line">        price:    <span class="number">8000</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    earphones := FreeGift&#123;</span><br><span class="line">        name:     <span class="string">&quot;耳机&quot;</span>,</span><br><span class="line">        quantity: <span class="number">1</span>,</span><br><span class="line">        price:    <span class="number">200</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    goods := []Good&#123;iPhone, earphones&#125;</span><br><span class="line">    allPrice := calculateAllPrice(goods)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;该订单总共需要支付 %d 元&quot;</span>, allPrice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-空接口的使用（重点）"><a href="#四-空接口的使用（重点）" class="headerlink" title="四.空接口的使用（重点）"></a>四.空接口的使用（重点）</h2><h3 id="4-1：定义"><a href="#4-1：定义" class="headerlink" title="4.1：定义"></a>4.1：定义</h3><p>空接口没有定义任何方法口，也因此，我们可以说所有类型都至少实现了空接口。<br>每一个接口都包含两个属性，一个是值，一个是类型。<br>而对于空接口来说，这两者都是 nil，可以使用 fmt 来验证一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type: %T, value: %v&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//type: &lt;nil&gt;, value: &lt;nil&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-2空接口使用"><a href="#4-2空接口使用" class="headerlink" title="4.2空接口使用"></a>4.2空接口使用</h3><p>第一，通常我们会直接使用 interface{} 作为类型声明一个实例，而这个实例可以承载任意类型的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个空接口实例</span></span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存 int 没有问题</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    fmt.Println(i)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存字符串也没有问题</span></span><br><span class="line">    i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    fmt.Println(i)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存布尔值也没有问题</span></span><br><span class="line">    i = <span class="literal">false</span></span><br><span class="line">    fmt.Println(i)</span><br></pre></td></tr></table></figure><p>第二，如果想让你的函数可以接收任意类型的值 ，也可以使用空接口;<br>第三，你也定义一个可以接收任意类型的 array、slice、map、strcut，例如这边定义一个切片;</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    any := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">5</span>)</span><br><span class="line">    any[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line">    any[<span class="number">1</span>] = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">    any[<span class="number">2</span>] = []<span class="type">int</span>&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> any &#123;</span><br><span class="line">        fmt.Println(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3空接口几个要注意的坑（我刚学时的错误）"><a href="#4-3空接口几个要注意的坑（我刚学时的错误）" class="headerlink" title="4.3空接口几个要注意的坑（我刚学时的错误）"></a>4.3空接口几个要注意的坑（我刚学时的错误）</h3><p>坑1：空接口可以承载任意值，但不代表任意类型就可以承接空接口类型的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明a变量, 类型int, 初始值为1</span></span><br><span class="line">  <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明i变量, 类型为interface&#123;&#125;, 初始值为a, 此时i的值变为1</span></span><br><span class="line">  <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = a</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明b变量, 尝试赋值i  报错</span></span><br><span class="line">  <span class="keyword">var</span> b <span class="type">int</span> = i</span><br></pre></td></tr></table></figure><p>坑2：：当空接口承载数组和切片后，该对象无法再进行切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sli := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   i = sli</span><br><span class="line">    <span class="comment">//报错</span></span><br><span class="line">   g := i[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">   fmt.Println(g)</span><br></pre></td></tr></table></figure><p>坑3：当你使用空接口来接收任意类型的参数时，它的静态类型是 interface{}，但动态类型（是 int，string 还是其他类型）我们并不知道，因此需要使用类型断言。</p><p>这里还有一点要说明   空接口调用函数时的隐式转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;参数的类型是 int&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;参数的类型是 string&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    b := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    myfunc(a)</span><br><span class="line">    myfunc(b)</span><br><span class="line">如果写在外面  则报错</span><br><span class="line"><span class="comment">/*switch a.(type) &#123;</span></span><br><span class="line"><span class="comment">    case int:</span></span><br><span class="line"><span class="comment">        fmt.Println(&quot;参数的类型是 int&quot;)</span></span><br><span class="line"><span class="comment">    case string:</span></span><br><span class="line"><span class="comment">        fmt.Println(&quot;参数的类型是 string&quot;)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1和3是最容易犯问题，唉。。。。。。。。。。。。。</p><p>如果写的有错误，可以告诉我，嘿嘿。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高频问题-逃逸分析</title>
      <link href="/2022/10/27/golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
      <url>/2022/10/27/golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写过C&#x2F;C++的同学都知道，调用著名的malloc和new函数可以在堆上分配一块内存，这块内存的使用和销毁的责任都在程序员。一不小心，就会发生内存泄露。<br>切换到Golang后，基本不会担心内存泄露了。虽然也有new函数，但是使用new函数得到的内存不一定就在堆上。一个变量是在堆上分配，还是在栈上分配，是经过编译器的逃逸分析之后得出的结论。<br><code>Go语言逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸。</code></p><h2 id="什么是逃逸分析"><a href="#什么是逃逸分析" class="headerlink" title="什么是逃逸分析"></a>什么是逃逸分析</h2><p>在编译原理中，分析指针动态范围的方法称之为<code>逃逸分析</code>。通俗来讲，当一个对象的<code>指针</code>被<code>多个方法</code>或<code>线程</code>引用时，我们称这个指针发生了逃逸。更简单来说，逃逸分析决定一个变量是分配在堆上还是分配在栈上。<br>所谓逃逸分析（Escape analysis）是指由编译器决定内存分配的位置，不需要程序员指定。函数中申请一个新的对象</p><blockquote><p>如果分配在栈中，则函数执行结束可自动将内存回收；<br> 如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理；</p></blockquote><h2 id="为什么要逃逸分析"><a href="#为什么要逃逸分析" class="headerlink" title="为什么要逃逸分析"></a>为什么要逃逸分析</h2><p>逃逸分析把变量合理地分配到它该去的地方。即使你是用new申请到的内存，如果我发现你竟然在退出函数后没有用了，那么就把你丢到栈上，毕竟栈上的内存分配比堆上快很多；反之，即使你表面上只是一个普通的变量，但是经过逃逸分析后发现在退出函数之后还有其他地方在引用，那我就把你分配到堆上。<br><strong>如果变量都分配到堆上，堆不像栈可以自动清理。它会引起Go频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销。</strong><br>堆和栈相比，堆适合<strong>不可预知大小的内存分配</strong>。但是为此付出的代价是分配速度较慢，而且会形成<strong>内存碎片</strong>。栈内存分配则会非常快。栈分配内存只需要两个CPU指令：“PUSH”和“RELEASSE”，分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。<br><strong>通过逃逸分析，可以尽量把那些不需要分配到堆上的变量直接分配到栈上，堆上的变量少了，会减轻分配堆内存的开销，同时也会减少gc的压力，提高程序的运行速度。</strong></p><h2 id="逃逸分析是怎么完成的"><a href="#逃逸分析是怎么完成的" class="headerlink" title="逃逸分析是怎么完成的"></a>逃逸分析是怎么完成的</h2><p><strong>Go逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸。</strong><br><code>Go中的变量只有在编译器可以证明在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上。 Go语言里没有一个关键字或者函数可以直接让变量被编译器分配到堆上，相反，编译器通过分析代码来决定将变量分配到何处。 对一个变量取地址，可能会被分配到堆上。但是编译器进行逃逸分析后，如果考察到在函数返回后，此变量不会被引用，那么还是会被分配到栈上。</code></p><p>简单来说，编译器会根据变量是否被外部引用来决定是否逃逸：</p><blockquote><p>如果函数外部没有引用，则优先放到栈中；<br>如果函数外部存在引用，则必定放到堆中；</p></blockquote><h2 id="Golang的逃逸分析情况"><a href="#Golang的逃逸分析情况" class="headerlink" title="Golang的逃逸分析情况"></a>Golang的逃逸分析情况</h2><p>查看逃逸分析指令：<code>go build -gcflags=-m  文件名</code>。<br>逃逸分析通常有四种情况:</p><ul><li>指针逃逸</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StudentRegister</span><span class="params">(name <span class="type">string</span>)</span></span> *Student &#123;</span><br><span class="line">    s := <span class="built_in">new</span>(Student) <span class="comment">//局部变量s逃逸到堆</span></span><br><span class="line">    s.Name = name</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    StudentRegister(<span class="string">&quot;Jim&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行  <span class="keyword">go</span> build -gcflags=-m main.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//new(Student) escapes to heap</span></span><br></pre></td></tr></table></figure><ul><li>栈空间不足逃逸</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Slice()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Slice make([]int, 10000, 10000) does not escape</span></span><br></pre></td></tr></table></figure><ul><li>动态类型逃逸</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;Escape&quot;</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//s escapes to heap</span></span><br></pre></td></tr></table></figure><ul><li>闭包引用对象逃逸</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Increase</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n++</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">in := Increase()</span><br><span class="line">fmt.Println(in()) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(in()) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Increase() 返回值是一个闭包函数，该闭包函数访问了外部变量 n，那变量 n 将会一直存在，直到 in 被销毁。很显然，变量 n 占用的内存不能随着函数 Increase() 的退出而回收，因此将会逃逸到堆上。</span></span><br></pre></td></tr></table></figure><ul><li><strong>发送指针或带有指针的值到 channel 中</strong>。</li><li><strong>在一个切片上存储指针或带指针的值</strong>。 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。</li><li><strong>slice 的背后数组被重新分配了</strong>，因为 append 时可能会超出其容量( cap )。 slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。</li></ul><h2 id="避免内存逃逸"><a href="#避免内存逃逸" class="headerlink" title="避免内存逃逸"></a>避免内存逃逸</h2><p>在<code>runtime/stubs.go:133</code>有个函数叫<code>noescape</code>。noescape可以在逃逸分析中隐藏一个指针。让这个指针在逃逸分析中不会被检测为逃逸。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">noescape</span><span class="params">(p unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">     x := <span class="type">uintptr</span>(p)</span><br><span class="line">     <span class="keyword">return</span> unsafe.Pointer(x ^ <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">S *<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *A)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> *f.S</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ATrick <span class="keyword">struct</span> &#123;</span><br><span class="line">S unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *ATrick)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="type">string</span>)(f.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewA</span><span class="params">(s <span class="type">string</span>)</span></span> A &#123;</span><br><span class="line"><span class="keyword">return</span> A&#123;S: &amp;s&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewATrick</span><span class="params">(s <span class="type">string</span>)</span></span> ATrick &#123;</span><br><span class="line"><span class="keyword">return</span> ATrick&#123;S: noescape(unsafe.Pointer(&amp;s))&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noescape</span><span class="params">(p unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">x := <span class="type">uintptr</span>(p)</span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(x ^ <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">f1 := NewA(s)</span><br><span class="line">f2 := NewATrick(s)</span><br><span class="line">s1 := f1.String()</span><br><span class="line">s2 := f2.String()</span><br><span class="line">_ = s1 + s2</span><br><span class="line">&#125;</span><br><span class="line">$<span class="keyword">go</span> build -gcflags=-m main.<span class="keyword">go</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">24</span>:<span class="number">16</span>: &amp;s escapes to heap</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">23</span>:<span class="number">13</span>: moved to heap: s</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">27</span>:<span class="number">18</span>: NewATrick s does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">28</span>:<span class="number">45</span>: NewATrick &amp;s does not escape</span><br></pre></td></tr></table></figure><p><code>noescape()</code>函数的作用是<code>遮蔽输入和输出</code>的依赖关系。使编译器不认为 p会通过 x逃逸， 因为 uintptr()产生的引用是编译器无法理解的。<br>内置的 uintptr类型是一个真正的指针类型，但是在编译器层面，它只是一个存储一个 指针地址的 int类型。代码的最后一行返回 unsafe.Pointer也是一个 int。</p><h2 id="逃逸总结"><a href="#逃逸总结" class="headerlink" title="逃逸总结"></a>逃逸总结</h2><ul><li>栈上分配内存比在堆中分配内存有更高的效率</li><li>栈上分配的内存不需要GC处理</li><li>堆上分配的内存使用完毕会交给GC处理</li><li>逃逸分析目的是决定内分配地址是栈还是堆</li><li>逃逸分析在编译阶段完成</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-内存管理篇（二） 万字总结-golang内存分配篇</title>
      <link href="/2022/10/27/golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/27/golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是讲解Golang内存管理的第二篇,在第一篇中我们提到,Golang的内存分配模式与TCMalloc是极其相似的。<br>所以先来回顾一下TCMalloc相关知识点。</p><ul><li><code>Page</code>：TCMalloc也是以页为单位管理内存 默认8KB。</li><li><code>Span</code>:TCMalloc是以Span为单位向操作系统申请内存的,由一组连续的Page组成。</li><li><code>Size Class</code>:由Span分裂出的对象，由同一个Span分裂出的SizeClass大小相同，SizeClass是对象内存实际的载体。</li><li><code>ThreadCache</code>：存小对象，线程都会有一份单独的缓存,不需要加锁。</li><li><code>CentralCache</code>:存小对象，主要是起到针对<code>ThreadCache</code>的一层二级缓存作用各个线程共用的，所以与<code>CentralCache</code>获取内存交互是需要加锁的。</li><li><code>PageHeap</code>：<code>PageHeap</code>则是针对<code>CentralCache</code>的三级缓存,补对于中对象内存和大对象内存的分配，<code>PageHeap</code>也是直接和操作系统虚拟内存衔接的一层缓存。</li></ul><h2 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h2><h3 id="线性分配器"><a href="#线性分配器" class="headerlink" title="线性分配器"></a>线性分配器</h3><p><img src="https://img-blog.csdnimg.cn/e0ef48f870a44c5992ee047c1ec21add.png" alt="在这里插入图片描述"><br><strong>定义</strong><br>只需要在内存中维护一个指向内存特定位置的指针，当用户程序申请内存时，分配器只需要检查剩余的空闲内存、返回分配的内存区域并修改指针在内存中的位置，即移动下图中的指针。</p><p><strong>优点</strong><br>有较快的执行速度，以及较低的实现复杂度；</p><p><strong>缺点</strong><br>无法在内存被释放时重用内存，因此，需要合适的垃圾回收算法配合使用，<code>标记压缩、复制回收和分代回收</code>等算法可以通过拷贝的方式整理存活对象的碎片，将空闲内存定期合并。</p><h3 id="空闲链表分配器"><a href="#空闲链表分配器" class="headerlink" title="空闲链表分配器"></a>空闲链表分配器</h3><p><img src="https://img-blog.csdnimg.cn/79e3149437f649faa33b8e830254c552.png" alt="在这里插入图片描述"><br>只需要在内存中维护一个指向内存特定位置的指针、当用户程序申请内存时，分配器只需要检查剩余的空闲内存、返回分配的内存区域并修改指针在内存中的位置，即移动下图中的指针。</p><p><strong>链表分配器中常用的几种分配策略</strong></p><ul><li>首次适应（First-Fit）<ul><li>从链表头开始遍历，选择第一个大小大于申请内存的内存块</li></ul></li><li>循环首次适应（Next-Fit）<ul><li>从上次遍历的结束位置开始遍历，选择第一个大小大于申请的内存块</li></ul></li><li>最优适应（Best-Fit）<ul><li>从链表头遍历整个链表，选择最合适的内存块</li></ul></li><li>隔离适应（Segregated-Fit）<ul><li>将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块<ul><li>通过该策略会将内存分割成4、8、16、32字节的内存块组成的链表，当我们向内存分配器申请8字节的内存时，我们会在上图中的第二个链表找到空闲内存块并返回，隔离适应的分配策略减少了需要遍历的内存块数量，提高了内存分配的效率</li><li><strong>go语言使用的内存分配策略与隔离适应策略有些相似</strong></li></ul></li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/c1494648e2ed49e9bf0ffcc3efd8f63c.png" alt="在这里插入图片描述"></p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>Go在程序启动的时候，会先向操作系统申请一块内存，切成小块后自己进行管理。申请到的内存块被分配了三个区域，在X64上分别是512MB，16GB，512GB大小。<br><img src="https://img-blog.csdnimg.cn/2aac22892ea4416583cd498e55f6e4fa.png" alt="在这里插入图片描述"><br><code>arena</code>区域就是我们所谓的堆区，Go动态分配的内存都是在这个区域，它把内存分割成8KB大小的页，一些页组合起来称为<code>mspan</code>。<br><code>bitmap</code>区域标识<code>arena</code>区域哪些地址保存了对象，并且用4bit标志位表示对象是否包含指针、GC标记信息。<code>bitmap</code>中一个byte大小的内存对应arena区域中4个指针大小（指针大小为 8B ）的内存，所以<code>bitmap</code>区域的大小是512GB&#x2F;(4*8B)&#x3D;16GB。</p><p><img src="https://img-blog.csdnimg.cn/17e00071f33a437db8b641f6c0fbfd0b.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/f895eda5e56d4f7a9d8167645ab30cc0.png" alt="在这里插入图片描述"></p><h2 id="Golang内存模型层级结构"><a href="#Golang内存模型层级结构" class="headerlink" title="Golang内存模型层级结构"></a>Golang内存模型层级结构</h2><p><img src="https://img-blog.csdnimg.cn/3d965ffeaa9b44e98ccbd3173779077f.png" alt="在这里插入图片描述"></p><p>Golang内存管理模型与TCMalloc的设计极其相似。基本轮廓和概念也几乎相同，只是一些规则和流程存在差异，接下来分析一下Golang内存管理模型的基本层级模块组成概念。</p><h3 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h3><p>与TCMalloc的Page一致。Golang内存管理模型延续了TCMalloc的概念，一个Page的大小依然是8KB。</p><h3 id="mSpan"><a href="#mSpan" class="headerlink" title="mSpan"></a>mSpan</h3><p>与TCMalloc中的Span一致。mSpan概念依然延续TCMalloc中的Span概念，在Golang中将Span的名称改为mSpan，依然表示一组连续的Page。<a href="https://github.com/golang/go/blob/master/src/runtime/sizeclasses.go">对于mspan来说,Size Class会决定mspan所能分到的页数 （class_to_size 数组）</a><br><strong>span数据结构</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mSpanList <span class="keyword">struct</span> &#123;</span><br><span class="line">_     sys.NotInHeap</span><br><span class="line">first *mspan <span class="comment">// first span in list, or nil if none</span></span><br><span class="line">last  *mspan <span class="comment">// last span in list, or nil if none</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">    next *mspan            <span class="comment">//链表前向指针，用于将span链接起来</span></span><br><span class="line">    prev *mspan            <span class="comment">//链表前向指针，用于将span链接起来</span></span><br><span class="line">    list *mSpanList </span><br><span class="line">    startAddr <span class="type">uintptr</span> <span class="comment">// 起始地址，也即所管理页的地址 (指向area)</span></span><br><span class="line">    npages    <span class="type">uintptr</span> <span class="comment">// 管理的页数</span></span><br><span class="line">    nelems <span class="type">uintptr</span> <span class="comment">// 块个数，也即有多少个块可供分配</span></span><br><span class="line">    allocBits  *gcBits <span class="comment">//分配位图，每一位代表一个块是否已分配</span></span><br><span class="line">    allocCount  <span class="type">uint16</span>     <span class="comment">// 已分配块的个数</span></span><br><span class="line">    spanclass   spanClass  <span class="comment">// class表中的class ID</span></span><br><span class="line">freeindex <span class="type">uintptr</span>  <span class="comment">//— 扫描页中空闲对象的初始索引；</span></span><br><span class="line">    elemsize    <span class="type">uintptr</span>    <span class="comment">// class表中的对象大小，也即块大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：一个<code>mspan的Size Class</code>等于10，可知 object size是<code>144B</code>(后面有介绍)，算出可分配的对象个数是8KB&#x2F;144B&#x3D;56.89个，取整56个，所以会有一些内存浪费掉了，再根据<code>class_to_allocnpages</code>数组，得到这个<code>mspan</code>只由<code>1</code>个<code>page</code>组成；假设这个<code>mspan</code>是分配给无指针对象的，那么spanClass等于<code>20</code>。allocBits指向一个位图，每位代表一个块是否被分配。<br><img src="https://img-blog.csdnimg.cn/57707550a90f4c3fa9d7b6f7b45011df.png" alt="在这里插入图片描述"></p><h3 id="Size-Class相关"><a href="#Size-Class相关" class="headerlink" title="Size Class相关"></a>Size Class相关</h3><ul><li><strong>Object Size</strong>，协程应用逻辑一次向Golang内存申请的对象Object大小。<strong>Object是Golang内存管理模块针对内存管理更加细化的内存管理单元</strong>。一个Span在初始化时会被分成多个Object。比如<code>Object Size</code>是8B（8字节）大小的Object，所属的<code>Span</code>大小是8KB（8192字节）块大小为1024个,。<br><strong>Page是Golang内存管理与操作系统交互衡量内存容量的基本单元，Golang内存管理内部本身用来给对象存储内存的基本单元是Object。</strong></li><li><strong>Size Class</strong>，Golang内存管理中的<code>Size Class</code>与TCMalloc所表示的设计含义是一致的，都表示一块内存的所属规格或者刻度。**。<a href="https://github.com/golang/go/blob/master/src/runtime/sizeclasses.go">Go1.9.2里mspan的Size Class共有68种，每种mspan分割的object大小是8*2n的倍数。</a> 如果在用 <code>noscan </code>区分的话，则一共有136种 <code>spanClass</code>。</li><li><strong>Span Class</strong>，这个是Golang内存管理额外定义的规格属性，是针对Span来进行划分的，是Span大小的级别。<strong>一个Size Class会对应两个Span Class</strong>，其中一个Span为存放需要GC扫描的对象，另一个Span为存放不需要GC扫描的对象。</li></ul><p>其中<code>Size Class</code>和<code>Span Class</code>的对应关系计算方式可以参考Golang源代码，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//usr/local/go/src/runtime/mheap.go</span></span><br><span class="line"><span class="keyword">type</span> spanClass <span class="type">uint8</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSpanClass</span><span class="params">(sizeclass <span class="type">uint8</span>, noscan <span class="type">bool</span>)</span></span> spanClass &#123;</span><br><span class="line"><span class="keyword">return</span> spanClass(sizeclass&lt;&lt;<span class="number">1</span>) | spanClass(bool2int(noscan))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>对象</th><th>Size Class 与 Span Class对应公式</th></tr></thead><tbody><tr><td>需要GC扫描</td><td>Span Class &#x3D; Size Class * 2 + 0</td></tr><tr><td>不需要GC扫描</td><td>Span Class &#x3D; Size Class * 2 + 1</td></tr></tbody></table><h3 id="MCache"><a href="#MCache" class="headerlink" title="MCache"></a>MCache</h3><p><code>MCache</code>与TCMalloc的<code>ThreadCache</code>十分相似，访问mcache依然不需要加锁而是直接访问，且<code>MCache</code>中依然保存各种大小的<code>Span</code>。但是二者还是存在一定的区别的，<code>MCache</code>是与Golang协程调度模型GPM中的<code>P</code>所绑定，而不是和<code>线程</code>绑定。<code>mcache</code>在初始化的时候是没有任何mspan资源的，在使用过程中会动态地从<code>mcentral</code>申请，之后会缓存下来。当对象小于等于32KB大小时，使用mcache的相应规格的mspan进行分配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">local_scan  <span class="type">uintptr</span> <span class="comment">// 在当前mcache中已经分配的可以扫描的字节数</span></span><br><span class="line"><span class="comment">// 微对象分配器</span></span><br><span class="line">tiny             <span class="type">uintptr</span></span><br><span class="line">tinyoffset       <span class="type">uintptr</span></span><br><span class="line">local_tinyallocs <span class="type">uintptr</span> <span class="comment">// 微对象的分配数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// numSpanClasses = 138 = _NumSizeClasses * 2 </span></span><br><span class="line">   alloc [numSpanClasses]*mspan      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一组列表中所表示的对象中包含了指针，第二组列表中所表示的对象不含有指针，这么做是为了提高GC扫描性能，对于不包含指针的span列表，没必要去扫描。<br>根据对象是否包含指针，将对象分为noscan和scan两类，其中noscan代表没有指针，而scan则代表有指针，需要GC进行扫描。<img src="https://img-blog.csdnimg.cn/d7eb1eddaade4a08a1d8a6f6c3334c69.png" alt="在这里插入图片描述"></p><p><code>MCache</code>中每个<code>Span Class</code>都会对应一个MSpan，不同<code>Span Class</code>的MSpan的总体长度不同，参考上面的分配。</p><h3 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h3><p><code>MCentral</code>与<code>TCMalloc</code>中的<code>Central</code>概念依然相似。向<code>MCentral</code>申请<code>Span</code>是同样是需要加锁的。当<code>MCache</code>中某个<code>Size Class</code>对应的Span被一次次Object<code>被上层取走后，如果出现当前</code>Size Class<code>的</code>Span<code>空缺情况，</code>MCache<code>则会向</code>MCentral<code>申请对应的</code>Span<code>。</code>Goroutine<code>、</code>MCache<code>、</code>MCentral<code>、</code>MHeap&#96;互相交换的内存单位是不同,其中协程逻辑层与MCache的内存交换单位是Object，MCache与MCentral的内存交换单位是Span，而MCentral与MHeap的内存交换单位是Page。<br><img src="https://img-blog.csdnimg.cn/e6550d588e61452d952eaf5571e05191.png" alt="在这里插入图片描述"></p><p><code>MCentral</code>与<code>TCMalloc</code>中的<code>Central</code>不同的是<code>MCentral</code>针对每个<code>Span Class</code>级别有两个<code>Span</code>链表，而<code>TCMalloc</code>中的<code>Central</code>只有一个。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// mcentral对应的spanClass</span></span><br><span class="line">spanclass spanClass</span><br><span class="line"></span><br><span class="line">partial  [<span class="number">2</span>]spanSet <span class="comment">// 储存空闲的Span的列表 </span></span><br><span class="line">full     [<span class="number">2</span>]spanSet <span class="comment">// 储存不包含空闲空间的列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**partial ** : 表示还有可用空间的<code>Span</code>链表。链表中的所有Span都至少有1个空闲的Object空间。如果MCentral上游MCache退还Span，会将退还的Span加入到<code>partial </code>链表中。<br>**full **:表示这条链表里的<code>mspan</code>都被分配了object，或者是已经被<code>cache</code>取走了的<code>mspan</code>，这个mspan就被那个工作线程独占了。<br>可以看见<code>Partial和Full</code>都是一个[2]spanSet类型，也就每个Partial和Full都各有两个spanSet集合，这是为了给GC垃圾回收来使用的，其中一个集合是<code>已扫描</code>的，另一个集合是<code>未扫描</code>的。</p><p><strong>线程从central获取span步骤如下：</strong></p><ul><li>加锁</li><li>从<code>partial</code>列表获取一个可用<code>span</code>，并将其从链表中删除</li><li>将取出的<code>span</code>放入<code>full</code>链表</li><li>将span返回给线程</li><li>解锁</li><li>线程将该<code>span</code>缓存进<code>cache</code><br><strong>线程将span归还步骤如下：</strong></li><li>加锁</li><li>将<code>span</code>从full &#96;列表删除</li><li>将<code>span</code>加入<code>partial </code>列表</li><li>解锁</li></ul><h3 id="mheap"><a href="#mheap" class="headerlink" title="mheap"></a>mheap</h3><p>Golang内存管理的<code>MHeap</code>依然是继承<code>TCMalloc</code>的<code>PageHeap</code>设计。MHeap的上游是<code>MCentral</code>，MCentral中的Span不够时会向<code>MHeap</code>申请。<code>MHeap</code>的下游是操作系统，<code>MHeap</code>的内存不够时会向操作系统的虚拟内存空间申请。访问<code>MHeap</code>获取内存依然是需要加锁的。<code>MHeap</code>是对内存块的管理对象，是通过Page为内存单元进行管理。那么用来详细管理每一系列Page的结构称之为一个<code>HeapArena</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">lock mutex<span class="comment">// spans: 指向mspans区域，用于映射mspan和page的关系</span></span><br><span class="line">spans []*mspan </span><br><span class="line"><span class="comment">// 指向bitmap首地址，bitmap是从高地址向低地址增长的</span></span><br><span class="line">bitmap <span class="type">uintptr</span> </span><br><span class="line">    <span class="comment">// 指示arena区首地址</span></span><br><span class="line">arena_start <span class="type">uintptr</span> </span><br><span class="line"><span class="comment">// 指示arena区已使用地址位置</span></span><br><span class="line">arena_used  <span class="type">uintptr</span> </span><br><span class="line"><span class="comment">// 指示arena区末地址</span></span><br><span class="line">arena_end   <span class="type">uintptr</span> </span><br><span class="line">central [<span class="number">67</span>*<span class="number">2</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">mcentral mcentral</span><br><span class="line">pad [sys.CacheLineSize - unsafe.Sizeof(mcentral&#123;&#125;)%sys.CacheLineSize]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6432684a83814c23bf67451d969ddd41.png" alt="在这里插入图片描述"><br>heapArena用于管理真实的内存<br><img src="https://img-blog.csdnimg.cn/2a1a96f06d6248acab61d2a88ba09d3c.png" alt="在这里插入图片描述"></p><h2 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h2><ul><li>微对象 (0, 16B) — 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存；</li><li>小对象 [16B, 32KB] — 依次尝试使用线程缓存、中心缓存和堆分配内存；</li><li>大对象 (32KB, +∞) — 直接在堆上分配内存；</li></ul><h3 id="Tiny对象分配流程"><a href="#Tiny对象分配流程" class="headerlink" title="Tiny对象分配流程"></a>Tiny对象分配流程</h3><p>Tiny空间是从<code>Size Class = 2</code>中获取一个16B的Object，作为Tiny对象的分配空间。对于Golang内存管理为什么需要一个Tiny这样的16B空间，原因是因为如果协程逻辑层申请的内存空间小于等于8B，那么根据正常的Size Class匹配会匹配到<code>Size Class = 1</code>，所以像<code>int32、 byte、 bool</code>以及小字符串等经常使用的Tiny微小对象，也都会使用从<code>Size Class = 1</code>申请的这8B的空间。但是类似bool或者1个字节的byte，也都会各自独享这8B的空间，进而导致有一定的内存空间浪费。</p><p>Go 语言运行时将小于 16 字节的对象划分为<strong>微对象</strong>，它会使用线程缓存上的微分配器提高微对象分配的性能，我们主要使用它来分配较小的字符串以及逃逸的临时变量。微分配器可以将多个较小的内存分配请求合入同一个内存块中，<strong>只有当内存块中的所有对象都需要被回收时，整片内存才可能被回收</strong>。</p><p><strong>微对象分配部分的代码:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//maxSmallSize  =32*1024*1024 32kb</span></span><br><span class="line"><span class="comment">// maxTinySize  =16b</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line"><span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">off := c.tinyoffset</span><br><span class="line"><span class="comment">// 省略将off对齐的代码</span></span><br><span class="line"><span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 将对象分配到微对象分配器中,实际是将对应的内存作为指针返回</span></span><br><span class="line">x = unsafe.Pointer(c.tiny + off)</span><br><span class="line"><span class="comment">// 更新微对象分配器中的状态</span></span><br><span class="line">c.tinyoffset = off + size</span><br><span class="line">c.tinyAllocs++</span><br><span class="line">mp.mallocing = <span class="number">0</span></span><br><span class="line">releasem(mp)</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果微对象分配器中的内存不足时,使用span进行分配.</span></span><br><span class="line">span = c.alloc[tinySpanClass]</span><br><span class="line"><span class="comment">//调用mcache中缓存的mspan获取内存.</span></span><br><span class="line">v := nextFreeFast(span)</span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 同样是获取mcache中的缓存,但是更加耗时</span></span><br><span class="line"><span class="comment">// 如果mcache中没获取到则获取mcentral中的mspan用于分配(调用refill方法)</span></span><br><span class="line"><span class="comment">// 如果mcentral也没有则去找mheap.</span></span><br><span class="line"><span class="comment">// 这里的tinySpanClass,是序号为2的spanClass,即大小为16字节.同时也等于macTinySize</span></span><br><span class="line">v, span, shouldhelpgc = c.nextFree(tinySpanClass)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回对应内存的指针</span></span><br><span class="line">x = unsafe.Pointer(v)</span><br><span class="line">(*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">(*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment">// 如果微对象分配器没有初始化,则将当前对象申请的空间作为微对象分配器的空间</span></span><br><span class="line"><span class="keyword">if</span> size &lt; c.tinyoffset || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">c.tiny = <span class="type">uintptr</span>(x)</span><br><span class="line">c.tinyoffset = size</span><br><span class="line">&#125;</span><br><span class="line">size = maxTinySize</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MCache中对于Tiny微小对象的申请流程如下：</p><ul><li>P向MCache申请微小对象(假如是bool类型)。如果申请的<code>Object</code>在<code>Tiny对象</code>的大小范围内，则进入<code>Tiny</code>对象申请流程，否则进入小对象或大对象申请流程。</li><li>判断申请的<code>Tiny</code>对象是否包含指针，如果包含则进入小对象申请流程（不会放在Tiny缓冲区，因为需要GC走扫描等流程）。</li><li>如果Tiny空间的16B没有多余的存储容量，则从<code>Size Class = 2</code>的Span中获取一个16B的Object放置Tiny缓冲区。</li><li>将对象（bool）放置在16B的Tiny空间中，以字节对齐的方式。</li></ul><p>注意：</p><blockquote><p>微分配器管理的对象不可以是指针类型，管理多个对象的内存块大小 maxTinySize 是可以调整的.<br>在默认情况下，内存块的大小为 16 字节。<br>微对象分配器中已经被分配了12B的内存,现在仅剩下4B空闲, 如果此时有小于等于4B的对象需要被分配内存,那么这个对象会直接使用tinyoffset之后剩余的空间。<br>分配在微对象分配器中的对象只有在微对象分配器中所有对象都标记为垃圾才会被整块回收。<br>如果微对象分配器一开始没有被初始化,但是又有微对象需要被分配,就会走小对象分配的过程,但是申请到的空间会作为微对象分配器的空间,剩下的空间可以用于分配另外的微对象。</p></blockquote><p><strong>使用微对象分配器节省空间。</strong><br><img src="https://img-blog.csdnimg.cn/4f0fd4f939f64da2870ef8802abe9283.png" alt="在这里插入图片描述"></p><h3 id="小对象分配流程"><a href="#小对象分配流程" class="headerlink" title="小对象分配流程"></a>小对象分配流程</h3><p>分配小对象的标准流程是按照·Span Class·规格匹配的。在之前介绍MCache的内部构造已经介绍了，MCache一共有68份<code>Size Class</code>其中Size Class 为0的做了特殊的处理直接返回一个固定的地址。<code>Span Class</code>为<code>Size Class</code>的二倍。</p><p><strong>具体的流程过程</strong>：</p><ul><li>MCache在接收到请求后，会根据对象所需的内存空间计算出具体的大小Size。</li><li>判断Size是否小于16B，如果小于16B则进入Tiny微对象申请流程，否则进入小对象申请流程。</li><li>根据Size匹配对应的<code>Size Class</code>内存规格，再根据Size Class和该对象是否包含指针，来定位是从<code>noscan Span Class</code> 还是 <code>scan Span Class</code>获取空间，没有指针则锁定noscan。</li><li>在定位的<code>Span Class</code>中的Span取出一个Object返回给协程逻辑层P，P得到内存空间，流程结束。</li><li>如果定位的<code>Span Class</code>中的<code>Span</code>所有的内存块<code>Object</code>都被占用，则<code>MCache</code>会向<code>MCentral</code>申请一个Span。</li><li>MCentral收到内存申请后，优先从相对应的<code>Span Class</code>中的<code>Partial Set</code>,里取出<code>Span</code>，<code>Partial Set</code>List没有则从<code>Full Set </code>中取，返回给<code>MCache</code>。</li><li><code>MCache</code>得到<code>MCentral</code>返回的<code>Span</code>，补充到对应的<code>Span Class</code>中，P得到内存空间，流程结束。</li><li>如果<code>Full Set</code>中没有符合条件的Span，则MCentral会向MHeap申请内存。</li><li>MHeap收到内存请求从其中一个<code>HeapArena</code>从取出一部分<code>Pages</code>返回给<code>MCentral</code>，当<code>MHeap</code>没有足够的内存时，<code>MHeap</code>会向操作系统申请内存，将申请的内存也保存到<code>HeapArena</code>中的mspan中。MCentral将从MHeap获取的由Pages组成的Span添加到对应的<code>Span Class</code>链表或集合中。</li><li>最后协程业务逻辑层得到该对象申请到的内存，流程结束。</li></ul><h3 id="大对象分配流程"><a href="#大对象分配流程" class="headerlink" title="大对象分配流程"></a>大对象分配流程</h3><p>小对象是在MCache中分配的，而大对象是直接从MHeap中分配。对于不满足MCache分配范围的对象，均是按照大对象分配流程处理。</p><p><strong>具体的大对象内存分配流程</strong></p><ul><li>协程逻辑层申请大对象所需的内存空间，如果超过32KB，则直接绕过<code>MCache</code>和<code>MCentral</code>直接向<code>MHeap</code>申请。</li><li><code>MHeap</code>根据对象所需的空间计算得到需要多少个Page。</li><li><code>MHeap</code>向<code>Arenas</code>中的<code>HeapArena</code>申请相对应的Pages。</li><li>如果<code>Arenas中没有</code>HeapA<code>可提供合适的</code>Pages&#96;内存，则向操作系统的虚拟内存申请，且填充至Arenas中。</li><li>MHeap返回大对象的内存空间。</li><li>协程逻辑层P得到内存，流程结束。</li></ul><p>参考链接<br><a href="https://zhuanlan.zhihu.com/p/572059278">https://zhuanlan.zhihu.com/p/572059278</a><br><a href="https://www.topgoer.cn/docs/gozhuanjia/gozhuanjiachapter044.1-memory_alloc">https://www.topgoer.cn/docs/gozhuanjia/gozhuanjiachapter044.1-memory_alloc</a><br><a href="https://juejin.cn/post/6844903795739082760#heading-5">https://juejin.cn/post/6844903795739082760#heading-5</a><br><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#%E5%B0%8F%E5%AF%B9%E8%B1%A1">https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#%E5%B0%8F%E5%AF%B9%E8%B1%A1</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>golang内存TCMalloc算法的区别</li><li>Go内存管理的基本单元是mspan，它由若干个页组成，每种mspan可以分配特定大小的object</li><li>mcache, mcentral, mheap是Go内存管理的三大组件，层层递进。mcache管理线程在本地缓存的</li><li>极小对象会分配在一个object中，以节省资源，使用tiny分配器分配内存；一般小对象通过mspan分配内存；大对象则直接由mheap分配内存。</li></ul>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang-值接收者和指针接收者的区别</title>
      <link href="/2022/10/27/golang/%E5%9F%BA%E7%A1%80/go/"/>
      <url>/2022/10/27/golang/%E5%9F%BA%E7%A1%80/go/</url>
      
        <content type="html"><![CDATA[<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法能给<strong>用户自定义的类型</strong>添加新的行为。它和函数的区别在于方法有一个<strong>接收者</strong>，给一个函数添加一个接收者，那么它就变成了方法。<strong>接收者可以是值接收者，也可以是指针接收者</strong>。<br>在调用方法的时候，<strong>值类型</strong>既可以<strong>调用值接收者</strong>的方法，也可以调用<strong>指针接收者</strong>的方法；<strong>指针类型</strong>既可以调用<strong>指针接收者</strong>的方法，也可以调用<strong>值接收者</strong>的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> AddAge() &#123;</span><br><span class="line">p.age += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> GetAge() &#123;</span><br><span class="line">p.age += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// p1 是值类型</span></span><br><span class="line">p := Person&#123;age: <span class="number">18</span>&#125;</span><br><span class="line"><span class="comment">// 值类型 调用接收者也是值类型的方法</span></span><br><span class="line">p.AddAge()</span><br><span class="line">fmt.Println(p.age)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p2 是指针类型  指针类型调用接收者是值类型的方法</span></span><br><span class="line">p2 := &amp;Person&#123;age: <span class="number">100</span>&#125;</span><br><span class="line">p2.AddAge()</span><br><span class="line">fmt.Println(p2.age)</span><br><span class="line"><span class="comment">//值类型 调用接收者也是指针类型的方法</span></span><br><span class="line">p3 := Person&#123;age: <span class="number">18</span>&#125;</span><br><span class="line">p3.GetAge()</span><br><span class="line">fmt.Println(p3.age)</span><br><span class="line"><span class="comment">// 指针类型 调用收者也是指针类型的方法</span></span><br><span class="line">p4 := Person&#123;age: <span class="number">100</span>&#125;</span><br><span class="line">p4.GetAge()</span><br><span class="line">fmt.Println(p4.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//18</span></span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//19</span></span><br><span class="line"><span class="comment">//101</span></span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>值接收者</th><th>指针接收者</th></tr></thead><tbody><tr><td>值类型调用者</td><td>传递一个副本</td><td>使用值的引用来调用方法</td></tr><tr><td>指针类型调用者</td><td>传递一个副本</td><td>方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针</td></tr></tbody></table><p>总结：<br>1.一个结构体的方法的接收者可能是类型值或指针<br>2.当<strong>接受者不是一个指针</strong>时，该方法操作对应接受者的值的副本，即使你使用了指针调用函数，但是函数的接受者是值类型，所以函数内部操作还是对副本的操作，而不是指针操作。<br>3.如果接收者是指针，则调用者修改的是指针指向的值本身。</p><h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><p>当结构体实现一个接口时，可以在方法中设置一个接收者，比如对于以下接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Inter <span class="keyword">interface</span> &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体在实现它时，方法的接收者类型可以是：值、指针。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span></span> foo() &#123;&#125; <span class="comment">// 值类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S)</span></span> foo() &#123;&#125; <span class="comment">// 或者指针类型</span></span><br></pre></td></tr></table></figure><p>在使用结构体初始化接口变量时，结构体的类型也可以是：值、指针。比如：</p><figure class="highlight go"><figcaption><span>、</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="keyword">var</span> s Inter = S&#123;&#125; <span class="comment">// 值类型</span></span><br><span class="line">s.foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s Inter = &amp;S&#123;&#125; <span class="comment">// 指针类型</span></span><br><span class="line">s.foo()</span><br></pre></td></tr></table></figure><p>那么调用接口方法的组合实际有四种情况：<br><strong>值类型结构体 -&gt; 赋值给接口 -&gt; 调用接收者类型为值类型的结构体方法<br>指针类型结构体 -&gt; 赋值给接口 -&gt; 调用接收者类型为指针类型的结构体方法<br>值类型结构体 -&gt; 赋值给接口 -&gt; 调用接收者类型为指针类型的结构体方法（不通过）<br>指针类型结构体 -&gt; 赋值给接口 -&gt; 调用接收者类型为值类型的结构体方法</strong><br>结构体类型为值类型、调用了接收者为指针的方法不通过。但是反过来，结构体为指针类型时，却可以调用接收值为值或指针的任何方法。这是为什么呢？</p><p><strong>接收者是方法的一个额外的参数</strong>，而 Go 在调用函数的时候，参数都是值传递的。将一个<strong>指针拷贝，它们还是指向同一个地址，指向一个确定的结构体；将一个值拷贝，它们变成了两个不同的结构体，有着不同的地址</strong>。这会导致以下两种情况：</p><p>当在一个结构体指针上，通过接口，调用一个接收者为值类型的方法时，Go 首先会创建这个指针的副本，然后将这个指针解引用，再作为接收者参数传递给该方法。这两个指针指向相同的地址，所以它们传递给方法的接收者参数都是相同的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Inter <span class="keyword">interface</span> &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span></span> foo() &#123;&#125; <span class="comment">// 接收者为值类型的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a Inter = &amp;S&#123;&#125; <span class="comment">// 使用结构体指针初始化一个接口</span></span><br><span class="line">a.foo() <span class="comment">// 调用 foo 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上底层是这样的：</span></span><br><span class="line"><span class="comment">// 首先拷贝 a 的底层值，即 `&amp;S&#123;&#125;`，是一个结构体指针：</span></span><br><span class="line"><span class="keyword">var</span> b *S = a.inner_value <span class="comment">// a、b 是不同的变量，但是指向同一个结构体</span></span><br><span class="line"><span class="comment">// 然后将 b 解引用，传递给 foo：</span></span><br><span class="line">foo(*b) <span class="comment">// *b 和 *(a.inner_value) 其实都表示同一个结构体</span></span><br></pre></td></tr></table></figure><p>这些规则用来说明是否我们一个类型的值或者指针实现了该接口：</p><ul><li>类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集</li><li>类型 T 的可调用方法集包含接受者为 T 的所有方法</li></ul><h3 id="两者分别在何时使用"><a href="#两者分别在何时使用" class="headerlink" title="两者分别在何时使用"></a>两者分别在何时使用</h3><p>如果方法的接收者是<strong>值类型</strong>，无论调用者是对象还是对象指针，修改的都是<strong>对象的副本</strong>，不影响调用者；如果方法的接收者是<strong>指针类型</strong>，则调用者修改的是<strong>指针指向的对象本身</strong>。</p><p>使用指针作为方法的接收者的理由：</p><ul><li>方法能够修改接收者指向的值。</li><li>避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</li><li>是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的本质。</li></ul>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 结构体 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang-map</title>
      <link href="/2022/10/27/golang/%E5%9F%BA%E7%A1%80/go_map/"/>
      <url>/2022/10/27/golang/%E5%9F%BA%E7%A1%80/go_map/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Map？"><a href="#什么是Map？" class="headerlink" title="什么是Map？"></a>什么是Map？</h3><p><strong>声明 &amp; 初始化map</strong><br>map是一个拥有<strong>键值对元素</strong>的无序集合。在这个集合中，<strong>键的值是唯一的</strong>，键对应的值可以通过键来获取、更新或移除。<br>在 Go 语言中， map是散列表的引用， map的类型是map[K]V ，其中 K 和 V 是字典的键和值对应的数据类型。 map 中所有的<strong>键都拥有相同的数据类型</strong>，同时<strong>所有的值也都拥有相同的数据类型</strong>，但是键的类型和值的类型不一定相同。<strong>键的类型 K ，必须是可以通过操作符&#x3D;&#x3D;来进行比较的数据类型</strong>，所以 map 可以检测某一个键是否已经存在。</p><h3 id="go-map的数据结构-重点"><a href="#go-map的数据结构-重点" class="headerlink" title="go map的数据结构(重点)"></a>go map的数据结构(重点)</h3><p><strong>核心结体体</strong><br><img src="https://img-blog.csdnimg.cn/15f2a059687d46c59b52bb687069d9af.png" alt="在这里插入图片描述"><br><strong>哈希桶（hmap）</strong><br>指整个哈希数组，数组内每个元素是一个桶。<br><strong>桶链</strong><br>哈希桶的一个桶以及该桶下挂着的所有溢出桶。<br><strong>桶（bucket）</strong><br>一个bmap结构，与溢出桶的区别在于它是哈希桶数组上的一个元素。严格来说hmap.buckets指向桶组成的数组，每个桶的头部是bmap，之后是8个key，再是8个value，最后是1个溢出指针。溢出指针指向额外的桶链表，用于存储溢出的数据<br><strong>溢出桶（overflow bucket）</strong><br>一个bmap结构，与桶区别是，它不是哈希桶数组的元素，而是挂在哈希桶数组上或挂在其它溢出桶上。<br><strong>负载因子(overFactor)</strong><br>表示平均每个哈希桶的元素个数（注意是哈希桶，不包括溢出桶）。如当前map中总共有20个元素，哈希桶长度为4，则负载因子为5。负载因子主要是来判断当前map是否需要扩容。<br>新、旧哈希桶<br>新、旧哈希桶的概念只存在于map扩容阶段，在哈希桶扩容时，会申请一个新的哈希桶，原来的哈希桶变成了旧哈希桶，然后会分步将旧哈希桶的元素迁移到新桶上，当旧哈希桶所有元素都迁移完成时，旧哈希桶会被释放掉。</p><p><strong>核心源码</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ( <span class="comment">// 关键的变量</span></span><br><span class="line">    bucketCntBits = <span class="number">3</span></span><br><span class="line">bucketCnt     = <span class="number">1</span> &lt;&lt; bucketCntBits  <span class="comment">// 一个桶最多存储8个key-value对</span></span><br><span class="line">loadFactorNum = <span class="number">13</span> <span class="comment">// 扩散因子：loadFactorNum / loadFactorDen = 6.5。</span></span><br><span class="line">loadFactorDen = <span class="number">2</span>  <span class="comment">// 即元素数量 &gt;= (hash桶数量(2^hmp.B) * 6.5 / 8) 时，触发扩容</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// map的基础数据结构</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">count     <span class="type">int</span> <span class="comment">// map存储的元素对计数，len()函数返回此值，所以map的len()时间复杂度是O(1)</span></span><br><span class="line">flags     <span class="type">uint8</span>  <span class="comment">// 记录几个特殊的位标记，如当前是否有别的线程正在写map、当前是否为相同大小的增长（扩容/缩容？）</span></span><br><span class="line">B         <span class="type">uint8</span>  <span class="comment">// hash桶buckets的数量为2^B个</span></span><br><span class="line">noverflow <span class="type">uint16</span> <span class="comment">// 溢出的桶的数量的近似值</span></span><br><span class="line">hash0     <span class="type">uint32</span> <span class="comment">// hash种子</span></span><br><span class="line"></span><br><span class="line">buckets    unsafe.Pointer <span class="comment">// 指向2^B个桶组成的数组的指针，数据存在这里</span></span><br><span class="line">oldbuckets unsafe.Pointer <span class="comment">// 指向扩容前的旧buckets数组，只在map增长时有效</span></span><br><span class="line">nevacuate  <span class="type">uintptr</span>        <span class="comment">// 计数器，标示扩容后搬迁的进度</span></span><br><span class="line"></span><br><span class="line">extra *mapextra <span class="comment">// 保存溢出桶的链表和未使用的溢出桶数组的首地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap  <span class="comment">//overflow 为 hmap.buckets （当前）溢出桶的指针地址</span></span><br><span class="line">    oldoverflow *[]*bmap  <span class="comment">//oldoverflow 为 hmap.oldbuckets （旧）溢出桶的指针地址</span></span><br><span class="line">    nextOverflow *bmap  <span class="comment">//nextOverflow 为空闲溢出桶的指针地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 桶的实现结构</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// tophash存储桶内每个key的hash值的高字节</span></span><br><span class="line"><span class="comment">// tophash[0] &lt; minTopHash表示桶的疏散状态</span></span><br><span class="line"><span class="comment">// 当前版本bucketCnt的值是8，一个桶最多存储8个key-value对</span></span><br><span class="line">tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line"><span class="comment">// 特别注意：</span></span><br><span class="line"><span class="comment">// 实际分配内存时会申请一个更大的内存空间A，A的前8字节为bmap</span></span><br><span class="line"><span class="comment">// 后面依次跟8个key、8个value、1个溢出指针</span></span><br><span class="line"><span class="comment">// map的桶结构实际指的是内存空间A</span></span><br><span class="line">keys    [bucketCnt]KeyType</span><br><span class="line">values  [bucketCnt]ValueType</span><br><span class="line">overflow *bmap <span class="comment">//溢出bucket的地址</span></span><br><span class="line"><span class="comment">//上述中keys   values  和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map.go里很多函数的第1个入参是这个结构，从成员来看很明显，此结构标示了键值对和桶的大小等必要信息</span></span><br><span class="line"><span class="comment">// 有了这个结构的信息，map.go的代码就可以与键值对的具体数据类型解耦</span></span><br><span class="line"><span class="comment">// 所以map.go用内存偏移量和unsafe.Pointer指针来直接对内存进行存取，而无需关心key或value的具体类型</span></span><br><span class="line"><span class="keyword">type</span> maptype <span class="keyword">struct</span> &#123;</span><br><span class="line">typ        _type</span><br><span class="line">key        *_type</span><br><span class="line">elem       *_type</span><br><span class="line">bucket     *_type <span class="comment">// internal type representing a hash bucket</span></span><br><span class="line">keysize    <span class="type">uint8</span>  <span class="comment">// size of key slot</span></span><br><span class="line">valuesize  <span class="type">uint8</span>  <span class="comment">// size of value slot</span></span><br><span class="line">bucketsize <span class="type">uint16</span> <span class="comment">// size of bucket</span></span><br><span class="line">flags      <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Go 用了增量扩容。而 buckets 和 oldbuckets 也是与扩容相关的载体，一般情况下只使用 buckets，oldbuckets 是为空的。但如果正在扩容的话，oldbuckets 便不为空，buckets 的大小也会改变</li><li>当 hint 大于 8 时，就会使用 *mapextra 做溢出桶。若小于 8，则存储在 buckets 桶中</li><li>map底层创建时，会初始化一个hmap结构体，同时分配一个足够大的内存空间A。其中A的前段用于hash数组，A的后段预留给溢出的桶。于是hmap.buckets指向hash数组，即A的首地址；hmap.extra.nextOverflow初始时指向内存A中的后段，即hash数组结尾的下一个桶，也即第1个预留的溢出桶。所以当hash冲突需要使用到新的溢出桶时，会优先使用上述预留的溢出桶，hmap.extra.nextOverflow依次往后偏移直到用完所有的溢出桶，才有可能会申请新的溢出桶空间。<br><img src="https://img-blog.csdnimg.cn/0e450ff30ca54871a8f445552fa3ad15.png" alt="在这里插入图片描述"><br><strong>bmap结构图</strong><br>当往map中存储一个kv对时，通过k获取hash值，<strong>hash值的低八位和bucket数组长度取余</strong>，定位到在数组中的那个下标，hash值的高八位存储在bucket中的tophash中，用来快速判断key是否存在，key和value的具体值则通过指针运算存储，当一个bucket满时，通过overfolw指针链接到下一个bucket。<br><img src="https://img-blog.csdnimg.cn/c2578e8ee4614cf9a9ce28536f62b9fa.png" alt="在这里插入图片描述"></li></ul><p><strong>为什么不是k1v1，k2v2….. 而是k1k2…v1v2…</strong>，<br>我们看上面的注释说的 map[int64]int8,key是int64（8个字节），value是int8（一个字节），kv的长度不同，如果按照kv格式存放，则考虑内存对齐v也会占用int64，而按照后者存储时，8个v刚好占用一个int64,从这个就可以看出go的map设计之巧妙.</p><h3 id="map创建"><a href="#map创建" class="headerlink" title="map创建"></a>map创建</h3><ul><li>不带参数   make(map[keyType]valueType)</li><li>带参数      make(map[keyType]valueType, size)</li></ul><p><strong>源码分析</strong></p><ul><li>创建hmap，并初始化。</li><li>获取一个随机种子，保证同一个key在不同map的hash值不一样（安全考量）。</li><li>计算初始桶大小。</li><li>如果初始桶大小不为0， 则创建桶，有必要还要创建溢出桶结构。<img src="https://img-blog.csdnimg.cn/e4f85d542dcf45a085c023fef7d250a7.png" alt="在这里插入图片描述"></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make(map[k]v, hint), hint即预分配大小</span></span><br><span class="line"><span class="comment">// 不传hint时，如用new创建个预设容量为0的map时，makemap只初始化hmap结构，不分配hash数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;</span><br><span class="line"><span class="comment">// 1. 创建hmap，并初始化</span></span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">h = <span class="built_in">new</span>(hmap)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取一个随机种子</span></span><br><span class="line">h.hash0 = fastrand()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算初始桶大小。</span></span><br><span class="line">B := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// overLoadFactor(hint, B)只有一行代码：return hint &gt; bucketCnt &amp;&amp; uintptr(hint) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span></span><br><span class="line"><span class="comment">// 即B的大小应满足 hint &lt;= (2^B) * 6.5</span></span><br><span class="line"><span class="comment">// 一个桶能存8对key-value，所以这就表示B的初始值是保证这个map不需要扩容即可存下hint个元素对的最小的B值</span></span><br><span class="line"><span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">B++</span><br><span class="line">&#125;</span><br><span class="line">h.B = B</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里分配hash数组</span></span><br><span class="line"><span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// makeBucketArray()会在hash数组后面预分配一些溢出桶，</span></span><br><span class="line"><span class="comment">// h.extra.nextOverflow用来保存上述溢出桶的首地址</span></span><br><span class="line"><span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">h.extra.nextOverflow = nextOverflow</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给map bucket分配内存</span></span><br><span class="line"><span class="comment">//  @param t map的类型</span></span><br><span class="line"><span class="comment">//  @param b 桶的个数2^b</span></span><br><span class="line"><span class="comment">//  @param dirtyalloc 是否要把返回的buckets指向dirtyalloc地址</span></span><br><span class="line"><span class="comment">//  @return buckets buckets地址</span></span><br><span class="line"><span class="comment">//  @return nextOverflow 溢出桶地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBucketArray</span><span class="params">(t *maptype, b <span class="type">uint8</span>, dirtyalloc unsafe.Pointer)</span></span> (buckets unsafe.Pointer, nextOverflow *bmap) &#123;</span><br><span class="line">base := bucketShift(b) <span class="comment">// base代表用户预期的桶的数量，即hash数组的真实大小</span></span><br><span class="line">nbuckets := base <span class="comment">// nbuckets表示实际分配的桶的数量，&gt;= base，这就可能会追加一些溢出桶作为溢出的预留</span></span><br><span class="line"><span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line"><span class="comment">// 这里追加一定数量的桶，并做内存对齐</span></span><br><span class="line">nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">sz := t.bucket.size * nbuckets</span><br><span class="line">up := roundupsize(sz)</span><br><span class="line"><span class="keyword">if</span> up != sz &#123;</span><br><span class="line">nbuckets = up / t.bucket.size</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里大家可以思考下这个数组空间要怎么分配，其实就是n*sizeof(桶)，所以：</span></span><br><span class="line"><span class="comment">// 每个桶前面是8字节的tophash数组，然后是8个key，再是8个value，最后放一个溢出指针</span></span><br><span class="line"><span class="comment">// sizeof(桶) = 8 + 8*sizeof(key) + 8*sizeof(value) + 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> buckets, nextOverflow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>哈希桶初始大小</strong><br>在创建map时，当没有指定size大小或size为0时，不会创建哈希桶，会在插入元素时创建，避免只申请不使用导致的效率和内存浪费。当size不为0时，会根据size大小计算出哈希桶的大小。</p><ul><li>size &lt;9，bucketLen &#x3D; 1 (2^0) B&#x3D;0</li><li>size &lt; 14，bucketLen &#x3D; 2 (2^1) B&#x3D;1</li><li>size &lt; 27，bucketLen &#x3D; 4 (2^2) B&#x3D;2</li><li>size &lt; 53，bucketLen &#x3D; 8 (2^3) B&#x3D;3</li><li>size &lt; 104，bucketLen &#x3D; 16 (2^4) B&#x3D;4</li></ul><h3 id="插入或更新"><a href="#插入或更新" class="headerlink" title="插入或更新"></a>插入或更新</h3><blockquote><p>向nil map赋值会引发panic​<br>map不支持并发读写</p></blockquote><p>go map的插入操作，调用mapassign()函数。</p><ul><li>go map需要初始化才能使用，对空map插入会panic。hmap指针传递的方式，决定了map在使用前必须初始化</li><li>go map不支持并发读写，会panic。如果一定要并发，请用sync.Map或自己解决冲突。</li></ul><p>流程分析：</p><ul><li>判断map是否为空、判断有没有协程并发写。</li><li>计算key的哈希值，设置写标志</li><li>如果buckets为空，申请一个长度为1的buckets。</li><li>找出改key对应的桶位置。</li><li>如果map正在迁移切该桶没有被迁移，迁移该桶。</li><li>遍历该桶，如果找到相同的key，返回val的位置。如果没有找到，找出下一个空位置，赋值tophash、key，返回val的位置。</li><li>判断map是否需要扩容，如果扩容，返回5的操作。</li><li>如果当前buckets和溢出buckets都没有位置了，添加一个溢出buckets，赋值tophash、key到第一个空位，返回val的位置。<br>-<img src="https://img-blog.csdnimg.cn/ae3ed1418edf4bffb0e74b0986a4a41c.png"></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增或者替换key val  m[key]=val</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">  <span class="comment">//@Step1 如果map为nil，panic</span></span><br><span class="line">  <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">&quot;assignment to entry in nil map&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断有没有协程正在写map</span></span><br><span class="line">  <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// @Step2</span></span><br><span class="line">  hash := alg.hash(key, <span class="type">uintptr</span>(h.hash0)) <span class="comment">// 这里得到uint32的hash值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置map写的标志</span></span><br><span class="line">  h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">  <span class="comment">//@Step3 buckets为nil，new一个</span></span><br><span class="line">  <span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123;</span><br><span class="line">    h.buckets = newobject(t.bucket) <span class="comment">// newarray(t.bucket, 1)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">  <span class="comment">//@Step4 找出key hash对应的桶</span></span><br><span class="line">  bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">  <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">    <span class="comment">//  @Step5 如果桶需要迁移，则把旧桶迁移</span></span><br><span class="line">    growWork(t, h, bucket)</span><br><span class="line">  &#125;</span><br><span class="line">  b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">  top := tophash(hash)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> inserti *<span class="type">uint8</span></span><br><span class="line">  <span class="keyword">var</span> insertk unsafe.Pointer</span><br><span class="line">  <span class="keyword">var</span> elem unsafe.Pointer</span><br><span class="line">  <span class="comment">//@Step6 寻找map中有没有存在的key</span></span><br><span class="line">  <span class="comment">//  5-1 如果存在，更新key的值，则返回val的位置</span></span><br><span class="line">  <span class="comment">//  5-2 如果不存在，则记录bucket最近一个空位置的tophash 、key、value的位置</span></span><br><span class="line">  <span class="comment">//  5-2-1 判断bucket有没有溢出，如果没有溢出，则下一步。</span></span><br><span class="line">  <span class="comment">//  5-2-2 溢出了则找出下一个溢出桶，继续bucketloop上述操作</span></span><br><span class="line">bucketloop:</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">        <span class="comment">//判断当前元素是否为空，如果为空，记录第一个为空的位置（方便找不到key时插入）</span></span><br><span class="line">        <span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">          inserti = &amp;b.tophash[i]</span><br><span class="line">          insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">          elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">          <span class="keyword">break</span> bucketloop</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">      <span class="keyword">if</span> !t.key.equal(key, k) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">      <span class="comment">//找到了key</span></span><br><span class="line">      <span class="keyword">goto</span> done</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在常规桶中没有找到数据，在溢出桶继续找</span></span><br><span class="line">    ovf := b.overflow(t)</span><br><span class="line">    <span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    b = ovf</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//@Step7 如果添加一个元素会造成bucket超过负载（6.5），或者溢出bucket太多</span></span><br><span class="line">  <span class="comment">//  扩充桶，返回上面逻辑bucketloop继续寻找val位置</span></span><br><span class="line">  <span class="comment">/// overLoadFactor函数用来判断map是否由于数据太多，需要增量1倍扩容</span></span><br><span class="line">  <span class="comment">//负载因子 &gt; 6.5时，也即平均每个bucket存储的键值对达到6.5个。</span></span><br><span class="line">  <span class="comment">//overflow数量 &gt; 2^15时，也即overflow数量超过32768时。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// tooManyOverflowBuckets函数用来判断map是否需要等量迁移，map由于删除操作，溢出bucket很多，但是数据分布很稀疏，我们可以通过等量迁移，将数据更加紧凑的存储在一起，节约空间</span></span><br><span class="line">  <span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">    hashGrow(t, h)</span><br><span class="line">    <span class="keyword">goto</span> again </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//@Step8 当前bucket和溢出桶都满了，重新添加一个溢出桶</span></span><br><span class="line">  <span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">    newb := h.newoverflow(t, b)</span><br><span class="line">    inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">    insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">    elem = add(insertk, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 储存key、tophash的位置。h.count +1</span></span><br><span class="line">  <span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">    kmem := newobject(t.key)</span><br><span class="line">    *(*unsafe.Pointer)(insertk) = kmem</span><br><span class="line">    insertk = kmem</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">    vmem := newobject(t.elem)</span><br><span class="line">    *(*unsafe.Pointer)(elem) = vmem</span><br><span class="line">  &#125;</span><br><span class="line">  typedmemmove(t.key, insertk, key)</span><br><span class="line">  *inserti = top</span><br><span class="line">  h.count++</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回val的位置</span></span><br><span class="line">done:</span><br><span class="line">  <span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  h.flags &amp;^= hashWriting</span><br><span class="line">  <span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">    elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> elem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><blockquote><p>1.每个 bucket 有 8 个空位，在没有溢出，且所有的桶都装满了的情况下，装载因子算出来的结果是 8。因此当装载因子超过 6.5 时，表明很多 bucket 都快要装满了，查找效率和插入效率都变低了。在这个时候进行扩容是有必要的。<br>2.在装载因子比较小的情况下，这时候 map 的查找和插入效率也很低，而第 1 点识别不出来这种情况。表面现象就是计算装载因子的分子比较小，即 map 里元素总数少，但是 bucket 数量多（真实分配的 bucket 数量多，包括大量的 overflow bucket）。​原因：不停地插入、删除元素。先插入很多元素，导致创建了很多 bucket，但是装载因子达不到第 1 点的临界值，未触发扩容来缓解这种情况。之后，删除元素降低元素总数量，再插入很多元素，导致创建很多的 overflow bucket，overflow bucket 数量太多，导致 key 会很分散，查找插入效率低得吓人。<br>对于命中条件 1，2 的限制，都会发生扩容。但是扩容的策略并不相同，毕竟两种条件应对的场景不同。​<br>对于 1，元素太多，而 bucket 数量太少，很简单：将 B 加 1，bucket 最大数量(2^B)直接变成原来 bucket 数量的 2 倍。于是，就有新老 bucket 了。注意，这时候元素都在老 bucket 里，还没迁移到新的 bucket 来。新 bucket 只是最大数量变为原来最大数量的 2 倍(2^B*2) 。​<br>对于条件 2，其实元素没那么多，但是 overflow bucket 数特别多，说明很多 bucket 都没装满。解决办法就是开辟一个新 bucket 空间，将老 bucket 中的元素移动到新 bucket，使得同一个 bucket 中的 key 排列地更紧密。这样，原来，在 overflow bucket 中的 key 可以移动到 bucket 中来。结果是节省空间，提高 bucket 利用率，map 的查找和插入效率自然就会提升。​<br>由于 map 扩容需要将原有的 key&#x2F;value 重新搬迁到新的内存地址，如果有大量的 key&#x2F;value 需要搬迁，会非常影响性能。因此 Go map 的扩容采取了一种称为“渐进式”的方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。</p></blockquote><p>map库容分为<strong>等量迁移和加倍扩容</strong>：等量迁移是为了让稀疏的数据分布更加紧凑（由于删除操作，map可能会很稀疏），加倍扩容是由于插入数据过多，申请一个加倍的空间来存储kv，同时加倍扩容也会删除空的槽位，让数据分布紧凑；<br>扩容后，B 增加了 1，意味着 buckets 总数是原来的 2 倍，原来 1 号的桶“裂变”到两个桶，某个 key 在搬迁前后 bucket 序号可能和原来相等，也可能是相比原来加上 2^B（原来的 B 值），取决于 hash 值 第 6 bit 位是 0 还是 1。原理看下图：</p><p><img src="https://img-blog.csdnimg.cn/ef20e9a978d64323b740b1fd21e59584.png" alt="在这里插入图片描述"></p><h3 id="删除key-value"><a href="#删除key-value" class="headerlink" title="删除key value"></a>删除key value</h3><p><strong>语法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>, key)</span><br></pre></td></tr></table></figure><p><strong>删除流程</strong><br>1 校验map是否为空，map是否正在写，如果是，则直接报”concurrent map writes”错误<br>2 设置写标志，计算key的哈希值<br>3 计算桶链首地址和tophash<br>4 找到桶链下的所有桶的元素，如果找到key，处理指针相关。<br>5 设置该位置的tophash值，这个逻辑比较复杂，详细会在tophash详解里面介绍<br>6 map总元素个数减1<br>7 清除写标志</p><p><img src="https://img-blog.csdnimg.cn/a81eef2e87ab4373b1fb7ef3e0f94b4e.png" alt="在这里插入图片描述"><br><strong>源码分析</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除key、val</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1.判断map是否处于写状态</span></span><br><span class="line">  <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 设置写标志，计算key的哈希值</span></span><br><span class="line">  hash := t.hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">  h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3 找出对应的桶位置</span></span><br><span class="line">  <span class="comment">//  如果需要迁移，继续迁移</span></span><br><span class="line">  bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">  <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">    growWork(t, h, bucket)</span><br><span class="line">  &#125;</span><br><span class="line">  b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">  bOrig := b</span><br><span class="line">  top := tophash(hash)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2</span></span><br><span class="line">  <span class="comment">//  2-1 找出tophash key val位置</span></span><br><span class="line">  <span class="comment">//  2-2 把tophash置为 emptyOne（当前位置为空，但后面还有元素）</span></span><br><span class="line">  <span class="comment">//  2-3 当前bucket后面没有元素，则置为emptyRest（当前位置为空，且后面没有元素）</span></span><br><span class="line">search:</span><br><span class="line">  <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">        <span class="keyword">if</span> b.tophash[i] == emptyRest &#123; <span class="comment">//如果发现对应的tophash已经是emptyRest状态，则标识后面没有数据了</span></span><br><span class="line">          <span class="keyword">break</span> search</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">      k2 := k</span><br><span class="line">      <span class="keyword">if</span> !t.key.equal(key, k2) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">      <span class="comment">//清除val</span></span><br><span class="line">      <span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">        *(*unsafe.Pointer)(e) = <span class="literal">nil</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.elem.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">        memclrHasPointers(e, t.elem.size)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        memclrNoHeapPointers(e, t.elem.size)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 把tophash置为 emptyOne（当前位置为空，但后面还有元素）</span></span><br><span class="line">      b.tophash[i] = emptyOne</span><br><span class="line">      <span class="comment">//3 判断下一个位置（可能是溢出桶第一个）tophash是不是emptyRest</span></span><br><span class="line">      <span class="comment">//  3-1 如果不是，直接到notLast结束流程</span></span><br><span class="line">      <span class="comment">//  3-2 如果是，往前搜索，把所有emptyOne置为emptyRest</span></span><br><span class="line">      <span class="keyword">if</span> i == bucketCnt<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> b.overflow(t) != <span class="literal">nil</span> &amp;&amp; b.overflow(t).tophash[<span class="number">0</span>] != emptyRest &#123;</span><br><span class="line">          <span class="keyword">goto</span> notLast</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> b.tophash[i+<span class="number">1</span>] != emptyRest &#123;</span><br><span class="line">          <span class="keyword">goto</span> notLast</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> &#123;</span><br><span class="line">        b.tophash[i] = emptyRest</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> b == bOrig &#123;</span><br><span class="line">            <span class="keyword">break</span> </span><br><span class="line">          &#125;</span><br><span class="line">          c := b</span><br><span class="line">          <span class="keyword">for</span> b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">          i = bucketCnt - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          i--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> b.tophash[i] != emptyOne &#123;</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    notLast:</span><br><span class="line">      <span class="comment">//数量减1</span></span><br><span class="line">      h.count--</span><br><span class="line">      <span class="keyword">break</span> search</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map查找"><a href="#map查找" class="headerlink" title="map查找"></a>map查找</h3><p> <strong>语法</strong></p><ul><li>第一种用法，只返回value值，当key在map中没有找到时，返回value对应类型的默认值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="built_in">print</span>(m[<span class="string">&quot;1&quot;</span>]) -- 结果为: <span class="number">0</span> (返回<span class="type">int</span>对应的默认值)</span><br></pre></td></tr></table></figure><ul><li><p>第二种用法，返回value值以及key是否存在标志</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">val, ok := m[<span class="string">&quot;1&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(val, ok)  -- 结果为：<span class="number">0</span>, <span class="literal">false</span> </span><br></pre></td></tr></table></figure></li><li><p>第三种用法，返回key和value，只用于range迭代场景</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>整体思路</strong><br><img src="https://img-blog.csdnimg.cn/7bd94f3fe75e49e0bf691f24c0d3a03c.png" alt="在这里插入图片描述"></p></li></ul><p>校验map是否正在写，如果是，则直接报”concurrent map read and map write”错误<br>计算key哈希值，并根据哈希值计算出key所在桶链位置<br>如果map正在扩（等量）容且该桶还未被迁移，定位到旧桶的位置<br>计算tophash值，便于快速查找<br>遍历桶链上的每一个桶，并依次遍历桶内的元素<br>先比较tophash，如果tophash不一致，再比较下一个，如果tophash一致，再比较key值是否相等<br>如果key值相等，计算出value的地址，并取出value值，并直接返回<br>如果key值不相等，则继续比较下一个元素，如果所有元素都不匹配，则直接返回value类型的默认值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 判断是否正在写，如果是直接报错</span></span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算key哈希值</span></span><br><span class="line">alg := t.key.alg</span><br><span class="line">hash := alg.hash(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如 B=5，那 m 就是31，二进制是全 1</span></span><br><span class="line">    <span class="comment">// 求 bucket num 时，将 hash 与 m 相与，</span></span><br><span class="line">    <span class="comment">// 达到 bucket num 由 hash 的低 8 位决定的效果</span></span><br><span class="line">    <span class="comment">//假如 B=5 低5的值就是通的位置，即10。</span></span><br><span class="line">    <span class="comment">// 10010111 | 000011110110110010001111001010100010010110010101010 │ 01010</span></span><br><span class="line">m := bucketMask(h.B)</span><br><span class="line">b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="comment">// 计算tophash值  高8位就是对应的tophash值 10010111--&gt;151,ophash 值（HOB hash）为 151 的 key</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断有没有旧桶（正在迁移）</span></span><br><span class="line">  <span class="comment">//  如果旧桶数据没有被迁移，定位到当前key在旧桶的位置</span></span><br><span class="line">  <span class="comment">//  如果当前旧桶没有被迁移，则迁移桶</span></span><br><span class="line">  <span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !h.sameSizeGrow() &#123; </span><br><span class="line">    <span class="comment">// 新 bucket 数量是老的 2 倍</span></span><br><span class="line">      m &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  求出 key 在老的 map 中的 bucket 位置</span></span><br><span class="line">    oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">    <span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">      b = oldb</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">top := tophash(hash)</span><br><span class="line">bucketloop:</span><br><span class="line"><span class="comment">// 遍历桶链每个桶  从bucket中找出key对应的val，循环遍历top hash</span></span><br><span class="line"><span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123; </span><br><span class="line">    <span class="comment">// 遍历桶的元素</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line"><span class="comment">// 如果tophash不相等，continue</span></span><br><span class="line"><span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line"><span class="comment">// 如果top hash为emptyRest，则表示后面没数据了</span></span><br><span class="line"><span class="keyword">if</span> b.tophash[i] == emptyRest &#123; </span><br><span class="line"><span class="keyword">break</span> bucketloop</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tophash相等</span></span><br><span class="line"><span class="comment">// 获取当前位置对应的key值</span></span><br><span class="line">k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line"><span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">k = *((*unsafe.Pointer)(k))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果与key匹配，表明找到了，直接返回value值</span></span><br><span class="line"><span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.valuesize))</span><br><span class="line"><span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">v = *((*unsafe.Pointer)(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一直没有找到，返回value类型的默认值</span></span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历-mapiterinit"><a href="#遍历-mapiterinit" class="headerlink" title="遍历  mapiterinit"></a>遍历  mapiterinit</h3><p><strong>为什么map是无序的？​</strong><br>遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。这样，遍历 map 的结果就不可能按原来的顺序了。<br>hash表中数据每次插入的位置是变化的（其实是因为实现的原因，一方面hash种子是随机的，这导致相同的数据在不同的map变量内的hash值不同；另一方面即使同一个map变量内，数据删除再添加的位置也有可能变化，因为在同一个桶及溢出链表中数据的位置不分先后），所以为了防止用户错误的依赖于每次迭代的顺序。</p><p><strong>整体流程</strong></p><ul><li>从hash数组中第it.startBucket个桶开始，先遍历hash桶，然后是这个桶的溢出链表。<br>之后hash数组偏移量+1，继续前一步动作。</li><li>遍历每一个桶，无论是hash桶还是溢出桶，都从it.offset偏移量开始。（如果只是随机一个开始的桶，range结果还是有序的；但每个桶都加it.offset偏移，这个输出结果就有点扑朔迷离，大家可以亲手试下，对同一个map多次range）</li><li>当迭代器经过一轮循环回到it.startBucket的位置，结束遍历。<br><img src="https://img-blog.csdnimg.cn/1e7f667a323f4427897344b1004f2574.png" alt="在这里插入图片描述"></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiterinit</span><span class="params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;</span><br><span class="line">  <span class="comment">//1 初始化迭代器</span></span><br><span class="line">  it.t = t</span><br><span class="line">  <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  it.h = h</span><br><span class="line">  it.B = h.B</span><br><span class="line">  it.buckets = h.buckets</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2 给一个随机数，决定迭代桶的开始位置和桶内开始迭代的顺序</span></span><br><span class="line">  r := <span class="type">uintptr</span>(fastrand())</span><br><span class="line">  <span class="keyword">if</span> h.B &gt; <span class="number">31</span>-bucketCntBits &#123;</span><br><span class="line">    r += <span class="type">uintptr</span>(fastrand()) &lt;&lt; <span class="number">31</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//it.startBucket：这个是hash数组的偏移量，表示遍历从这个桶开始</span></span><br><span class="line">   <span class="comment">//it.offset：这个是桶内的偏移量，表示每个桶的遍历都从这个偏移量开始</span></span><br><span class="line">  it.startBucket = r &amp; bucketMask(h.B)          <span class="comment">//桶的偏移量</span></span><br><span class="line">  it.offset = <span class="type">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>)) <span class="comment">//桶内偏移量</span></span><br><span class="line"></span><br><span class="line">  it.bucket = it.startBucket</span><br><span class="line">  ....</span><br><span class="line">   mapiternext(it) <span class="comment">// 初始化迭代器的同时也返回第1对key/value</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器迭代</span></span><br><span class="line"><span class="comment">//  1 从随机偏移桶循环迭代每个桶数据</span></span><br><span class="line"><span class="comment">//  2 桶内从随机偏移量开始遍历</span></span><br><span class="line"><span class="comment">//  3 列出该方法隐掉了当正在进行扩容时怎么迭代，需要了解参考源码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiternext</span><span class="params">(it *hiter)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123; <span class="comment">//有协程正在写</span></span><br><span class="line">    throw(<span class="string">&quot;concurrent map iteration and map write&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  t := it.t</span><br><span class="line">  bucket := it.bucket</span><br><span class="line">  b := it.bptr</span><br><span class="line">  i := it.i</span><br><span class="line">  checkBucket := it.checkBucket</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">  <span class="keyword">if</span> b == <span class="literal">nil</span> &#123; <span class="comment">//当前桶指针为nil，标识桶内数据已经遍历完成，需要遍历下一个桶</span></span><br><span class="line">    <span class="keyword">if</span> bucket == it.startBucket &amp;&amp; it.wrapped &#123; <span class="comment">//已经遍历到开始的桶</span></span><br><span class="line">      it.key = <span class="literal">nil</span></span><br><span class="line">      it.elem = <span class="literal">nil</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    bucket++</span><br><span class="line">    <span class="keyword">if</span> bucket == bucketShift(it.B) &#123;</span><br><span class="line">      bucket = <span class="number">0</span></span><br><span class="line">      it.wrapped = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ; i &lt; bucketCnt; i++ &#123;</span><br><span class="line">    offi := (i + it.offset) &amp; (bucketCnt - <span class="number">1</span>) <span class="comment">//从桶内哪个位置开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty &#123;<span class="comment">//没数据</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    k := add(unsafe.Pointer(b), dataOffset+<span class="type">uintptr</span>(offi)*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">    e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+<span class="type">uintptr</span>(offi)*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">  b = b.overflow(t)</span><br><span class="line">  i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">goto</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代还需要关注扩容缩容的情况：<br>如果是在迭代开始后才growing，这种情况当前的逻辑没处理，迭代有可能异常。呃，go map不支持并发。<br>如果是先growing，再开始迭代，这是有可能的。这种情况下，会先到旧hash表中检查key对应的桶有没有被疏散，未疏散则遍历旧桶，已疏散则遍历新hash表里对应的桶。</p><h3 id="go-map的扩容缩容"><a href="#go-map的扩容缩容" class="headerlink" title="go map的扩容缩容"></a>go map的扩容缩容</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// overLoadFactor()返回true则触发扩容，即map的count大于hash桶数量(2^B)*6.5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="type">int</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="type">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tooManyOverflowBuckets()，顾名思义，溢出桶太多了触发缩容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="type">uint16</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">B = <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> noverflow &gt;= <span class="type">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map只在插入元素即mapassign()函数中对是否扩容缩容进行触发，条件即是上面这段代码：</p><ul><li>条件1：当前不处在growing状态</li><li>条件2-1：触发扩容：map的数据量count大于hash桶数量(2B)*6.5。注意这里的(2B)只是hash数组大小，不包括溢出的桶</li><li>条件2-2：触发缩容：溢出的桶数量noverflow&gt;&#x3D;32768(1&lt;&lt;15)或者&gt;&#x3D;hash数组大小。<br>仔细观察触发的代码，扩容和缩容是同一个函数，这是怎么做到的呢？在hashGrow()开始，会先判断是否满足扩容条件，如果满足就表明这次是扩容，不满足就一定是缩容条件触发了。扩容和缩容剩下的逻辑，主要区别就在于容量变化，就是hmap.B参数，扩容时B+1则hash表容量扩大1倍，缩容时hash表容量不变。</li><li>h.oldbuckets：指向旧的hash数组，即当前的h.buckets</li><li>h.buckets：指向新创建的hash数组</li></ul><p>触发的主要工作已经完成，接下来就是怎么把元素搬迁到新hash表里了。如果现在就一次全量搬迁过去，显然接下来会有比较长的一段时间map被占用（不支持并发）。所以搬迁的工作是异步增量搬迁的。<br>在插入和删除的函数内都有下面一段代码用于在每次插入和删除操作时，执行一次搬迁工作.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> h.growing() &#123; <span class="comment">// 当前处于搬迁状态</span></span><br><span class="line">growWork(t, h, bucket) <span class="comment">// 调用搬迁函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 将当前需要处理的桶搬迁</span></span><br><span class="line">evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> h.growing() &#123; <span class="comment">// 再多搬迁一个桶</span></span><br><span class="line">evacuate(t, h, h.nevacuate)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每执行一次插入或删除，都会调用growWork搬迁0~2个hash桶（有可能这次需要搬迁的2个桶在此之前都被搬过了）</li><li>搬迁是以hash桶为单位的，包含对应的hash桶和这个桶的溢出链表</li><li>被delete掉的元素(emptyone标志)会被舍弃（这是缩容的关键）</li></ul><p><strong>为什么叫“伪缩容”？如何实现“真缩容”？</strong><br>因为缩容仅仅针对<strong>溢出桶太多</strong>的情况，触发缩容时hash数组的大小不变，即hash数组所占用的空间只增不减。也就是说，如果我们把一个已经增长到很大的map的元素挨个全部删除掉，hash表所占用的内存空间也不会被释放。所以如果要实现“真缩容”，需自己实现缩容搬迁，即创建一个较小的map，将需要缩容的map的元素挨个搬迁过来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go map缩容代码示例</span></span><br><span class="line">myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这里我们对bigMap做了很多次插入，之后又做了很多次删除，此时bigMap的元素数量远小于hash表大小</span></span><br><span class="line"><span class="comment">// 接下来我们开始缩容</span></span><br><span class="line">smallMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="built_in">len</span>(myMap))</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">    smallMap[k] = v</span><br><span class="line">&#125;</span><br><span class="line">myMap = smallMap <span class="comment">// 缩容完成，原来的map被我们丢弃，交给gc去清理</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>关键知识点</strong></p><p>5.1 基本原理</p><ul><li>底层是hash实现，数据结构为hash数组 + 桶 + 溢出的桶链表，每个桶存储最多8个key-value对。</li><li>查找和插入的原理：key的hash值（低阶位）与桶数量相与，得到key所在的hash桶，再用key的高8位与桶中的tophash[i]对比，相同则进一步对比key值，key值相等则找到</li><li>go map不支持并发。插入、删除、搬迁等操作会置writing标志，检测到并发直接panic</li><li>每次扩容hash表增大1倍，hash表只增不减</li><li>支持有限缩容，delete操作只置删除标志位，释放溢出桶的空间依靠触发缩容来实现。</li><li>map在使用前必须初始化，否则panic：已初始化的map是make(map[key]value)或make(map[key]value, hint)这两种形式。而new或var xxx map[key]value这两种形式是未初始化的，直接使用会panic。</li></ul><p>5.2 时间复杂度和空间复杂度分析<br>时间复杂度，go map是hash实现：</p><ul><li>正常情况，且<strong>不考虑扩容状态</strong>，复杂度O(1)：通过hash值定位桶是O(1)，一个桶最多8个元素，合理的hash算法应该能把元素相对均匀散列，所以溢出链表（如果有）也不会太长，所以虽然在桶和溢出链表上定位key是遍历，考虑到数量小也可以认为是O(1)</li><li>正常情况，处于<strong>扩容状态时</strong>，复杂度也是O(1)：相比于上一种状态，扩容会增加搬迁最多2个桶和溢出链表的时间消耗，当溢出链表不太长时，复杂度也可以认为是O(1)</li><li>极端情况，散列极不均匀，大部分数据被集中在一条散列链表上，复杂度退化为O(n)。<br>所以综合情况下go map的时间复杂度应为O(1)</li></ul><p>空间复杂度分析：<br>首先我们不考虑因删除大量元素导致的空间浪费情况（这种情况现在go是留给程序员自己解决），只考虑一个持续增长状态的map的一个空间使用率：<br>由于溢出桶数量超过hash桶数量时会触发缩容，所以最坏的情况是数据被集中在一条链上，hash表基本是空的，这时空间浪费O(n)。<br>最好的情况下，数据均匀散列在hash表上，没有元素溢出，这时最好的空间复杂度就是扩散因子决定了，当前go的扩散因子由全局变量决定，即loadFactorNum&#x2F;loadFactorDen &#x3D; 6.5。即平均每个hash桶被分配到6.5个元素以上时，开始扩容。所以最小的空间浪费是(8-6.5)&#x2F;8 &#x3D; 0.1875，即O(0.1875n)<br>结论：go map的空间复杂度（指除去正常存储元素所需空间之外的空间浪费）是O(0.1875n) ~ O(n)之间。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-泛型基础篇（二）</title>
      <link href="/2022/10/27/golang/golang-%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/10/27/golang/golang-%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇文章中介绍了 golang中泛型的定义，泛型结构体，部分错误的泛型写法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStruct[T <span class="type">int</span> | <span class="type">string</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data     []T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>匿名结构体不支持泛型</code>。<br>原因（个人理解）：定义泛型，相当于定义新的类型，然后对其进行初始化。使用匿名结构体时，定义好匿名结构体之后直接初始化，相当于每次定义一个新的结构体类型进行初始化。不太符合泛型的要求。</p><h2 id="泛型receiver"><a href="#泛型receiver" class="headerlink" title="泛型receiver"></a>泛型receiver</h2><p>定义了新的普通类型之后可以给类型添加方法。那么可以给泛型类型添加方法吗？答案是可以的，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MySlice[T <span class="type">int</span> | <span class="type">float32</span>] []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s MySlice[T])</span></span> Sum() T &#123;</span><br><span class="line"><span class="keyword">var</span> sum T</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSlice</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mySlice = MySlice[<span class="type">int</span>]&#123;&#125;</span><br><span class="line">mySlice = <span class="built_in">append</span>(mySlice, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;...)</span><br><span class="line">fmt.Println(mySlice.Sum())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>泛型receiver</code>的实用性。在没有泛型之前如果想实现通用的数据结构，诸如：堆、栈、队列、链表之类的话，我们的选择只有两个：</p><ul><li>为每种类型写一个实现（每个类型写一次，代码量大）</li><li>使用 接口+反射(反射效率低)</li></ul><h3 id="基于泛型的队列"><a href="#基于泛型的队列" class="headerlink" title="基于泛型的队列"></a>基于泛型的队列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于泛型的队列</span></span><br><span class="line"><span class="keyword">type</span> MyQueue[T <span class="keyword">interface</span>&#123;&#125;] <span class="keyword">struct</span> &#123;</span><br><span class="line">elements []T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyQueue[T])</span></span> Push(value T) &#123;</span><br><span class="line">q.elements = <span class="built_in">append</span>(q.elements, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyQueue[T])</span></span> Pop() (value T, isEmtry <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(q.elements) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">value = q.elements[<span class="number">0</span>]</span><br><span class="line">q.elements = q.elements[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">return</span> value, <span class="built_in">len</span>(q.elements) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q MyQueue[T])</span></span> Size() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(q.elements)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于泛型的栈"><a href="#基于泛型的栈" class="headerlink" title="基于泛型的栈"></a>基于泛型的栈</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于泛型的栈</span></span><br><span class="line"><span class="keyword">type</span> MyStack[T <span class="keyword">interface</span>&#123;&#125;] <span class="keyword">struct</span> &#123;</span><br><span class="line">elements []T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyStack[T])</span></span> Push(value T) &#123;</span><br><span class="line">q.elements = <span class="built_in">append</span>(q.elements, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyStack[T])</span></span> Pull() (value T, isEmtry <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(q.elements) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">value = q.elements[<span class="built_in">len</span>(q.elements)<span class="number">-1</span>]</span><br><span class="line">q.elements = q.elements[:<span class="built_in">len</span>(q.elements)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> value, <span class="built_in">len</span>(q.elements) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q MyStack[T])</span></span> Size() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(q.elements)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="泛型不能进行类型断言"><a href="#泛型不能进行类型断言" class="headerlink" title="泛型不能进行类型断言"></a>泛型不能进行类型断言</h2><p>对于<code>interface</code>类型的参数，可以对其进行类型断言,然后不同类型做出不同处理呢。对于<code>T</code>这样通过类型形参定义的变量，<strong>我们不能判断具体类型</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue[T])</span></span> Put(value T) &#123;</span><br><span class="line">    value.(<span class="type">int</span>) <span class="comment">// 错误。泛型类型定义的变量不能使用类型断言</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误。不允许使用type switch 来判断 value 的具体类型</span></span><br><span class="line">    <span class="keyword">switch</span> value.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然<code>泛型</code>和<code>类型断言</code>一起不能用，但我们可通过反射机制达到目的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver Queue[T])</span></span> Put(value T) &#123;</span><br><span class="line">    <span class="comment">// Printf() 可输出变量value的类型(底层就是通过反射实现的)</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T&quot;</span>, value) </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射可以动态获得变量value的类型从而分情况处理</span></span><br><span class="line">    v := reflect.ValueOf(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Int:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你写出上面这样的代码时候就出现了一个问题：<br><strong>你为了避免使用反射而选择了泛型，结果到头来又为了一些功能在在泛型中使用反射</strong>。当出现这种情况的时候你可能需要重新思考一下，自己的需求是不是真的需要用泛型。</p><h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><p>泛型函数在第一篇介绍过写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">float32</span> | <span class="title">float64</span>]<span class="params">(a T, b T)</span></span> T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestADD</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法1</span></span><br><span class="line">    fmt.Println(Add[](<span class="number">10</span>, <span class="number">20</span>）)</span><br><span class="line">    <span class="comment">//写法2</span></span><br><span class="line">fmt.Println(Add[<span class="type">int</span>](<span class="number">100</span>, <span class="number">200</span>))</span><br><span class="line">fmt.Println(Add[<span class="type">float64</span>](<span class="number">10.5</span>, <span class="number">24.6</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和泛型类型一样，泛型函数也是不能直接调用的，要使用泛型函数的话必须传入类型实参之后才能调用。<br><strong>匿名函数不支持泛型</strong>：匿名函数不能自己定义类型形参。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误，匿名函数不能自己定义类型实参</span></span><br><span class="line">fnGeneric := <span class="function"><span class="keyword">func</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">float32</span>]<span class="params">(a, b T)</span></span> T &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">fmt.Println(fnGeneric(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>go里面不止有函数还有方法。有泛型函数，有没有泛型方法呢？结果：<strong>目前Go的方法并不支持泛型</strong>。但是因为<code>receiver</code>支持泛型， 所以如果想在方法中使用泛型的话，我们可以这样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A[T <span class="type">int</span> | <span class="type">float32</span> | <span class="type">float64</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法可以使用类型定义中的形参 T </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver A[T])</span></span> Add(a T, b T) T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="keyword">var</span> a A[<span class="type">int</span>]</span><br><span class="line">a.Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aa A[<span class="type">float32</span>]</span><br><span class="line">aa.Add(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p>个人理解：函数主要针对传参进行操作，方法可以针对<code>receiver</code>进行操作。如果传入一个泛型的参数赋值给一个非泛型<code>receiver</code>的属性，可能会报错( 如：int  value in variable)。所以不支持泛型方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go的泛型(或者或类型形参)目前可使用在3个地方</p><ul><li>泛型类型 - 类型定义中带类型形参的类型</li><li>泛型<code>receiver</code> - 泛型类型的<code>receiver</code></li><li>泛型函数 - 带类型形参的函数</li><li>没有匿名的泛型类型（匿名结构体，匿名方法）</li><li>没有泛型的方法，但是泛型方法可以通过泛型<code>receiver</code>+泛型参数来实现。</li><li>泛型类型不能直接使用，要使用的话必须传入类型实参进行实例化</li></ul>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-内存管理篇（一） TCMalloc</title>
      <link href="/2022/10/27/golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Tcmalloc/"/>
      <url>/2022/10/27/golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Tcmalloc/</url>
      
        <content type="html"><![CDATA[<h2 id="1-内存为什么需要管理"><a href="#1-内存为什么需要管理" class="headerlink" title="1.内存为什么需要管理"></a>1.内存为什么需要管理</h2><p>我们知道<strong>处理速度与存储容量</strong>是成反比的。也就是说，性能越大的计算机硬件资源，越是稀缺，所以合理的利用和分配就越重要。大部分程序逻辑临时用的数据，全部都存在内存之中，比如，变量、全局变量、函数跳转地址、静态库、临时开辟的内存结构体（对象）等。当存储的东西越来越多，也就发现物理内存的容量依然是不够用，那么对物理内存的利用率和合理的分配，管理就变得非常的重要。<br>Golang编程语言给开发者提供了一套内存管理模式，所以开发者有必要了解一下Golang做了哪些助力的功能。</p><h2 id="2-TcMalloc是什么"><a href="#2-TcMalloc是什么" class="headerlink" title="2.TcMalloc是什么?"></a>2.TcMalloc是什么?</h2><p>Go内存管理是基于<code>TCMalloc</code>基础上进行设计的，所以在学习Go内存管理之前先学习<code>TCMalloc</code>原理。<br>TCMalloc(Thread Cache Malloc)是线程级别的内存管理模式。<code>TCMalloc</code>是用来替代<strong>传统的malloc内存分配函数</strong>。它有<strong>减少内存碎片，适用于多核</strong>，更好的并行性支持等特性。</p><h2 id="3-TcMalloc分配原则"><a href="#3-TcMalloc分配原则" class="headerlink" title="3.TcMalloc分配原则"></a>3.TcMalloc分配原则</h2><p><img src="https://img-blog.csdnimg.cn/4e8d3679c618474794736c44117b8f4d.png" alt="在这里插入图片描述"><br><code>TCMalloc</code>则是为<strong>每个Thread预分配一块缓存</strong>，每个Thread在申请内存时首先会先从这个缓存区<strong>ThreadCache</strong>申请，且所有<code>ThreadCache</code>缓存区还共享一个叫<strong>CentralCache的中心缓存</strong>。<br>好处：</p><ul><li><code>ThreadCache</code>做为每个线程独立的缓存，能够明显的提高Thread获取高命中的数据</li><li><code>ThreadCache</code>也是从堆空间一次性申请，即只触发一次系统调用即可。</li></ul><p><strong>CentralCache是所有线程共享的缓存</strong>，当<code>ThreadCache</code>的缓存不足时，就会从<code>CentralCache</code>获取，当<code>ThreadCache</code>的缓存充足或者过多时，则会将内存退还给<code>CentralCache</code>。但是<code>CentralCache</code>由于共享，那么访问一定是需要加锁的。<strong>ThreadCache作为线程独立的第一交互内存，访问无需加锁</strong>，<code>CentralCache</code>则作为<code>ThreadCache</code>临时补充缓存。<code>ThreadCache</code>和<code>CentralCache</code>可以解决<strong>小对象</strong>内存块的申请。</p><p><img src="https://img-blog.csdnimg.cn/3ea8159cc4a64f3a8a35fbdf6c9c07c6.png" alt="在这里插入图片描述"></p><p>为了解决中对象和大对象的内存申请，<code>TCMalloc</code>依然有一个全局共享内存堆<code>PageHeap</code>。<br><code>PageHeap</code>也是一次系统调用从虚拟内存中申请的，<code>PageHeap</code>很明显是全局的，所以访问一定是要加锁。<code>PageHeap</code>发现也没有内存的时候,会向OS申请内存。<br>作用:</p><ul><li>当<code>CentralCache</code>没有足够内存时会从<code>PageHeap</code>取，当<code>CentralCache</code>内存过多或者充足，则将低命中内存块退还<code>PageHeap</code>。</li><li>Thread需要大对象申请超过的Cache容纳的内存块单元大小，也会直接从<code>PageHeap</code>获取。</li></ul><p><strong>TCMalloc优势：</strong><br>1、速度快<br>2、减少锁竞争。对于小对象，只有在对应线程分配的空闲块不足的时候，才会使用到锁；对于大对象，TCMalloc尝试使用有效的自旋锁。</p><h2 id="4-对象的分类"><a href="#4-对象的分类" class="headerlink" title="4.对象的分类"></a>4.对象的分类</h2><table><thead><tr><th>对象</th><th>容量</th></tr></thead><tbody><tr><td>小对象</td><td>(0,256KB]</td></tr><tr><td>中对象</td><td>(256KB, 1MB]</td></tr><tr><td>大对象</td><td>(1MB, +∞)</td></tr></tbody></table><h2 id="5-TCMalloc模型相关基础结构"><a href="#5-TCMalloc模型相关基础结构" class="headerlink" title="5.TCMalloc模型相关基础结构"></a>5.TCMalloc模型相关基础结构</h2><h3 id="5-1-Page"><a href="#5-1-Page" class="headerlink" title="5.1.Page"></a>5.1.Page</h3><p><code>Pages</code>是<code>TCMalloc</code>管理的内存基本单位，默认大小是8KB。</p><h3 id="5-2-Span"><a href="#5-2-Span" class="headerlink" title="5.2.Span"></a>5.2.Span</h3><p><code>Span</code>是<code>PageHeap</code>中管理内存页的单位，它是由一组连续的Page组成，TCMolloc以span为单位向系统申请内存。<code>span</code>是由<code>PageHeap</code>进行管理的，可以被拆分成多个相同的<code>page size</code>用于小对象使用；也可以作为一个整体被中大对象进行使用。Span可用于管理已移交给应用程序的大对象(多个Page组成的大对象)，或已拆分为一系列小对象的一组页面(一个或多个<code>Page</code>被<code>Size-Class</code>拆分固定大小的Object链表)。如果Span管理的是小对象，则会在Span中记录对象的Size-Class信息。<br><img src="https://img-blog.csdnimg.cn/150bc268b1b54578ade459836a20e021.png" alt="在这里插入图片描述"></p><h3 id="5-3-Size-Class"><a href="#5-3-Size-Class" class="headerlink" title="5.3.Size-Class"></a>5.3.Size-Class</h3><p><img src="https://img-blog.csdnimg.cn/19ee9897709b4232b120a045a93270d8.png" alt="在这里插入图片描述"></p><p>由<code>Span</code>分裂出的对象，由<strong>同一个Span分裂出的SizeClass大小相同</strong>，<code>SizeClass</code>是对象内存实际的载体。小对象的分配被映射到不同大小的<code>Size-class</code>类型上。例如，一个12字节的分配将被四舍五入到16字节Size-class。Size-class的设计是为了在舍入到下一个最大的size类时尽量减少浪费的内存量。</p><h3 id="5-4-ThreadCache"><a href="#5-4-ThreadCache" class="headerlink" title="5.4.ThreadCache"></a>5.4.ThreadCache</h3><p><img src="https://img-blog.csdnimg.cn/02d5e6f4ca0b4564bbf16cee0a419238.png" alt="在这里插入图片描述"><br><code>ThreadCache</code>中对于每个<code>Size Class</code>都会有一个对应的<code>FreeList，FreeList</code>表示当前缓存中还有多少个空闲的内存可用。使用方对于从<code>TCMalloc</code>申请的小对象，会直接从<strong>TreadCache</strong>获取，实则是从FreeList中返回一个空闲的对象，如果对应的Size Class刻度下已经没有空闲的Span可以被获取了，则<code>ThreadCache</code>会从<code>CentralCache</code>中获取。当使用方使用完内存之后，归还也是直接归还给当前的<code>ThreadCache</code>中对应刻度下的的<code>FreeList</code>中。</p><h3 id="5-5-CentralCache"><a href="#5-5-CentralCache" class="headerlink" title="5.5.CentralCache"></a>5.5.CentralCache</h3><p><code>CentralCache</code>是各个线程共用的，所以与CentralCache获取内存交互是需要加锁的。CentralCache缓存的<code>Size Class</code>和<code>ThreadCache</code>的一样，这些缓存都被放在<code>Central Free List</code>中。<code>Central Free List</code>是当<code>ThreadCache</code>内存不足时,提供内存供<code>ThreadCache</code>使用。每种规格的<code>Size-Class</code>,都从不同的 <code>Span</code> 进行分配;每种规则的<code>Size-class</code>都有一个独立的内存分配单元。每一个<code>size-class</code>都会关联一个<code>span List</code>,这个list中所有<code>span</code>的大小都是相同的,每个span都已经被拆分为对应的<code>size-class</code>。</p><h3 id="5-6-PageHeap"><a href="#5-6-PageHeap" class="headerlink" title="5.6.PageHeap"></a>5.6.PageHeap</h3><p><code>PageHeap</code>是提供<code>CentralCache</code>的内存来源。<code>PageHead</code>与<code>CentralCache</code>不同的是<code>CentralCache</code>是与<code>ThreadCache</code>布局一模一样的缓存，主要是起到针对<code>ThreadCache</code>的一层二级缓存作用，且只支持小对象内存分配。而<code>PageHeap</code>则是针对<code>CentralCache</code>的三级缓存。弥补对于中对象内存和大对象内存的分配，<code>PageHeap</code>也是直接和操作系统虚拟内存衔接的一层缓存，当ThreadCache、CentralCache、PageHeap都找不到合适的Span，PageHeap则会调用操作系统内存申请系统调用函数来从虚拟内存的堆区中取出内存填充到PageHeap当中。小于等于128 list都按照链表来进行缓存管理；超过128的存储在一个有序的set。<br>作用</p><ul><li>管理未使用的内存。</li><li>当没有合适大小的可用内存来满足分配请求时, 它负责从操作系统获取内存。</li><li>将不需要的内存返回给操作系统。<br><img src="https://img-blog.csdnimg.cn/8a3f63e126824661a95134647a0faac2.png" alt="在这里插入图片描述"></li></ul><h3 id="5-7-内存回收"><a href="#5-7-内存回收" class="headerlink" title="5.7.内存回收"></a>5.7.内存回收</h3><p>上面说的都是内存分配，内存回收的情况是怎样的？</p><p>应用程序调用free()或delete一个小对象时，仅仅是将其插入到ThreadCache中其size class对应的FreeList中而已，不需要加锁，因此速度也是非常快的。</p><p>只有当满足一定的条件时，<code>ThreadCache</code>中的空闲对象才会重新放回<code>CentralCache</code>中，以供其他线程取用。同样的，当满足一定条件时，<code>CentralCache</code>中的空闲对象也会还给<code>PageHeap</code>，<code>PageHeap</code>再还给系统。</p><h3 id="5-8-小结"><a href="#5-8-小结" class="headerlink" title="5.8.小结"></a>5.8.小结</h3><p>小对象分配流程大致如下：</p><ul><li>将要分配的内存大小映射到对应的<code>size class</code>。</li><li>查看<code>ThreadCache</code>中该<code>size class</code>对应的<code>FreeList</code>。<ul><li>如果<code>Free List</code>非空，则移除<code>Free List</code>的第一个空闲对象并将其返回，分配结束。</li><li>如果<code>Free List</code>是空的：<ul><li>从<code>CentralCache</code>中<code>size class</code>对应的<code>Central Free List </code>获取一堆空闲对象。</li><li>如果<code>Central Free List</code>也是空的，则向<code>PageHeap</code>申请一个<code>span</code>。拆分成<code>size class</code>对应大小的空闲对象，放入<code>Central Free List </code>中。</li></ul></li><li>将这堆对象放置到<code>ThreadCache</code>中<code>size class</code>对应的<code>FreeList</code>中（第一个对象除外）。</li><li>返回从<code>CentralCache</code>获取的第一个对象，分配结束。</li></ul></li></ul><h2 id="6-内存碎片处理"><a href="#6-内存碎片处理" class="headerlink" title="6.内存碎片处理"></a>6.内存碎片处理</h2><p>内存碎片就是不能再分配给应用使用。分配<strong>内部碎片和外部碎片</strong>，内部碎片就是内部碎片是分配器分配的内存大于程序申请的内存，内部产生碎片；外部碎片就是内存块太小，不足以分配给应用使用。<br>对于TCMalloc是怎么处理内部碎片和外部碎片的？<br>内部碎片：TCMalloc提前分配了多种size-class：8， 16， 32， 48， 64， 80， 96， 112， 128， 144， 160， 176…<br>TCMalloc的目标就是产生最多12.5%的内存碎片。可以看到上面不是按照2的幂级数分配的大小，这是因为如果按照2的幂产生的碎片会更大。比如申请65字节，2幂申请的话会分配128，而按照TCMalloc只分配80，相应的减少了很多碎片。</p><ul><li>16字节以内，每8字节划分一个size class：8,16</li><li>16~128字节，每16字节划分一个size class：32,48,64…</li><li>128B~256字节，按照每次增加x&#x2F;8进行增加：128+128&#x2F;8&#x3D;144 以此类推</li><li>大于大于1024的 size-class 其实都以128对齐：</li></ul><p>外部碎片：<br><code>TCMalloc</code>的<code>CentralCache</code>向<code>PageHeap</code>申请内存的时候，是以<code>Page</code>为单位进行申请的。当申请1024的时候，<br>page(8192)%1024&#x3D;0没有内存碎片，当时当申请class-size为1152的时候（8192%1152&#x3D;128）产生128的外部碎片，为了使得内存碎片率最多12.5%，可以多申请几个<code>Page</code>来解决。也就是合并相邻的Page，可以减少外部碎片。<br>TCMalloc也考虑相同的<code>class-size</code>进行合并，这里的相同就是指分配的对象大小相同，取一个碎片更少的size进行使用。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://wallenwang.com/2018/11/tcmalloc/#ftoc-heading-24">https://wallenwang.com/2018/11/tcmalloc/#ftoc-heading-24</a><br><a href="https://blog.csdn.net/kelvin_yin/article/details/78997953">https://blog.csdn.net/kelvin_yin&#x2F;article&#x2F;details&#x2F;78997953</a><br><a href="https://zhuanlan.zhihu.com/p/572059278">https://zhuanlan.zhihu.com/p/572059278</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go_垃圾回收</title>
      <link href="/2022/10/27/golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/go_GC/"/>
      <url>/2022/10/27/golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/go_GC/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是-GC？"><a href="#1-什么是-GC？" class="headerlink" title="1.什么是 GC？"></a>1.什么是 GC？</h1><p>垃圾回收（GC）是编程语言中提供的内存管理功能。有自动和手动两种方式。<br>在应用程序中会使用到两种内存，分别为<strong>堆（Heap）和栈（Stack）</strong>，GC 负责回收堆内存，而不负责回收栈中的内存。那么这是为什么呢？主要原因是栈是一块专用内存，专门为了函数执行而准备的，存储着函数中的局部变量以及调用栈。除此以外，栈中的数据都有一个特点——简单。比如局部变量不能被函数外访问，所以这块内存用完就可以直接释放。正是因为这个特点，栈中的数据可以通过简单的编译器指令自动清理，并不需要通过 GC 来回收。</p><p><strong>根对象</strong>：</p><ul><li>全局变量</li><li>执行栈：每个协程有自己的执行栈，包含执行栈变量，分配堆内存的指针等。</li><li>寄存器</li></ul><h1 id="2-GC-算法的种类"><a href="#2-GC-算法的种类" class="headerlink" title="2.GC 算法的种类"></a>2.GC 算法的种类</h1><h2 id="2-1-引用计数"><a href="#2-1-引用计数" class="headerlink" title="2.1.引用计数"></a>2.1.引用计数</h2><p>对每个对象维护一个引用计数，当引用对象的对象被销毁时，引用计数-1，如果引用计数为0，则进行垃圾回收。<br><img src="https://img-blog.csdnimg.cn/276e48f86637491799ce97e6a2e1cd9b.png" alt="在这里插入图片描述"></p><p>优点：<strong>回收速度快</strong>，对象可以<strong>很快的被回收</strong>，不会出现内存耗尽或达到某个阀值时才回收。<br>缺点：<strong>不能很好的处理循环引用</strong>，而且实时维护引用计数，有也一定的代价，频繁更新引用计数降低了性能。</p><h2 id="2-2-标记-清除"><a href="#2-2-标记-清除" class="headerlink" title="2.2.标记-清除"></a>2.2.标记-清除</h2><p>该方法分为两步，标记从<strong>根变量</strong>开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；标记完成后进行清除操作，对没有标记过的内存进行回收（回收同时可能伴有碎片整理操作）。即：从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的进行回收。<br><img src="https://img-blog.csdnimg.cn/3428001c4c7347b593f4471c46b3778f.png" alt="在这里插入图片描述"><br>优点：解决了引用计数的缺点。<br>缺点：需要STW，即要暂时停掉程序运行，回收同时可能伴有碎片整理操作。<br>代表语言：Golang(其采用三色标记法)</p><h2 id="2-3-复制收集"><a href="#2-3-复制收集" class="headerlink" title="2.3.复制收集"></a>2.3.复制收集</h2><p>解决效率问题，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br>    这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。<br>   它的主要缺点有两个：<br>        （1）效率问题：在对象存活率较高时，复制操作次数多，效率降低；<br>        （2）空间问题：內存缩小了一半；需要額外空间做分配担保(老年代)</p><p><strong>复制收集算法</strong>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。<strong>复制收集的方式只需要对对象进行一次扫描</strong>。从根对象开始对对象进行扫描，如果存在对这个对象的引用，就把它复制到新空间中。一次扫描结束之后，所有存在于新空间的对象就是所有的非垃圾对象。<br><strong>标记清除的方式节省内存但是两次扫描需要更多的时间</strong>，复制收集更快速但是需要额外开辟一块用来复制的内存，<strong>对垃圾比例较大的情况占优势</strong>。<br><img src="https://img-blog.csdnimg.cn/36208a0b9b2442ce9a9bd10451803182.png" alt="在这里插入图片描述"></p><p>在复制收集的过程中，会按照对象被引用的顺序将对象复制到新空间中。于是，<strong>关系较近的对象被放在距离较近的内存空间的可能性会提高，这叫做局部性</strong>。局部性高的情况下，内存缓存会更有效地运作，程序的性能会提高。<br>优点：速度更快，没有碎片化。<br>缺点：需要STW，可利用空间小。在对象存活率较高时，复制操作次数多，效率降低；</p><h2 id="2-4-标记-整理算法"><a href="#2-4-标记-整理算法" class="headerlink" title="2.4.标记-整理算法"></a>2.4.标记-整理算法</h2><p><img src="https://img-blog.csdnimg.cn/196464283f784ae98a45663cc9d568fe.png" alt="在这里插入图片描述"></p><p>   复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况。<br> 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h1 id="3-Golang的三色标记"><a href="#3-Golang的三色标记" class="headerlink" title="3.Golang的三色标记"></a>3.Golang的三色标记</h1><p><img src="https://img-blog.csdnimg.cn/8d93926f7eee48438384454d69043872.png" alt="在这里插入图片描述"><br>这个图还认识吧，不了解的话，可以去这篇文章<a href="https://blog.csdn.net/weixin_42128977/article/details/127322024?spm=1001.2014.3001.5502">go-内存管理篇（二） 万字总结-golang内存分配篇</a>。<br><code>mspan</code>多个<code>page</code>的组成。一个<code>page</code>大小为8kb。<br>mspan参数介绍：</p><ul><li>npages  由多少个page组成</li><li>nelems: 可分配的对象。</li><li><strong>allocBits</strong>: 位图，每位代表一个块是否被分配。</li><li>allCounts: 多少块被分配</li><li>elemsize: object size大小   常量</li><li><strong>spanclass</strong>: Span大小的级别。一个Size Class会对应两个Span Class，其中一个Span为存放需</li><li>GC扫描的对象，另一个Span为存放不需要GC扫描的对象。</li><li><strong>gcmarkBits</strong> ： allocBits位图 标记span的块是否被引用。</li></ul><h2 id="3-1-三色标记"><a href="#3-1-三色标记" class="headerlink" title="3.1.三色标记"></a>3.1.三色标记</h2><ul><li>灰色：对象已被标记，但这个对象包含的子对象未标记。</li><li>黑色：对象已被标记，且这个对象包含的子对象也已标记，gcmarkBits对应的位为1（该对象不会在本次GC中被清理）。</li><li>白色：对象未被标记，gcmarkBits对应的位为0（该对象将会在本次GC中被清理）</li></ul><p><strong>三色标记清除的整个过程：</strong><br><img src="https://img-blog.csdnimg.cn/5bcd332b0ff44bc2b506261ef05c0a82.gif#pic_center" alt="在这里插入图片描述"><br>第一步：在进入 GC 的三色标记阶段的一开始，所有对象都是白色的。<br>第二步, 遍历根节点集合里的所有根对象，把根对象引用的对象标记为灰色，从白色集合放入灰色集合。<br>第三步, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合<br>第四步：重复第三步, 直到灰色集合中无任何对象。</p><ul><li><strong>写屏障（Write Barrier）</strong> ：写屏障就是让 goroutine 与 GC 同时运行的手段，虽然不能完全消除 STW，但是可以大大减少 STW 的时间。写屏障在 GC 的特定时间开启，开启后指针传递时会把指针标记，即本轮不回收，下次 GC 时再确定。</li><li><strong>辅助 GC（Mutator Assist）</strong> ：为了防止内存分配过快，在 GC 执行过程中，GC 过程中 mutator 线程会并发运行，而 mutator assist 机制会协助 GC 做一部分的工作。<br>第五步：回收白色集合里的所有对象，本次垃圾回收结束。</li></ul><h2 id="3-2-三色标记法所存在问题"><a href="#3-2-三色标记法所存在问题" class="headerlink" title="3.2.三色标记法所存在问题"></a>3.2.三色标记法所存在问题</h2><p><strong>多标-浮动垃圾问题</strong><br>假设 E 已经被标记过了（变成灰色了），此时 D 和 E 断开了引用，按理来说对象 E&#x2F;F&#x2F;G 应该被回收的，但是因为 E 已经变为灰色了，其仍会被当作存活对象继续遍历下去。最终的结果是：这部分对象仍会被标记为存活，即本轮 GC 不会回收这部分内存。<br><img src="https://img-blog.csdnimg.cn/d9f09e6157064b1a8bc0fdfd504a6515.png" alt="在这里插入图片描述"><br><strong>漏标-悬挂指针问题</strong><br>除了上面多标的问题，还有就是漏标问题。当 GC 线程已经遍历到 E 变成灰色，D变成黑色时，灰色 E 断开引用白色 G ，黑色 D 引用了白色 G。此时切回 GC 线程继续跑，因为 E 已经没有对 G 的引用了，所以不会将 G 放到灰色集合。尽管因为 D 重新引用了 G，但因为 D 已经是黑色了，不会再重新做遍历处理。<br>最终导致的结果是：G 会一直停留在白色集合中，最后被当作垃圾进行清除。这直接影响到了应用程序的正确性，是不可接受的，这也是 Go 需要在 GC 时解决的问题。<br><img src="https://img-blog.csdnimg.cn/9788c0e3fa5447b69ef75108ce394f50.png" alt="在这里插入图片描述"></p><h2 id="3-3-屏障机制"><a href="#3-3-屏障机制" class="headerlink" title="3.3.屏障机制"></a>3.3.屏障机制</h2><p>为了解决上面的悬挂指针问题，我们需要引入<strong>屏障技术</strong>来保障数据的一致性。内存屏障，是一种屏障指令，它能使CPU或编译器对在该屏障指令之前和之后发出的内存操作强制执行排序约束，在内存屏障前执行的操作一定会先于内存屏障后执行的操作。</p><ul><li>强三色不变式：不存在黑色对象引用到白色对象的指针。<br><img src="https://img-blog.csdnimg.cn/a7869220525c4e94bf0da0d90ffa184b.png" alt="图片"></li><li>弱三色不变式：所有被黑色对象引用的白色对象都处于灰色保护状态.<br><img src="https://img-blog.csdnimg.cn/fba514963a18490c803c139203df253b.png" alt="在这里插入图片描述"></li></ul><h3 id="3-3-1-插入屏障"><a href="#3-3-1-插入屏障" class="headerlink" title="3.3.1.插入屏障"></a>3.3.1.插入屏障</h3><p>具体操作: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)<br>满足: 强三色不变式. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p><h3 id="3-3-2-删除写屏障"><a href="#3-3-2-删除写屏障" class="headerlink" title="3.3.2.删除写屏障"></a>3.3.2.删除写屏障</h3><p>当一个白色对象被另外一个对象时解除引用时，将该被引用对象标记为灰色。<br>缺点：产生内存冗余，如果上述该白色对象没有被别的对象引用，相当于还是垃圾，但是这一轮垃圾回收并没有处理掉他。</p><h3 id="3-3-3-Go-V1-8的混合写屏障机制"><a href="#3-3-3-Go-V1-8的混合写屏障机制" class="headerlink" title="3.3.3.Go V1.8的混合写屏障机制"></a>3.3.3.Go V1.8的混合写屏障机制</h3><p>插入写屏障和删除写屏障的短板：<br><strong>插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；<br>删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。</strong><br>混合写屏障机制,<strong>避免了对栈重复扫描的过程</strong>，极大的减少了STW的时间。结合了两者的优点。<br><strong>混合写屏障机制具体操作:</strong><br>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，<br>2、GC期间，任何在栈上创建的新对象，均为黑色。<br>3、被删除的对象标记为灰色。<br>4、被添加的对象标记为灰色。</p><h1 id="4-GC流程"><a href="#4-GC流程" class="headerlink" title="4.GC流程"></a>4.GC流程</h1><ul><li>首先检查上一次垃圾回收是否还有mspan未被清理，如果有还需要执行清理工作；</li><li>标记准备（Mark Setup） ：打开写屏障r，需 STW；</li><li>标记开始（Marking） ：使用三色标记法并发标记 ，与用户程序并发执行；</li><li>标记终止（Mark Termination）：对触发写屏障的对象进行重新扫描标记，关闭写屏障，需 STW；</li><li>清理（Sweeping） ：将需要回收的内存归还到堆中，将过多的内存归还给操作系统，与用户程序并发执行。</li></ul><p><img src="https://img-blog.csdnimg.cn/9d911e6564524dcb86738095af328160.png" alt="在这里插入图片描述"></p><h2 id="4-1-stopTheworld。如何暂停用户协程呢？"><a href="#4-1-stopTheworld。如何暂停用户协程呢？" class="headerlink" title="4.1.stopTheworld。如何暂停用户协程呢？"></a>4.1.stopTheworld。如何暂停用户协程呢？</h2><p>不是所有根对象的扫描都需要STW, 例如扫描栈上的对象只需要停止拥有该栈的G。<br>线程M调度协程G是需要绑定逻辑处理器P的，那如果没有可用的逻辑处理P当然也就无法调度用户协程了？逻辑处理器P可以分为三种：<br>1）<strong>空闲</strong>，没有被任何线程M绑定，这种直接更新其状态即可；<br>2）<strong>系统调用中</strong>，说明已被线程M绑定，并且正在执行系统调用，同样的直接更新状态即可（系统调度返回后，检测逻辑处理器P的状态不对，线程M会休眠）；<br>3）<strong>运行中</strong>，也就是已被线程M绑定，并且正在调度用户协程，这种是需要通知其暂停用户协程的，如何通知呢？还记得介绍Go语言调度器提到的抢占式调度吗？协作式抢占调度与基于信号的抢占式调度。对，就是通过这两种方案实现的。</p><h2 id="4-2-为什么写屏障不保护栈的引用，为什么栈上触发写屏障就会影响性能？"><a href="#4-2-为什么写屏障不保护栈的引用，为什么栈上触发写屏障就会影响性能？" class="headerlink" title="4.2.为什么写屏障不保护栈的引用，为什么栈上触发写屏障就会影响性能？"></a>4.2.为什么写屏障不保护栈的引用，为什么栈上触发写屏障就会影响性能？</h2><p>写屏障:<strong>写屏障只监控堆上指针数据的变动</strong>，由于成本原因，没有监控栈上指针的变动，由于应用goroutine和GC的标记goroutine都在运行，当栈上的指针指向的对象变更为白色对象时，这个白色对象应当标记为黑色，需要再次扫描全局变量和栈，以免释放这类不该释放的对象。<br>go是并发运行的，大部分的操作都发生在栈上。数十万goroutine的栈都进行屏障保护自然会有性能问题。</p><h2 id="4-3-如果发生栈上对象引用改变。因为不涉及屏障，为什么不会发生错误。"><a href="#4-3-如果发生栈上对象引用改变。因为不涉及屏障，为什么不会发生错误。" class="headerlink" title="4.3.如果发生栈上对象引用改变。因为不涉及屏障，为什么不会发生错误。"></a>4.3.如果发生栈上对象引用改变。因为不涉及屏障，为什么不会发生错误。</h2><p>1.栈的操作是原子操作，要么栈全灰，要么全黑。<br>2.已被扫黑的栈，引用的堆上的对象至少是灰色。（比如C对象）。所以不可能发生同栈下引用改变会影响GC的问题。<br>3.不可能发生上述的跨栈的引用。因为“对象不是从天上掉下来的”。假设A对象可以与D对象建立引用，只有可能A也直接间接持有B对象。否则没有路径可以建立这样的引用。然而，因为Go的逃逸分析，B对象被外部引用，不可能存在于栈上。所以B一定是堆上的对象。</p><p>辅助GC：Golang GC实际上把单次暂停时间分散掉了，本来程序执⾏可能是“⽤户代码–&gt;⼤段GC–&gt;⽤户代码”，那么分散以后实际上变成了“⽤户代码–&gt;⼩段 GC–&gt;⽤户代码–&gt;⼩段GC–&gt;⽤户代码”这样。如果GC回收的速度跟不上用户代码分配对象的速度呢？ Go <strong>语⾔如果发现扫描后回收的速度跟不上分配的速度它依然会把⽤户逻辑暂停，⽤户逻辑暂停了以后也就意味着不会有新的对象出现，同时会把⽤户线程抢过来加⼊到垃圾回收⾥⾯加快垃圾回收的速度。</strong>这样⼀来原来的并发还是变成了STW，还是得把⽤户线程暂停掉，要不然扫描和回收没完没了了停不下来，因为新分配对象⽐回收快，所以这种东⻄叫做辅助回收。</p><h1 id="5-GC触发条件"><a href="#5-GC触发条件" class="headerlink" title="5.GC触发条件"></a>5.GC触发条件</h1><ul><li>主动触发：调用<code> runtime.GC()</code> 方法，触发 GC</li><li>被动触发：<ul><li>定时触发，该触发条件由<code>runtime.forcegcperiod</code>变量控制，默认为 2 分 钟。当超过两分钟没有产生任何 GC 时，触发 GC</li><li>根据内存分配阈值触发，该触发条件由环境变量GOGC控制，默认值为100（100%），当前堆内存占用是上次GC结束后占用内存的2倍时，触发GC</li></ul></li></ul><h1 id="6-调优gc"><a href="#6-调优gc" class="headerlink" title="6.调优gc"></a>6.调优gc</h1><h2 id="6-1-如何观察GC？"><a href="#6-1-如何观察GC？" class="headerlink" title="6.1.如何观察GC？"></a>6.1.如何观察GC？</h2><ul><li>通过指令  <code>GODEBUG =gctrace=1 ./main</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -o main.<span class="keyword">go</span></span><br><span class="line">GODEBUG =gctrace=<span class="number">1</span> ./main</span><br></pre></td></tr></table></figure><ul><li><code>go tool trace</code>: 统计信息可视化。</li><li>方法:debug.ReadGCStatus():监控</li><li>runtime.ReadMemStatus()</li></ul><h2 id="6-2-如何调优？"><a href="#6-2-如何调优？" class="headerlink" title="6.2.如何调优？"></a>6.2.如何调优？</h2><ul><li>一方面可以针对业务类型调整环境变量<code>GOGC</code>或者<code>debug.SetGCPercent()</code>（计算并调整下一次垃圾回收触发的内存门限）；</li><li>尽量减少用户代码分配内存的数量，比如使用对象池（复用），减少对象分配，合理重复利用；</li><li>避免string与[]byte转化；</li><li>少用+连接string(频繁分配内存)；</li><li>标记扫描就是对对象包含指针，就需要继续扫描，Go语言才会将每种mspan分为两种规格，有指针与无指针，而不包含指针的mspan是不需要继续扫描的。<code>bigcache包</code>是常用的本地内存缓存组件，就是通过去除指针来减少垃圾回收扫描的压力。</li></ul><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h1><ul><li>go 1.5 采用三色标记法，插入写屏障机制（只在堆内存中生效），最后仍需对栈内存进行STW；</li><li>go 1.8 采用混合写屏障机制，屏障限制只在堆内存中生效。避免了最后节点对栈进行STW的问题，提升了GC效率；</li><li>插入写屏障没有完全保证完整的强三色不变式(栈对象的影响)，所以赋值器是灰色赋值器，最后必须 STW 重新扫描栈；</li><li>混合写屏障消除了所有的 STW，实现的是黑色赋值器，不用 STW 扫描栈；</li><li>混合写屏障的精度和删除写屏障的一致，比以前插入写屏障要低；</li><li>混合写屏障扫描栈式逐个暂停，逐个扫描的，对于单个 goroutine 来说，栈要么全灰，要么全黑。</li><li>一次完整的垃圾回收会分为四个阶段，分别是标记准备、标记、结束标记以及清理。在标记准备和标记结束阶段会需要 STW，标记阶段会减少程序的性能，而清理阶段是不会对程序有影响的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-内存管理篇（三）内存对齐</title>
      <link href="/2022/10/27/golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
      <url>/2022/10/27/golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h1><h2 id="1-1-何为内存对齐"><a href="#1-1-何为内存对齐" class="headerlink" title="1.1.何为内存对齐"></a>1.1.何为内存对齐</h2><blockquote><p>现代计算机中内存空间都是按照字节(byte)进行划分的，所以从理论上讲对于任何类型的变量访问都可以从任意地址开始，但是在实际情况中，在访问特定类型变量的时候经常在特定的内存地址访问，所以这就需要把各种类型数据按照一定的规则在空间上排列，而不是按照顺序一个接一个的排放，这种就称为内存对齐，内存对齐是指首地址对齐，而不是说每个变量大小对齐。</p></blockquote><h2 id="1-2-为何要有内存对齐"><a href="#1-2-为何要有内存对齐" class="headerlink" title="1.2.为何要有内存对齐"></a>1.2.为何要有内存对齐</h2><p>1.平台原因：不是所有的硬件平台都能够访问任意地址上的任意数据。<br>2.性能原因：操作系统并非一个字节一个字节访问内存，而是按2, 4, 8这样的字长来访问。因此，当CPU从存储器读数据到寄存器，或者从寄存器写数据到存储器，IO的数据长度通常是字长。<br>3.CPU每次寻址都是要消费时间的，并且CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问，所以数据结构应该尽可能地在自然边界上对齐<strong>，如果访问未对齐的内存，处理器需要做两次内存访问，然后拼接字节流；而对齐的内存访问仅需要一次访问，内存对齐后可以提升性能</strong>。<br><img src="https://img-blog.csdnimg.cn/5fd6e7ab477141c4b07fee2c9f39d92a.png" alt="在这里插入图片描述"></p><h1 id="二-数据类型"><a href="#二-数据类型" class="headerlink" title="二.数据类型"></a>二.数据类型</h1><h2 id="2-1-go类型字节大小"><a href="#2-1-go类型字节大小" class="headerlink" title="2.1.go类型字节大小"></a>2.1.go类型字节大小</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">method1</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;bool&quot;</span>, unsafe.Sizeof(<span class="type">bool</span>(<span class="literal">true</span>))) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;int8&quot;</span>, unsafe.Sizeof(<span class="type">int8</span>(<span class="number">1</span>)))    <span class="comment">// 1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;int16&quot;</span>, unsafe.Sizeof(<span class="type">int16</span>(<span class="number">1</span>)))  <span class="comment">// 2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;int32&quot;</span>, unsafe.Sizeof(<span class="type">int32</span>(<span class="number">1</span>)))  <span class="comment">// 4</span></span><br><span class="line">fmt.Println(<span class="string">&quot;int64&quot;</span>, unsafe.Sizeof(<span class="type">int64</span>(<span class="number">1</span>)))  <span class="comment">// 8</span></span><br><span class="line">fmt.Println(<span class="string">&quot;int&quot;</span>, unsafe.Sizeof(<span class="type">int</span>(<span class="number">1</span>)))      <span class="comment">// 8</span></span><br><span class="line">fmt.Println(<span class="string">&quot;---------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;uint8&quot;</span>, unsafe.Sizeof(<span class="type">uint8</span>(<span class="number">1</span>)))   <span class="comment">// 1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;uint16&quot;</span>, unsafe.Sizeof(<span class="type">uint16</span>(<span class="number">1</span>))) <span class="comment">// 2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;uint32&quot;</span>, unsafe.Sizeof(<span class="type">uint32</span>(<span class="number">1</span>))) <span class="comment">// 4</span></span><br><span class="line">fmt.Println(<span class="string">&quot;uint64&quot;</span>, unsafe.Sizeof(<span class="type">uint64</span>(<span class="number">1</span>))) <span class="comment">// 8</span></span><br><span class="line">fmt.Println(<span class="string">&quot;uint&quot;</span>, unsafe.Sizeof(<span class="type">uint</span>(<span class="number">1</span>)))     <span class="comment">// 8</span></span><br><span class="line">fmt.Println(<span class="string">&quot;---------------------------&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;float32&quot;</span>, unsafe.Sizeof(<span class="type">float32</span>(<span class="number">1</span>))) <span class="comment">// 4</span></span><br><span class="line">fmt.Println(<span class="string">&quot;float64&quot;</span>, unsafe.Sizeof(<span class="type">float64</span>(<span class="number">1</span>))) <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;---------------------------&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;*T&quot;</span>, unsafe.Sizeof(<span class="type">uintptr</span>(<span class="number">1</span>)))   <span class="comment">// 8</span></span><br><span class="line">fmt.Println(<span class="string">&quot;*T&quot;</span>, unsafe.Sizeof(<span class="type">uintptr</span>(<span class="string">&#x27;0&#x27;</span>))) <span class="comment">// 8</span></span><br><span class="line">fmt.Println(<span class="string">&quot;---------------------------&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;map&quot;</span>, unsafe.Sizeof(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;)) <span class="comment">// 8</span></span><br><span class="line">fun := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;func&quot;</span>, unsafe.Sizeof(fun)) <span class="comment">// 8</span></span><br><span class="line">fmt.Println(<span class="string">&quot;---------------------------&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;string&quot;</span>, unsafe.Sizeof(<span class="type">string</span>(<span class="string">&quot;&quot;</span>))) <span class="comment">// 16</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;interface&quot;</span>, unsafe.Sizeof(a)) <span class="comment">// 16</span></span><br><span class="line">fmt.Println(<span class="string">&quot;---------------------------&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;[]T&quot;</span>, unsafe.Sizeof([]<span class="type">string</span>&#123;&#125;)) <span class="comment">// 24</span></span><br><span class="line"><span class="keyword">var</span> s [<span class="number">15</span>]<span class="type">uint32</span></span><br><span class="line">fmt.Println(<span class="string">&quot;[15]T&quot;</span>,unsafe.Sizeof(s)) <span class="comment">//60</span></span><br><span class="line"><span class="comment">// go 图像库中头信息类</span></span><br><span class="line"> <span class="keyword">type</span> TGIHeader <span class="keyword">struct</span> &#123;</span><br><span class="line"> _      <span class="type">uint16</span> <span class="comment">// Reserved</span></span><br><span class="line"> _      <span class="type">uint16</span> <span class="comment">// Reserved</span></span><br><span class="line"> Width  <span class="type">uint32</span></span><br><span class="line"> Height <span class="type">uint32</span></span><br><span class="line"> <span class="comment">//_        [15]uint32 // 15 &quot;don&#x27;t care&quot; dwords</span></span><br><span class="line"> SaveTime <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(unsafe.Sizeof(TGIHeader&#123;&#125;)) <span class="comment">//80</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">method1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于Go语言的内置类型，占用内存大小如下：</p><table><thead><tr><th>类型</th><th>字节数</th></tr></thead><tbody><tr><td>bool</td><td>1个字节</td></tr><tr><td>intN, uintN, floatN, complexN</td><td>N&#x2F;8 个字节 （int32 是 4 个字节）</td></tr><tr><td>int, uint, uintptr</td><td>计算机字长&#x2F;8 (64位 是 8 个字节)</td></tr><tr><td>*T, map, func, chan</td><td>计算机字长&#x2F;8 (64位 是 8 个字节)</td></tr><tr><td>string （data、len）</td><td>2 * 计算机字长&#x2F;8 (64位 是 16 个字节)</td></tr><tr><td>interface (tab、data 或 _type、data)</td><td>2 * 计算机字长&#x2F;8 (64位 是 16 个字节)</td></tr><tr><td>[]T (array、len、cap)</td><td>3 * 计算机字长&#x2F;8 (64位 是 24 个字节)</td></tr><tr><td>[nums]T</td><td>nums * T类型的字节数</td></tr></tbody></table><h2 id="2-2-对齐系数"><a href="#2-2-对齐系数" class="headerlink" title="2.2.对齐系数"></a>2.2.对齐系数</h2><ul><li>对于任意类型的变量 x ，unsafe.Alignof(x) 至少为 1。</li><li>对于 struct 结构体类型的变量 x，计算 x 每一个字段 f 的 unsafe.Alignof(x.f)，unsafe.Alignof(x) 等于其中的最大值。</li><li>对于 array 数组类型的变量 x，unsafe.Alignof(x) 等于构成数组的元素类型的对齐倍数。</li></ul><table><thead><tr><th>type</th><th>对齐系数</th></tr></thead><tbody><tr><td>bool,byte,uint8,int8</td><td>1</td></tr><tr><td>uint16,int16</td><td>2</td></tr><tr><td>uint32,int32,float32</td><td>4</td></tr><tr><td>uint32,int32,float32</td><td>4</td></tr><tr><td>arrays</td><td>由其元素决定</td></tr><tr><td>struct</td><td>由其字段决定</td></tr></tbody></table><p><strong>对齐规则</strong><br>我们讲内存对齐，就是把变量放在特定的地址，那么如何计算特定地址呢，这就涉及到内存对齐规则：</p><ul><li>成员对齐规则：针对一个基础类型变量，如果 unsafe.AlignOf() 返回的值是 m，那么该变量的地址需要 被m整除 ，如果当前地址不能整除，填充空白字节，直至可以整除。</li><li>整体对齐规则：针对一个结构体，如果 unsafe.AlignOf() 返回值是 m，需要保证该结构体整体内存占用是 m的整数倍，如果当前不是整数倍，需要在后面填充空白字节。</li></ul><p>通过内存对齐后，就可以在保证在访问一个变量地址时：</p><ul><li>如果该变量占用内存小于字长：保证一次访问就能得到数据；</li><li>如果该变量占用内存大于字长：保证第一次内存访问的首地址，是该变量的首地址。</li></ul><h1 id="三-struct-内存对齐的技巧"><a href="#三-struct-内存对齐的技巧" class="headerlink" title="三.struct 内存对齐的技巧"></a>三.struct 内存对齐的技巧</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> demo1 <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="type">int8</span></span><br><span class="line">b <span class="type">int16</span></span><br><span class="line">c <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> demo2 <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="type">int8</span></span><br><span class="line">c <span class="type">int32</span></span><br><span class="line">b <span class="type">int16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(unsafe.Sizeof(demo1&#123;&#125;)) <span class="comment">// 8</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(demo2&#123;&#125;)) <span class="comment">// 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是会产生影响。每个字段按照自身的对齐倍数来确定在内存中的偏移量，字段排列顺序不同，上一个字段因偏移而浪费的大小也不同。<br>接下来逐个分析，首先是 demo1：</p><ul><li>a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节。</li><li>b 是第二个字段，对齐倍数为 2，因此，必须空出 1 个字节，偏移量才是 2 的倍数，从第 2 个位置开始占据 2 字节。</li><li>c 是第三个字段，对齐倍数为 4，此时，内存已经是对齐的，从第 4 个位置开始占据 4 字节即可。</li></ul><p>因此 demo1 的内存占用为 8 字节。<br>其实是 demo2：</p><ul><li>a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节。</li><li>c 是第二个字段，对齐倍数为 4，因此，必须空出 3 个字节，偏移量才是 4 的倍数，从第 4 个位置开始占据 4 字节。</li><li>b 是第三个字段，对齐倍数为 2，从第 8 个位置开始占据 2 字节。</li></ul><p>demo2 的对齐倍数由 c 的对齐倍数决定，也是 4，因此，demo2 的内存占用为 12 字节。<br><img src="https://img-blog.csdnimg.cn/0156bb5dfd474a7cae6053335e73948b.png" alt="在这里插入图片描述"></p><h1 id="四-空结构体的对齐规则"><a href="#四-空结构体的对齐规则" class="headerlink" title="四.空结构体的对齐规则"></a>四.空结构体的对齐规则</h1><p>空 struct{} 大小为 0，作为其他 struct 的字段时，一般不需要内存对齐。但是有一种情况除外：即当 struct{} 作为结构体最后一个字段时，需要内存对齐。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">method3</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> demo1 <span class="keyword">struct</span> &#123;</span><br><span class="line">c <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">a <span class="type">int32</span></span><br><span class="line">b <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> demo2 <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="type">int32</span></span><br><span class="line">c <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">b <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> demo3 <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="type">int32</span></span><br><span class="line">b <span class="type">int32</span></span><br><span class="line">c <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> demo4 <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="type">int32</span></span><br><span class="line">b <span class="type">int64</span></span><br><span class="line">c <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> demo5 <span class="keyword">struct</span> &#123;</span><br><span class="line">b <span class="type">int64</span></span><br><span class="line">a <span class="type">int32</span></span><br><span class="line">c <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(unsafe.Sizeof(demo1&#123;&#125;)) <span class="comment">// 8</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(demo2&#123;&#125;)) <span class="comment">// 8</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(demo3&#123;&#125;)) <span class="comment">// 12</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(demo4&#123;&#125;)) <span class="comment">// 24</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(demo5&#123;&#125;)) <span class="comment">// 16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo4 结构体尾部size为0的变量(字段)会被分配内存空间进行填充，原因是如果不给它分配内存，该变量指针将指向一个非法的内存空间（内存泄漏的风险）。<br>比如说我连续分配了两个demo4 结构体,那么如果不存在这个内存填充，那么<code>demo4.c</code>的位置实际上是等于下一个<code>demo4</code>的位置的,导致了非法内存访问.</p><p>结论：如果空结构体作为结构体的内置字段：当变量位于结构体的前面和中间时，不会占用内存；当该变量位于结构体的末尾位置时，需要进行内存对齐，内存占用大小和前一个变量的大小保持一致。</p><h1 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h1><p>总结- 内存对齐是为了让 cpu 更高效访问内存中数据</p><ul><li>unsafe.Sizeof(x) 返回了变量x的内存占用大小；</li><li>两个结构体，即使包含变量类型的数量相同，但是位置不同，占用的内存大小也不同，由此引出了内存对齐；</li><li>内存对齐包含成员对齐和整体对齐，与 unsafe.AlignOf(x) 息息相关；</li><li>空结构体作为成员变量时，要避免作为 struct 最后一个字段，会有内存浪费；</li></ul>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gf_lua脚本</title>
      <link href="/2022/10/27/goframe/gf_lua/"/>
      <url>/2022/10/27/goframe/gf_lua/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Lua是一个高效的轻量级脚本语言。</p><p><strong>Redis中使用 Lua 的好处</strong></p><ul><li>减少网络开销，在 Lua脚本 中可以把多个命令放在同一个脚本中运行；</li><li>原子操作，Redis 会将整个脚本作为一个整体执行，中间不会被其他命令插入（编写脚本过程中无需担心会出现竞态条件）</li><li>复用性，客户端发送的脚本会永远存储在 Redis中，意味着其他客户端可以复用这一脚本。</li></ul><p><strong>Redis Lua脚本与事务</strong><br>从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。但是lua支持缓存，可以复用脚本，这个是原来的事务所没有的。</p><p>使用事务时可能会遇上以下两种错误：</p><ul><li>事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误；</li><li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。<br>对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。</li></ul><p>Redis 相关命令<br><strong>1.EVAL</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---   脚本   key个数    key      附件参数</span></span><br><span class="line">EVAL script numkeys key [key …] <span class="built_in">arg</span> [<span class="built_in">arg</span> …]</span><br><span class="line"><span class="comment">--- key [key ...] ： 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis键(key)，这些键名参数可在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。</span></span><br><span class="line"><span class="comment">--- arg [arg ...] ： 附加参数，在 Lua 中通过全局变量 ARGV 数组访问，访问的形式 ARGV[1]、ARGV[2] </span></span><br></pre></td></tr></table></figure><p>每次执行 Eval命令时 Redis 都会将脚本的 SHA1 摘要加入到脚本缓存中，以便下次客户端可以使用 EVALSHA 命令调用该脚本。（EVALSHA+script load)</p><p><strong>2.EVALSHA</strong><br>EVALSHA 命令的表现如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---     加密后的   key个数    key      附件参数</span></span><br><span class="line">evalsha sha1 numkeys key [key …] <span class="built_in">arg</span> [<span class="built_in">arg</span> …]</span><br></pre></td></tr></table></figure><p>  EVAL 命令要求在每次执行脚本的时候都发送一次脚本主体。Redis 有一个内部的缓存机制，因此它不会每次都重新编译脚本，不过在很多场合，付出无谓的带宽来传送脚本主体并不是最佳选择。为了减少带宽的消耗， Redis 实现了 EVALSHA 命令，它的作用和 EVAL 一样，都用于对脚本求值，但它接受的第一个参数不是脚本，而是脚本的 SHA1 校验和(sum)。</p><p><strong>3.SCRIPT FLUSH</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">script <span class="built_in">flush</span></span><br></pre></td></tr></table></figure><p>清除Redis服务端所有 Lua 脚本缓存</p><p><strong>4.SCRIPT EXISTS</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT EXISTS sha1 [sha1 …] </span><br></pre></td></tr></table></figure><p>给定一个或多个脚本的 SHA1 校验和，返回一个包含 0或 1 的列表，表示校验和所指定的脚本是否已经被保存在缓存当中</p><p><strong>5.SCRIPT LOAD</strong><br>将脚本 script 添加到Redis服务器的脚本缓存中，并不立即执行这个脚本，而是会立即对输入的脚本进行求值。并返回给定脚本的 SHA1 校验和。如果给定的脚本已经在缓存里面了，那么不执行任何操作。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">------脚本</span></span><br><span class="line">SCRIPT LOAD script </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>6.SCRIPT KILL</strong><br>杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。 这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限 loop 的脚本，诸如此类。<br>假如当前正在运行的脚本已经执行过写操作，那么即使执行SCRIPT KILL，也无法将它杀死，因为这是违反 Lua 脚本的原子性执行原则的。在这种情况下，唯一可行的办法是使用SHUTDOWN NOSAVE命令，通过停止整个 Redis 进程来停止脚本的运行，并防止不完整(half-written)的信息被写入数据库中。</p><h3 id="Lua中执行redis命令"><a href="#Lua中执行redis命令" class="headerlink" title="Lua中执行redis命令"></a>Lua中执行redis命令</h3><p>在 Lua 脚本中，可以使用两个不同函数来执行 Redis 命令，它们分别是：</p><ul><li>redis.call()</li><li>redis.pcall()</li></ul><p>这两个函数的唯一区别在于它们使用不同的方式处理执行命令所产生的错误。</p><h3 id="go使用lua脚本"><a href="#go使用lua脚本" class="headerlink" title="go使用lua脚本"></a>go使用lua脚本</h3><p>以goframe框架中gredis为例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> scriptEVALSha <span class="keyword">struct</span> &#123;</span><br><span class="line">r *gredis.Redis</span><br><span class="line">m sync.Map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ScriptEVALSha = &amp;scriptEVALSha&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> path = <span class="string">&quot;resource/scripts/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(r *gredis.Redis)</span></span> *scriptEVALSha &#123;</span><br><span class="line"><span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;scriptEVALSha&#123;</span><br><span class="line">r: r,</span><br><span class="line">m: sync.Map&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">ScriptEVALSha = <span class="built_in">new</span>(g.Redis())</span><br><span class="line">list, err := gfile.ScanDirFile(path, <span class="string">&quot;*.lua&quot;</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">sha, err := ScriptEVALSha.registerScriptFile(ctx, v)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(sha)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.注册脚本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNameByFilePath</span><span class="params">(ctx context.Context, filePath <span class="type">string</span>)</span></span> (fileName <span class="type">string</span>) &#123;</span><br><span class="line"><span class="comment">//获取文件名</span></span><br><span class="line">base := filepath.Base(filePath)</span><br><span class="line"><span class="keyword">if</span> i := strings.LastIndexByte(base, <span class="string">&#x27;.&#x27;</span>); i != <span class="number">-1</span> &#123;</span><br><span class="line">fileName = base[:i]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fileName = base</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterScriptFile 注册&#123;scriptsPath&#125;/&#123;filename&#125;脚本文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dr *scriptEVALSha)</span></span> registerScriptFile(ctx context.Context, filePath <span class="type">string</span>) (sha <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">fileName := getNameByFilePath(ctx, filePath)</span><br><span class="line">g.Log().Debugf(ctx, <span class="string">&quot;script: fileName = %s &quot;</span>, fileName)</span><br><span class="line">file, err := os.Open(filePath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">g.Log().Error(ctx, <span class="string">&quot;open file failed:&quot;</span>, err, filePath)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">fileBuffer, err := io.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">g.Log().Error(ctx, <span class="string">&quot;read file failed:&quot;</span>, err, filePath)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">&#125;</span><br><span class="line">script := <span class="type">string</span>(fileBuffer)</span><br><span class="line"><span class="comment">// 缓存脚本,获取校验和</span></span><br><span class="line"><span class="keyword">if</span> sha, err = dr.scriptLoad(ctx, script); err != <span class="literal">nil</span> &amp;&amp; sha == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(fmt.Sprintf(<span class="string">&quot;script load `%s` failed:&quot;</span>, err))</span><br><span class="line">&#125;</span><br><span class="line">g.Log().Debugf(ctx, <span class="string">&quot;script: fileName = %s sha = %s&quot;</span>, fileName, sha)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册脚本key和校验和，如果fileName已注册，则返回错误</span></span><br><span class="line">res, loaded := dr.m.LoadOrStore(fileName, sha)</span><br><span class="line"><span class="keyword">if</span> loaded &#123;</span><br><span class="line">err = errors.New(fmt.Sprintf(<span class="string">&quot;script fileName = %s has registered. exists sha1 = %s&quot;</span>, fileName, res))</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">&#125;</span><br><span class="line">sha = res.(<span class="type">string</span>)</span><br><span class="line">g.Log().Debugf(ctx, <span class="string">&quot;register script fileName: key = %s, sha = %s&quot;</span>, fileName, sha)</span><br><span class="line"><span class="keyword">return</span> sha, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓存脚本  sha1加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dr *scriptEVALSha)</span></span> scriptLoad(ctx context.Context, script <span class="type">string</span>) (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">doArgs = []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;LOAD&quot;</span>, script&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> v, err := dr.r.Do(ctx, <span class="string">&quot;SCRIPT&quot;</span>, doArgs...); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> v.String(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.执行脚本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fileName 执行的脚本名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dr *scriptEVALSha)</span></span> evalSha1CmdScriptKey(ctx context.Context, fileName <span class="type">string</span>, keys []<span class="type">string</span>, argv ...<span class="keyword">interface</span>&#123;&#125;) (*gvar.Var, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">//第一个参数是执行脚本 第二参数是key的个数</span></span><br><span class="line">doArgs = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">2</span>+<span class="built_in">len</span>(keys), <span class="number">2</span>+<span class="built_in">len</span>(keys)+<span class="built_in">len</span>(argv))</span><br><span class="line">)</span><br><span class="line">g.Log().Debugf(ctx, <span class="string">&quot;keys: %v, args: %v&quot;</span>, keys, argv)</span><br><span class="line"><span class="comment">// 读取脚本对应的SHA1校验和</span></span><br><span class="line">sha, ok := dr.m.Load(fileName)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">&quot;fileName = %s have not registered&quot;</span>, fileName))</span><br><span class="line">&#125;</span><br><span class="line">doArgs[<span class="number">0</span>] = sha</span><br><span class="line">doArgs[<span class="number">1</span>] = <span class="built_in">len</span>(keys)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">doArgs[<span class="number">2</span>+i] = k</span><br><span class="line">&#125;</span><br><span class="line">doArgs = <span class="built_in">append</span>(doArgs, argv...)</span><br><span class="line">g.Log().Debugf(ctx, <span class="string">&quot;eval script key: `evalsha %v`&quot;</span>, doArgs)</span><br><span class="line"><span class="keyword">return</span> dr.r.Do(ctx, <span class="string">&quot;evalsha&quot;</span>, doArgs...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dr *scriptEVALSha)</span></span> FlushScriptKey(ctx context.Context) (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">doArgs = []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;FLUSH&quot;</span>&#125;</span><br><span class="line">newMp  = sync.Map&#123;&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> v, err := dr.r.Do(ctx, <span class="string">&quot;SCRIPT&quot;</span>, doArgs...); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dr.m = newMp</span><br><span class="line"><span class="keyword">return</span> v.String(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dr *scriptEVALSha)</span></span> GetAndDel(ctx context.Context, key <span class="type">string</span>) (*gvar.Var, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> dr.evalSha1CmdScriptKey(ctx, <span class="string">&quot;get-and-del&quot;</span>, []<span class="type">string</span>&#123;key&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dr *scriptEVALSha)</span></span> GetAndSet(ctx context.Context, key <span class="type">string</span>, v ...<span class="keyword">interface</span>&#123;&#125;) (*gvar.Var, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> dr.evalSha1CmdScriptKey(ctx, <span class="string">&quot;get-and-set&quot;</span>, []<span class="type">string</span>&#123;key&#125;, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map 获取所有键值对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dr *scriptEVALSha)</span></span> Map() <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">dr.m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> k, ok := key.(<span class="type">string</span>); ok &#123;</span><br><span class="line">m[k] = value.(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keys 获取所有key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dr *scriptEVALSha)</span></span> Keys() []<span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">var</span> keys []<span class="type">string</span></span><br><span class="line">dr.m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, _ <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> k, ok := key.(<span class="type">string</span>); ok &#123;</span><br><span class="line">keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> keys</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> golang </tag>
            
            <tag> goframe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go泛型进阶</title>
      <link href="/2022/10/27/golang/golang-%E6%B3%9B%E5%9E%8B/go%E6%B3%9B%E5%9E%8B%E8%BF%9B%E9%98%B6/"/>
      <url>/2022/10/27/golang/golang-%E6%B3%9B%E5%9E%8B/go%E6%B3%9B%E5%9E%8B%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面的文章介绍了泛型的基础语法和使用要注意的地方。现在来看看泛型的优化方式。</p><h2 id="接口作为泛型约束"><a href="#接口作为泛型约束" class="headerlink" title="接口作为泛型约束"></a>接口作为泛型约束</h2><p>有时候使用泛型编程时，我们会书写长长的类型约束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个可以容纳所有int,uint以及浮点类型的泛型切片</span></span><br><span class="line"><span class="keyword">type</span> Slice[T <span class="type">int</span> | <span class="type">int8</span> | <span class="type">int16</span> | <span class="type">int32</span> | <span class="type">int64</span> | <span class="type">uint</span> | <span class="type">uint8</span> | <span class="type">uint16</span> | <span class="type">uint32</span> | <span class="type">uint64</span> | <span class="type">float32</span> | <span class="type">float64</span>] []T</span><br></pre></td></tr></table></figure><p>这个写法，让人头皮发麻。。。。。所以我们尝试将约束单独拿出来定义到接口中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntUintFloat <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="type">int</span> | <span class="type">int8</span> | <span class="type">int16</span> | <span class="type">int32</span> | <span class="type">int64</span> | <span class="type">uint</span> | <span class="type">uint8</span> | <span class="type">uint16</span> | <span class="type">uint32</span> | <span class="type">uint64</span> | <span class="type">float32</span> | <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T IntUintFloat] []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>(Slice[<span class="type">int</span>], <span class="number">0</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们还可不可以进行拆分成更小的接口呢？<br>答案是可以。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">type</span> Int <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">int</span> | <span class="type">int8</span> | <span class="type">int16</span> | <span class="type">int32</span> | <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">uint</span> | <span class="type">uint8</span> | <span class="type">uint16</span> | <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">float32</span> | <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">type</span> Slice[T Int | Uint | Float] []T  <span class="comment">// 使用 &#x27;|&#x27; 将多个接口类型组合</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SliceElement <span class="keyword">interface</span>&#123;</span><br><span class="line">Int | Uint | Float</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">type</span> Slice2[T SliceElement] []T  <span class="comment">// 使用 &#x27;|&#x27; 将多个接口类型组合</span></span><br></pre></td></tr></table></figure><h2 id="指定潜在类型"><a href="#指定潜在类型" class="headerlink" title="~ : 指定潜在类型"></a>~ : 指定潜在类型</h2><p>我们知道go里面<code>类型定义</code>产生的是一个新的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span></span><br></pre></td></tr></table></figure><p><code>MyString</code> 是新类型 ，<code>string</code> 可以被称为<code>MyString</code>的潜在类型。潜在类型的含义是，某<strong>个类型在本质上是哪个类型。潜在类型相同的不同类型的值之间是可以进行类型转换的</strong>。golang为了支持泛型可以<code>潜在类型</code>,使用<code>~</code>符合。</p><p>限制：使用 ~ 时有一定的限制：</p><ul><li>~后面的类型不能为接口</li><li>~后面的类型必须为基本类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Int <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">float32</span> | ~<span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T Int | Uint | Float] []T </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s Slice[<span class="type">int</span>] <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> s2 Slice[MyInt]  <span class="comment">// MyInt底层类型是int，所以可以用于实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyMyInt MyInt</span><br><span class="line"><span class="keyword">var</span> s3 Slice[MyMyInt]  <span class="comment">// 正确。MyMyInt 虽然基于 MyInt ，但底层类型也是int，所以也能用于实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的写法</span></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~MyInt   <span class="comment">// 错误，~后的类型必须为基本类型</span></span><br><span class="line">    ~<span class="type">error</span>   <span class="comment">// 错误，~后的类型不能为接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空接口和-any"><a href="#空接口和-any" class="headerlink" title="空接口和 any"></a>空接口和 any</h2><p>Go1.18之后的空接口应该这样理解：</p><blockquote><p>虽然空接口内没有写入任何的类型，但它代表的是所有类型的集合，而非一个 空集。</p><p>类型约束中指定 空接口 的意思是指定了一个包含所有类型的类型集，并不是类型约束限定了只能使用 空接口 来做类型形参。</p></blockquote><p>空接口是一个包含了所有类型的类型集，所以我们经常会用到它。于是，Go1.18开始提供了一个和空接口 interface{} 等价的新关键词 any ，用来使代码更简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice[T any] []T <span class="comment">// 代码等价于 type Slice[T interface&#123;&#125;] []T</span></span><br></pre></td></tr></table></figure><h2 id="不一样的接口"><a href="#不一样的接口" class="headerlink" title="不一样的接口"></a>不一样的接口</h2><p>学习泛型之前的我们对于接口的写法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法集</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">Name() (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">Age() (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>学习泛型之后，我们写接口就变成这样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型集</span></span><br><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">float32</span> | ~<span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Slice[T Float] []T </span><br></pre></td></tr></table></figure><p>换一个角度来重新思考上面这个<code>Animal </code>接口的话，会发现接口的定义实际上还能这样理解：</p><blockquote><p>我们可以把 Animal  接口看成代表了一个 类型的集合，所有实现了 Name() ，Age() 这两个方法的类型都在接口代表的类型集合当中。</p></blockquote><p>那如果这么写呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal2 <span class="keyword">interface</span> &#123;</span><br><span class="line">~<span class="type">int</span></span><br><span class="line">Age2() (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代表 Animal2 代表的类型集满足两个条件</strong></p><ul><li><p>1.底层类型是 int 底层类型</p></li><li><p>2.具有 Age2() (int, error) 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal2 <span class="keyword">interface</span> &#123;</span><br><span class="line">~<span class="type">int</span></span><br><span class="line">Age2() (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> AnimalImpl[T Animal2] <span class="keyword">struct</span> &#123;</span><br><span class="line">age T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Animal2 实现</span></span><br><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c myInt)</span></span> Age2() (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有实现</span></span><br><span class="line"><span class="comment">// type myString string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// func (c myString) Age2() (int, error) &#123;</span></span><br><span class="line"><span class="comment">// return 1, nil</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> my myInt = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> s1 AnimalImpl[myInt] = AnimalImpl[myInt]&#123;</span><br><span class="line">age: my,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  报错 myString does not implement Animal2</span></span><br><span class="line"><span class="comment">var mystring myString = &quot;1&quot;</span></span><br><span class="line"><span class="comment">var s2 AnimalImpl[myString] = AnimalImpl[myString]&#123;</span></span><br><span class="line"><span class="comment">age: mystring,</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">fmt.Println(s2)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>基本接口(Basic interface):如果接口中只存在方法，那么是基本接口。</p></li><li><p>一般接口(General interface)：接口中存在方法和类型，那么是一般接口。</p></li><li><p><strong>一般接口类型不能用来定义变量，只能用于泛型的类型约束中</strong>。</p></li></ul><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Int64 <span class="keyword">interface</span> &#123;</span><br><span class="line">~<span class="type">int64</span> | ~<span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NumberPlayer[T Int64] <span class="keyword">interface</span> &#123;</span><br><span class="line">AddCounter() T</span><br><span class="line">MinusCounter() T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter[T Int64] <span class="keyword">struct</span> &#123;</span><br><span class="line">t       T</span><br><span class="line">counter T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter[T])</span></span> AddCounter() T &#123;</span><br><span class="line">c.t += c.counter</span><br><span class="line"><span class="keyword">return</span> c.t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter[T])</span></span> MinusCounter() T &#123;</span><br><span class="line">c.t -= c.counter</span><br><span class="line"><span class="keyword">return</span> c.t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNumberPlayer</span>[<span class="title">T</span> <span class="title">Int64</span>]<span class="params">(t T, counter T)</span></span> NumberPlayer[T] &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Counter[T]&#123;</span><br><span class="line">t:       t,</span><br><span class="line">counter: counter,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">numbers := NewNumberPlayer(<span class="type">int64</span>(<span class="number">32</span>), <span class="type">int64</span>(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">println</span>(numbers.AddCounter())</span><br><span class="line"><span class="built_in">println</span>(numbers.MinusCounter())</span><br><span class="line"></span><br><span class="line">numbersAgain := NewNumberPlayer(<span class="type">uint64</span>(<span class="number">32</span>), <span class="type">uint64</span>(<span class="number">9</span>))</span><br><span class="line"><span class="built_in">println</span>(numbersAgain.AddCounter())</span><br><span class="line"><span class="built_in">println</span>(numbersAgain.MinusCounter())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类型要使用的话必须传入类型实参实例化才有意义。所以我们来尝试实例化一下这两个接口。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>接口有一般接口和基本接口。</li><li>一般接口不能用于定义类型遍历，只能用与约束。</li><li>泛型类型要使用的话必须传入类型实参实例化才有意义。</li><li>泛型不能与匿名方法或者函数一起使用</li><li>泛型不能与类型断言起使用。</li><li>泛型并不取代Go1.18之前用接口+反射实现的动态类型，泛型最适合的场景：当你需要针对不同类型书写同样的逻辑，使用泛型来简化代码是最好的 (比如你想写个队列，写个链表、栈、堆之类的数据结构）</li><li>泛型的三个重要概念，分别是：<ul><li>类型参数：泛型的抽象数据类型。</li><li>类型约束：确保调用方能够满足接受方的程序诉求。</li><li>类型推导：避免明确地写出一些或所有的类型参数。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-泛型基础篇（一）</title>
      <link href="/2022/10/27/golang/golang-%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/10/27/golang/golang-%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本文简单介绍go泛型的概念和使用。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数很简单，但是它无法计算int类型之外的和。如果我们想计算浮点或者字符串的和该怎么办？解决方法就是对它进行方法的重载。但是golang不支持对方法进行重载。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddFloat32</span><span class="params">(a <span class="type">float32</span>, b <span class="type">float32</span>)</span></span> <span class="type">float32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddString</span><span class="params">(a <span class="type">float64</span>, b <span class="type">float64</span>)</span></span> <span class="type">float64</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过泛型来解决。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">float64</span>]<span class="params">(a T, b T)</span></span> T &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型方法</strong>:该方法在调用时可以接收<code>不同类型</code>的参数。一个函数获得了处理<code>多种不同类型数据</code>的能力，这种编程方式被称为 <code>泛型编程</code>。<br>泛型有着自己的适用场景: 如果你经常要分别为<code>不同的类型</code>写完全相同逻辑的代码，那么使用泛型将是最合适的选择。</p><h2 id="Go的泛型"><a href="#Go的泛型" class="headerlink" title="Go的泛型"></a>Go的泛型</h2><p>之前我们定义一个可以容纳 int 或 float32或 int32 等其他类型的切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> intSlice []<span class="type">int</span> </span><br><span class="line"><span class="keyword">type</span> Float32Slie []<span class="type">float32</span></span><br><span class="line"><span class="keyword">type</span> int32Slice []<span class="type">int32</span> </span><br></pre></td></tr></table></figure><p>现在我们可以这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不同于一般的类型定义，这里类型名称 SliceT 后带了中括号</span></span><br><span class="line"><span class="keyword">type</span> SliceT[T <span class="type">int</span> | <span class="type">float32</span> | <span class="type">int32</span> ] []T</span><br></pre></td></tr></table></figure><ul><li>类型形参: T   在定义<code>SliceT</code>类型的时候 T 代表的具体类型并不确定，类似一个占位符。</li><li>类型约束: <code>int | float32 | int32 </code> 中间的 | 的意思是告诉编译器，类型形参 T 只可以接收 int 或 float32 或 float64 这三种类型的实参。</li><li>类型形参列表： <code> T  int | float32 | int32</code> 。</li><li>这里新定义的类型名称叫 <code>SliceT[T]</code>。</li></ul><blockquote><p>泛型类型:类型定义中带 <code>类型形参</code> 的类型</p></blockquote><h2 id="泛型实例"><a href="#泛型实例" class="headerlink" title="泛型实例"></a>泛型实例</h2><h3 id="切片泛型定义"><a href="#切片泛型定义" class="headerlink" title="切片泛型定义"></a>切片泛型定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceT[T <span class="type">int</span> | <span class="type">float32</span> | <span class="type">int32</span> | <span class="type">string</span>] []T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 这里传入了类型实参int，泛型类型SliceT[T]被实例化为具体的类型 Slice[int]</span></span><br><span class="line"><span class="keyword">var</span> a SliceT[<span class="type">int</span>] = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Type Name: %T\n&quot;</span>, a) <span class="comment">//输出：Type Name: Slice[int]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入类型实参float32, 将泛型类型SliceT[T]实例化为具体的类型 Slice[string]</span></span><br><span class="line"><span class="keyword">var</span> b SliceT[<span class="type">float32</span>] = []<span class="type">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Type Name: %T\n&quot;</span>, b) <span class="comment">//输出：Type Name: Slice[float32]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✗ 错误。string不在类型约束 int|float32|float64 中，不能用来实例化泛型类型</span></span><br><span class="line"><span class="comment">//var c SliceT[string] = []string&#123;&quot;Hello&quot;, &quot;World&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map泛型定义"><a href="#map泛型定义" class="headerlink" title="map泛型定义"></a>map泛型定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyMap[KEY <span class="type">int</span> | <span class="type">string</span>, VALUE <span class="type">float32</span> | <span class="type">float64</span>] <span class="keyword">map</span>[KEY]VALUE</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mp MyMap[<span class="type">string</span>, <span class="type">float64</span>] = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float64</span>&#123;</span><br><span class="line"><span class="string">&quot;jack_score&quot;</span>: <span class="number">9.6</span>,</span><br><span class="line"><span class="string">&quot;bob_score&quot;</span>:  <span class="number">8.4</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="channel泛型定义"><a href="#channel泛型定义" class="headerlink" title="channel泛型定义"></a>channel泛型定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyChan[T <span class="type">int</span> | <span class="type">string</span>] <span class="keyword">chan</span> T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ChanFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(MyChan[<span class="type">int</span>], <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="接口泛型定义"><a href="#接口泛型定义" class="headerlink" title="接口泛型定义"></a>接口泛型定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个泛型接口</span></span><br><span class="line"><span class="keyword">type</span> IPrintData[T <span class="type">int</span> | <span class="type">float32</span> | <span class="type">string</span>] <span class="keyword">interface</span> &#123;</span><br><span class="line">    Print(data T)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单结构体泛型定义"><a href="#简单结构体泛型定义" class="headerlink" title="简单结构体泛型定义"></a>简单结构体泛型定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个泛型类型的结构体。可用 int 或 sring 类型实例化</span></span><br><span class="line"><span class="keyword">type</span> MyStruct[T <span class="type">int</span> | <span class="type">string</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Data T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyStruct2[T <span class="type">int</span> | <span class="type">string</span>, A <span class="type">int</span> | <span class="type">bool</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Data T</span><br><span class="line">Sex  A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StructFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> my MyStruct[<span class="type">int</span>] = MyStruct[<span class="type">int</span>]&#123;</span><br><span class="line">Name: <span class="string">&quot;caicai&quot;</span>,</span><br><span class="line">Data: <span class="number">23</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(my)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> my2 MyStruct2[<span class="type">int</span>, <span class="type">bool</span>] = MyStruct2[<span class="type">int</span>, <span class="type">bool</span>]&#123;</span><br><span class="line">Name: <span class="string">&quot;caicai&quot;</span>,</span><br><span class="line">Data: <span class="number">23</span>,</span><br><span class="line">Sex:  <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(my2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="类型形参的互相套用"><a href="#类型形参的互相套用" class="headerlink" title="类型形参的互相套用"></a>类型形参的互相套用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceT[T <span class="type">int</span> | <span class="type">float32</span> | <span class="type">int32</span> | <span class="type">string</span>] []T</span><br><span class="line"><span class="keyword">type</span> SliceT2[T <span class="type">int</span> | <span class="type">float32</span> | <span class="type">int32</span>] []T</span><br><span class="line"><span class="keyword">type</span> MyStruct3[T <span class="type">int</span> | <span class="type">string</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="type">string</span></span><br><span class="line">Data  T</span><br><span class="line">habby SliceT[T]</span><br><span class="line"><span class="comment">//habby2 SliceT2[T]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Struct2Func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> my MyStruct3[<span class="type">string</span>] = MyStruct3[<span class="type">string</span>]&#123;</span><br><span class="line">Name:  <span class="string">&quot;caicai&quot;</span>,</span><br><span class="line">Data:  <span class="string">&quot;23&quot;</span>,</span><br><span class="line">habby: []<span class="type">string</span>&#123;<span class="string">&quot;swim&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(my)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 <code>MyStruct3</code>的约束是 <code>int或 string</code> 当传入的 <code>string</code> 时，属性habby2 不满足<code>string</code>，报错。</p><h2 id="几种语法错误"><a href="#几种语法错误" class="headerlink" title="几种语法错误"></a>几种语法错误</h2><ul><li>定义泛型类型的时候，基础类型不能只有类型形参，如下：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误，类型形参不能单独使用</span></span><br><span class="line"><span class="keyword">type</span> CommonType[T <span class="type">int</span>|<span class="type">string</span>|<span class="type">float32</span>] T</span><br></pre></td></tr></table></figure></li><li>当类型约束的一些写法会被编译器误认为是表达式时会报错<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//✗ 错误。T *int会被编译器误认为是表达式 T乘以int，而不是int指针</span></span><br><span class="line"><span class="keyword">type</span> NewType[T *<span class="type">int</span>] []T</span><br><span class="line"><span class="comment">// 上面代码再编译器眼中：它认为你要定义一个存放切片的数组，数组长度由 T 乘以 int 计算得到</span></span><br><span class="line"><span class="keyword">type</span> NewType [T * <span class="type">int</span>][]T </span><br><span class="line"></span><br><span class="line"><span class="comment">//✗ 错误。和上面一样，这里不光*被会认为是乘号，| 还会被认为是按位或操作</span></span><br><span class="line"><span class="keyword">type</span> NewType2[T *<span class="type">int</span>|*<span class="type">float64</span>] []T </span><br><span class="line"></span><br><span class="line"><span class="comment">//✗ 错误</span></span><br><span class="line"><span class="keyword">type</span> NewType2 [T (<span class="type">int</span>)] []T </span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 为了避免这种误解，解决办法就是给类型约束包上 <span class="keyword">interface</span>&#123;&#125; 或加上逗号消除歧义</span><br><span class="line"><span class="keyword">type</span> NewType[T <span class="keyword">interface</span>&#123;*<span class="type">int</span>&#125;] []T</span><br><span class="line"><span class="keyword">type</span> NewType2[T <span class="keyword">interface</span>&#123;*<span class="type">int</span>|*<span class="type">float64</span>&#125;] []T </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果类型约束中只有一个类型，可以添加个逗号消除歧义</span></span><br><span class="line"><span class="keyword">type</span> NewType3[T *<span class="type">int</span>,] []T</span><br><span class="line"></span><br><span class="line"><span class="comment">//✗ 错误。如果类型约束不止一个类型，加逗号是不行的</span></span><br><span class="line"><span class="keyword">type</span> NewType4[T *<span class="type">int</span>|*<span class="type">float32</span>,] []T </span><br><span class="line">因为上面逗号的用法限制比较大，这里推荐统一用 <span class="keyword">interface</span>&#123;&#125; 解决问题</span><br></pre></td></tr></table></figure></li></ul><h2 id="泛型类型的套娃"><a href="#泛型类型的套娃" class="headerlink" title="泛型类型的套娃"></a>泛型类型的套娃</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义个泛型类型 Slice[T]</span></span><br><span class="line"><span class="keyword">type</span> Slice[T <span class="type">int</span> | <span class="type">string</span> | <span class="type">float32</span> | <span class="type">float64</span>] []T</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✗ 错误。泛型类型Slice[T]的类型约束中不包含uint, uint8</span></span><br><span class="line"><span class="comment">//type UintSlice[T uint | uint8] Slice[T]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✓ 正确。基于泛型类型Slice[T]定义了新的泛型类型 FloatSlice[T] 。FloatSlice[T]只接受float32和float64两种类型</span></span><br><span class="line"><span class="keyword">type</span> FloatSlice[T <span class="type">float32</span> | <span class="type">float64</span>] Slice[T]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在map中套一个泛型类型Slice[T]</span></span><br><span class="line"><span class="keyword">type</span> WowMap[T <span class="type">int</span> | <span class="type">string</span>] <span class="keyword">map</span>[<span class="type">string</span>]Slice[T]</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>为了实现泛型，Go引入了一些新的概念：<ul><li>类型形参</li><li>类型形参列表</li><li>类型约束</li><li>实例化 - 泛型类型不能直接使用，要使用的话必须传入类型实参进行实例化。</li></ul></li><li>匿名结构体不支持泛型；</li><li>泛型类型的定义；</li><li>泛型类型的嵌套使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
