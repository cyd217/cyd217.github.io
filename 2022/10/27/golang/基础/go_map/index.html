<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>golang-map | 知识是海洋</title><meta name="keywords" content="golang"><meta name="author" content="caicai"><meta name="copyright" content="caicai"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么是Map？声明 &amp; 初始化mapmap是一个拥有键值对元素的无序集合。在这个集合中，键的值是唯一的，键对应的值可以通过键来获取、更新或移除。在 Go 语言中， map是散列表的引用， map的类型是map[K]V ，其中 K 和 V 是字典的键和值对应的数据类型。 map 中所有的键都拥有相同的数据类型，同时所有的值也都拥有相同的数据类型，但是键的类型和值的类型不一定相同。键的类型 K">
<meta property="og:type" content="article">
<meta property="og:title" content="golang-map">
<meta property="og:url" content="http://cyd217.github.io/2022/10/27/golang/%E5%9F%BA%E7%A1%80/go_map/index.html">
<meta property="og:site_name" content="知识是海洋">
<meta property="og:description" content="什么是Map？声明 &amp; 初始化mapmap是一个拥有键值对元素的无序集合。在这个集合中，键的值是唯一的，键对应的值可以通过键来获取、更新或移除。在 Go 语言中， map是散列表的引用， map的类型是map[K]V ，其中 K 和 V 是字典的键和值对应的数据类型。 map 中所有的键都拥有相同的数据类型，同时所有的值也都拥有相同的数据类型，但是键的类型和值的类型不一定相同。键的类型 K">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://cyd217.github.io/img/post/6833939bly1giph4fomxoj20zk0m8axp.jpg">
<meta property="article:published_time" content="2022-10-27T13:38:45.747Z">
<meta property="article:modified_time" content="2022-10-27T13:38:45.747Z">
<meta property="article:author" content="caicai">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cyd217.github.io/img/post/6833939bly1giph4fomxoj20zk0m8axp.jpg"><link rel="shortcut icon" href="/img/R-C.jpg"><link rel="canonical" href="http://cyd217.github.io/2022/10/27/golang/%E5%9F%BA%E7%A1%80/go_map/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'golang-map',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-27 21:38:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/bg.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/R-C.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/post/6833939bly1giph4fomxoj20zk0m8axp.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">知识是海洋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">golang-map</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-27T13:38:45.747Z" title="发表于 2022-10-27 21:38:45">2022-10-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-27T13:38:45.747Z" title="更新于 2022-10-27 21:38:45">2022-10-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/golang/">golang</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="什么是Map？"><a href="#什么是Map？" class="headerlink" title="什么是Map？"></a>什么是Map？</h3><p><strong>声明 &amp; 初始化map</strong><br>map是一个拥有<strong>键值对元素</strong>的无序集合。在这个集合中，<strong>键的值是唯一的</strong>，键对应的值可以通过键来获取、更新或移除。<br>在 Go 语言中， map是散列表的引用， map的类型是map[K]V ，其中 K 和 V 是字典的键和值对应的数据类型。 map 中所有的<strong>键都拥有相同的数据类型</strong>，同时<strong>所有的值也都拥有相同的数据类型</strong>，但是键的类型和值的类型不一定相同。<strong>键的类型 K ，必须是可以通过操作符&#x3D;&#x3D;来进行比较的数据类型</strong>，所以 map 可以检测某一个键是否已经存在。</p>
<h3 id="go-map的数据结构-重点"><a href="#go-map的数据结构-重点" class="headerlink" title="go map的数据结构(重点)"></a>go map的数据结构(重点)</h3><p><strong>核心结体体</strong><br><img src="https://img-blog.csdnimg.cn/15f2a059687d46c59b52bb687069d9af.png" alt="在这里插入图片描述"><br><strong>哈希桶（hmap）</strong><br>指整个哈希数组，数组内每个元素是一个桶。<br><strong>桶链</strong><br>哈希桶的一个桶以及该桶下挂着的所有溢出桶。<br><strong>桶（bucket）</strong><br>一个bmap结构，与溢出桶的区别在于它是哈希桶数组上的一个元素。严格来说hmap.buckets指向桶组成的数组，每个桶的头部是bmap，之后是8个key，再是8个value，最后是1个溢出指针。溢出指针指向额外的桶链表，用于存储溢出的数据<br><strong>溢出桶（overflow bucket）</strong><br>一个bmap结构，与桶区别是，它不是哈希桶数组的元素，而是挂在哈希桶数组上或挂在其它溢出桶上。<br><strong>负载因子(overFactor)</strong><br>表示平均每个哈希桶的元素个数（注意是哈希桶，不包括溢出桶）。如当前map中总共有20个元素，哈希桶长度为4，则负载因子为5。负载因子主要是来判断当前map是否需要扩容。<br>新、旧哈希桶<br>新、旧哈希桶的概念只存在于map扩容阶段，在哈希桶扩容时，会申请一个新的哈希桶，原来的哈希桶变成了旧哈希桶，然后会分步将旧哈希桶的元素迁移到新桶上，当旧哈希桶所有元素都迁移完成时，旧哈希桶会被释放掉。</p>
<p><strong>核心源码</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ( <span class="comment">// 关键的变量</span></span><br><span class="line">    bucketCntBits = <span class="number">3</span></span><br><span class="line">	bucketCnt     = <span class="number">1</span> &lt;&lt; bucketCntBits  <span class="comment">// 一个桶最多存储8个key-value对</span></span><br><span class="line">	loadFactorNum = <span class="number">13</span> <span class="comment">// 扩散因子：loadFactorNum / loadFactorDen = 6.5。</span></span><br><span class="line">	loadFactorDen = <span class="number">2</span>  <span class="comment">// 即元素数量 &gt;= (hash桶数量(2^hmp.B) * 6.5 / 8) 时，触发扩容</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// map的基础数据结构</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count     <span class="type">int</span>	 <span class="comment">// map存储的元素对计数，len()函数返回此值，所以map的len()时间复杂度是O(1)</span></span><br><span class="line">	flags     <span class="type">uint8</span>  <span class="comment">// 记录几个特殊的位标记，如当前是否有别的线程正在写map、当前是否为相同大小的增长（扩容/缩容？）</span></span><br><span class="line">	B         <span class="type">uint8</span>  <span class="comment">// hash桶buckets的数量为2^B个</span></span><br><span class="line">	noverflow <span class="type">uint16</span> <span class="comment">// 溢出的桶的数量的近似值</span></span><br><span class="line">	hash0     <span class="type">uint32</span> <span class="comment">// hash种子</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// 指向2^B个桶组成的数组的指针，数据存在这里</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// 指向扩容前的旧buckets数组，只在map增长时有效</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span>        <span class="comment">// 计数器，标示扩容后搬迁的进度</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra <span class="comment">// 保存溢出桶的链表和未使用的溢出桶数组的首地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap  <span class="comment">//overflow 为 hmap.buckets （当前）溢出桶的指针地址</span></span><br><span class="line">    oldoverflow *[]*bmap  <span class="comment">//oldoverflow 为 hmap.oldbuckets （旧）溢出桶的指针地址</span></span><br><span class="line">    nextOverflow *bmap  <span class="comment">//nextOverflow 为空闲溢出桶的指针地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 桶的实现结构</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// tophash存储桶内每个key的hash值的高字节</span></span><br><span class="line">	<span class="comment">// tophash[0] &lt; minTopHash表示桶的疏散状态</span></span><br><span class="line">	<span class="comment">// 当前版本bucketCnt的值是8，一个桶最多存储8个key-value对</span></span><br><span class="line">	tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">	<span class="comment">// 特别注意：</span></span><br><span class="line">	<span class="comment">// 实际分配内存时会申请一个更大的内存空间A，A的前8字节为bmap</span></span><br><span class="line">	<span class="comment">// 后面依次跟8个key、8个value、1个溢出指针</span></span><br><span class="line">	<span class="comment">// map的桶结构实际指的是内存空间A</span></span><br><span class="line">	keys    [bucketCnt]KeyType</span><br><span class="line">	values  [bucketCnt]ValueType</span><br><span class="line">	overflow *bmap <span class="comment">//溢出bucket的地址</span></span><br><span class="line"><span class="comment">//上述中keys   values  和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map.go里很多函数的第1个入参是这个结构，从成员来看很明显，此结构标示了键值对和桶的大小等必要信息</span></span><br><span class="line"><span class="comment">// 有了这个结构的信息，map.go的代码就可以与键值对的具体数据类型解耦</span></span><br><span class="line"><span class="comment">// 所以map.go用内存偏移量和unsafe.Pointer指针来直接对内存进行存取，而无需关心key或value的具体类型</span></span><br><span class="line"><span class="keyword">type</span> maptype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ        _type</span><br><span class="line">	key        *_type</span><br><span class="line">	elem       *_type</span><br><span class="line">	bucket     *_type <span class="comment">// internal type representing a hash bucket</span></span><br><span class="line">	keysize    <span class="type">uint8</span>  <span class="comment">// size of key slot</span></span><br><span class="line">	valuesize  <span class="type">uint8</span>  <span class="comment">// size of value slot</span></span><br><span class="line">	bucketsize <span class="type">uint16</span> <span class="comment">// size of bucket</span></span><br><span class="line">	flags      <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Go 用了增量扩容。而 buckets 和 oldbuckets 也是与扩容相关的载体，一般情况下只使用 buckets，oldbuckets 是为空的。但如果正在扩容的话，oldbuckets 便不为空，buckets 的大小也会改变</li>
<li>当 hint 大于 8 时，就会使用 *mapextra 做溢出桶。若小于 8，则存储在 buckets 桶中</li>
<li>map底层创建时，会初始化一个hmap结构体，同时分配一个足够大的内存空间A。其中A的前段用于hash数组，A的后段预留给溢出的桶。于是hmap.buckets指向hash数组，即A的首地址；hmap.extra.nextOverflow初始时指向内存A中的后段，即hash数组结尾的下一个桶，也即第1个预留的溢出桶。所以当hash冲突需要使用到新的溢出桶时，会优先使用上述预留的溢出桶，hmap.extra.nextOverflow依次往后偏移直到用完所有的溢出桶，才有可能会申请新的溢出桶空间。<br><img src="https://img-blog.csdnimg.cn/0e450ff30ca54871a8f445552fa3ad15.png" alt="在这里插入图片描述"><br><strong>bmap结构图</strong><br>当往map中存储一个kv对时，通过k获取hash值，<strong>hash值的低八位和bucket数组长度取余</strong>，定位到在数组中的那个下标，hash值的高八位存储在bucket中的tophash中，用来快速判断key是否存在，key和value的具体值则通过指针运算存储，当一个bucket满时，通过overfolw指针链接到下一个bucket。<br><img src="https://img-blog.csdnimg.cn/c2578e8ee4614cf9a9ce28536f62b9fa.png" alt="在这里插入图片描述"></li>
</ul>
<p><strong>为什么不是k1v1，k2v2….. 而是k1k2…v1v2…</strong>，<br>我们看上面的注释说的 map[int64]int8,key是int64（8个字节），value是int8（一个字节），kv的长度不同，如果按照kv格式存放，则考虑内存对齐v也会占用int64，而按照后者存储时，8个v刚好占用一个int64,从这个就可以看出go的map设计之巧妙.</p>
<h3 id="map创建"><a href="#map创建" class="headerlink" title="map创建"></a>map创建</h3><ul>
<li>不带参数   make(map[keyType]valueType)</li>
<li>带参数      make(map[keyType]valueType, size)</li>
</ul>
<p><strong>源码分析</strong></p>
<ul>
<li>创建hmap，并初始化。</li>
<li>获取一个随机种子，保证同一个key在不同map的hash值不一样（安全考量）。</li>
<li>计算初始桶大小。</li>
<li>如果初始桶大小不为0， 则创建桶，有必要还要创建溢出桶结构。<img src="https://img-blog.csdnimg.cn/e4f85d542dcf45a085c023fef7d250a7.png" alt="在这里插入图片描述"></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make(map[k]v, hint), hint即预分配大小</span></span><br><span class="line"><span class="comment">// 不传hint时，如用new创建个预设容量为0的map时，makemap只初始化hmap结构，不分配hash数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;</span><br><span class="line">	<span class="comment">// 1. 创建hmap，并初始化</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h = <span class="built_in">new</span>(hmap)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取一个随机种子</span></span><br><span class="line">	h.hash0 = fastrand()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算初始桶大小。</span></span><br><span class="line">	B := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="comment">// overLoadFactor(hint, B)只有一行代码：return hint &gt; bucketCnt &amp;&amp; uintptr(hint) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span></span><br><span class="line">	<span class="comment">// 即B的大小应满足 hint &lt;= (2^B) * 6.5</span></span><br><span class="line">	<span class="comment">// 一个桶能存8对key-value，所以这就表示B的初始值是保证这个map不需要扩容即可存下hint个元素对的最小的B值</span></span><br><span class="line">	<span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">		B++</span><br><span class="line">	&#125;</span><br><span class="line">	h.B = B</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里分配hash数组</span></span><br><span class="line">	<span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">		h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">		<span class="comment">// makeBucketArray()会在hash数组后面预分配一些溢出桶，</span></span><br><span class="line">		<span class="comment">// h.extra.nextOverflow用来保存上述溢出桶的首地址</span></span><br><span class="line">		<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">			h.extra.nextOverflow = nextOverflow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给map bucket分配内存</span></span><br><span class="line"><span class="comment">//  @param t map的类型</span></span><br><span class="line"><span class="comment">//  @param b 桶的个数2^b</span></span><br><span class="line"><span class="comment">//  @param dirtyalloc 是否要把返回的buckets指向dirtyalloc地址</span></span><br><span class="line"><span class="comment">//  @return buckets buckets地址</span></span><br><span class="line"><span class="comment">//  @return nextOverflow 溢出桶地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBucketArray</span><span class="params">(t *maptype, b <span class="type">uint8</span>, dirtyalloc unsafe.Pointer)</span></span> (buckets unsafe.Pointer, nextOverflow *bmap) &#123;</span><br><span class="line">	base := bucketShift(b) <span class="comment">// base代表用户预期的桶的数量，即hash数组的真实大小</span></span><br><span class="line">	nbuckets := base <span class="comment">// nbuckets表示实际分配的桶的数量，&gt;= base，这就可能会追加一些溢出桶作为溢出的预留</span></span><br><span class="line">	<span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">		<span class="comment">// 这里追加一定数量的桶，并做内存对齐</span></span><br><span class="line">		nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">		sz := t.bucket.size * nbuckets</span><br><span class="line">		up := roundupsize(sz)</span><br><span class="line">		<span class="keyword">if</span> up != sz &#123;</span><br><span class="line">			nbuckets = up / t.bucket.size</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里大家可以思考下这个数组空间要怎么分配，其实就是n*sizeof(桶)，所以：</span></span><br><span class="line">		<span class="comment">// 每个桶前面是8字节的tophash数组，然后是8个key，再是8个value，最后放一个溢出指针</span></span><br><span class="line">		<span class="comment">// sizeof(桶) = 8 + 8*sizeof(key) + 8*sizeof(value) + 8</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> buckets, nextOverflow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>哈希桶初始大小</strong><br>在创建map时，当没有指定size大小或size为0时，不会创建哈希桶，会在插入元素时创建，避免只申请不使用导致的效率和内存浪费。当size不为0时，会根据size大小计算出哈希桶的大小。</p>
<ul>
<li>size &lt;9，bucketLen &#x3D; 1 (2^0) B&#x3D;0</li>
<li>size &lt; 14，bucketLen &#x3D; 2 (2^1) B&#x3D;1</li>
<li>size &lt; 27，bucketLen &#x3D; 4 (2^2) B&#x3D;2</li>
<li>size &lt; 53，bucketLen &#x3D; 8 (2^3) B&#x3D;3</li>
<li>size &lt; 104，bucketLen &#x3D; 16 (2^4) B&#x3D;4</li>
</ul>
<h3 id="插入或更新"><a href="#插入或更新" class="headerlink" title="插入或更新"></a>插入或更新</h3><blockquote>
<p>向nil map赋值会引发panic​<br>map不支持并发读写</p>
</blockquote>
<p>go map的插入操作，调用mapassign()函数。</p>
<ul>
<li>go map需要初始化才能使用，对空map插入会panic。hmap指针传递的方式，决定了map在使用前必须初始化</li>
<li>go map不支持并发读写，会panic。如果一定要并发，请用sync.Map或自己解决冲突。</li>
</ul>
<p>流程分析：</p>
<ul>
<li>判断map是否为空、判断有没有协程并发写。</li>
<li>计算key的哈希值，设置写标志</li>
<li>如果buckets为空，申请一个长度为1的buckets。</li>
<li>找出改key对应的桶位置。</li>
<li>如果map正在迁移切该桶没有被迁移，迁移该桶。</li>
<li>遍历该桶，如果找到相同的key，返回val的位置。如果没有找到，找出下一个空位置，赋值tophash、key，返回val的位置。</li>
<li>判断map是否需要扩容，如果扩容，返回5的操作。</li>
<li>如果当前buckets和溢出buckets都没有位置了，添加一个溢出buckets，赋值tophash、key到第一个空位，返回val的位置。<br>-<img src="https://img-blog.csdnimg.cn/ae3ed1418edf4bffb0e74b0986a4a41c.png"></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增或者替换key val  m[key]=val</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">  <span class="comment">//@Step1 如果map为nil，panic</span></span><br><span class="line">  <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">&quot;assignment to entry in nil map&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断有没有协程正在写map</span></span><br><span class="line">  <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// @Step2</span></span><br><span class="line">  hash := alg.hash(key, <span class="type">uintptr</span>(h.hash0)) <span class="comment">// 这里得到uint32的hash值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置map写的标志</span></span><br><span class="line">  h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">  <span class="comment">//@Step3 buckets为nil，new一个</span></span><br><span class="line">  <span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123;</span><br><span class="line">    h.buckets = newobject(t.bucket) <span class="comment">// newarray(t.bucket, 1)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">  <span class="comment">//@Step4 找出key hash对应的桶</span></span><br><span class="line">  bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">  <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">    <span class="comment">//  @Step5 如果桶需要迁移，则把旧桶迁移</span></span><br><span class="line">    growWork(t, h, bucket)</span><br><span class="line">  &#125;</span><br><span class="line">  b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">  top := tophash(hash)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> inserti *<span class="type">uint8</span></span><br><span class="line">  <span class="keyword">var</span> insertk unsafe.Pointer</span><br><span class="line">  <span class="keyword">var</span> elem unsafe.Pointer</span><br><span class="line">  <span class="comment">//@Step6 寻找map中有没有存在的key</span></span><br><span class="line">  <span class="comment">//  5-1 如果存在，更新key的值，则返回val的位置</span></span><br><span class="line">  <span class="comment">//  5-2 如果不存在，则记录bucket最近一个空位置的tophash 、key、value的位置</span></span><br><span class="line">  <span class="comment">//  5-2-1 判断bucket有没有溢出，如果没有溢出，则下一步。</span></span><br><span class="line">  <span class="comment">//  5-2-2 溢出了则找出下一个溢出桶，继续bucketloop上述操作</span></span><br><span class="line">bucketloop:</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">        <span class="comment">//判断当前元素是否为空，如果为空，记录第一个为空的位置（方便找不到key时插入）</span></span><br><span class="line">        <span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">          inserti = &amp;b.tophash[i]</span><br><span class="line">          insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">          elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">          <span class="keyword">break</span> bucketloop</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">      <span class="keyword">if</span> !t.key.equal(key, k) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">      <span class="comment">//找到了key</span></span><br><span class="line">      <span class="keyword">goto</span> done</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在常规桶中没有找到数据，在溢出桶继续找</span></span><br><span class="line">    ovf := b.overflow(t)</span><br><span class="line">    <span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    b = ovf</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//@Step7 如果添加一个元素会造成bucket超过负载（6.5），或者溢出bucket太多</span></span><br><span class="line">  <span class="comment">//  扩充桶，返回上面逻辑bucketloop继续寻找val位置</span></span><br><span class="line">  <span class="comment">/// overLoadFactor函数用来判断map是否由于数据太多，需要增量1倍扩容</span></span><br><span class="line">  <span class="comment">//负载因子 &gt; 6.5时，也即平均每个bucket存储的键值对达到6.5个。</span></span><br><span class="line">  <span class="comment">//overflow数量 &gt; 2^15时，也即overflow数量超过32768时。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// tooManyOverflowBuckets函数用来判断map是否需要等量迁移，map由于删除操作，溢出bucket很多，但是数据分布很稀疏，我们可以通过等量迁移，将数据更加紧凑的存储在一起，节约空间</span></span><br><span class="line">  <span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">    hashGrow(t, h)</span><br><span class="line">    <span class="keyword">goto</span> again </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//@Step8 当前bucket和溢出桶都满了，重新添加一个溢出桶</span></span><br><span class="line">  <span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">    newb := h.newoverflow(t, b)</span><br><span class="line">    inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">    insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">    elem = add(insertk, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 储存key、tophash的位置。h.count +1</span></span><br><span class="line">  <span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">    kmem := newobject(t.key)</span><br><span class="line">    *(*unsafe.Pointer)(insertk) = kmem</span><br><span class="line">    insertk = kmem</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">    vmem := newobject(t.elem)</span><br><span class="line">    *(*unsafe.Pointer)(elem) = vmem</span><br><span class="line">  &#125;</span><br><span class="line">  typedmemmove(t.key, insertk, key)</span><br><span class="line">  *inserti = top</span><br><span class="line">  h.count++</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回val的位置</span></span><br><span class="line">done:</span><br><span class="line">  <span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  h.flags &amp;^= hashWriting</span><br><span class="line">  <span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">    elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> elem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<blockquote>
<p>1.每个 bucket 有 8 个空位，在没有溢出，且所有的桶都装满了的情况下，装载因子算出来的结果是 8。因此当装载因子超过 6.5 时，表明很多 bucket 都快要装满了，查找效率和插入效率都变低了。在这个时候进行扩容是有必要的。<br>2.在装载因子比较小的情况下，这时候 map 的查找和插入效率也很低，而第 1 点识别不出来这种情况。表面现象就是计算装载因子的分子比较小，即 map 里元素总数少，但是 bucket 数量多（真实分配的 bucket 数量多，包括大量的 overflow bucket）。​原因：不停地插入、删除元素。先插入很多元素，导致创建了很多 bucket，但是装载因子达不到第 1 点的临界值，未触发扩容来缓解这种情况。之后，删除元素降低元素总数量，再插入很多元素，导致创建很多的 overflow bucket，overflow bucket 数量太多，导致 key 会很分散，查找插入效率低得吓人。<br>对于命中条件 1，2 的限制，都会发生扩容。但是扩容的策略并不相同，毕竟两种条件应对的场景不同。​<br>对于 1，元素太多，而 bucket 数量太少，很简单：将 B 加 1，bucket 最大数量(2^B)直接变成原来 bucket 数量的 2 倍。于是，就有新老 bucket 了。注意，这时候元素都在老 bucket 里，还没迁移到新的 bucket 来。新 bucket 只是最大数量变为原来最大数量的 2 倍(2^B*2) 。​<br>对于条件 2，其实元素没那么多，但是 overflow bucket 数特别多，说明很多 bucket 都没装满。解决办法就是开辟一个新 bucket 空间，将老 bucket 中的元素移动到新 bucket，使得同一个 bucket 中的 key 排列地更紧密。这样，原来，在 overflow bucket 中的 key 可以移动到 bucket 中来。结果是节省空间，提高 bucket 利用率，map 的查找和插入效率自然就会提升。​<br>由于 map 扩容需要将原有的 key&#x2F;value 重新搬迁到新的内存地址，如果有大量的 key&#x2F;value 需要搬迁，会非常影响性能。因此 Go map 的扩容采取了一种称为“渐进式”的方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。</p>
</blockquote>
<p>map库容分为<strong>等量迁移和加倍扩容</strong>：等量迁移是为了让稀疏的数据分布更加紧凑（由于删除操作，map可能会很稀疏），加倍扩容是由于插入数据过多，申请一个加倍的空间来存储kv，同时加倍扩容也会删除空的槽位，让数据分布紧凑；<br>扩容后，B 增加了 1，意味着 buckets 总数是原来的 2 倍，原来 1 号的桶“裂变”到两个桶，某个 key 在搬迁前后 bucket 序号可能和原来相等，也可能是相比原来加上 2^B（原来的 B 值），取决于 hash 值 第 6 bit 位是 0 还是 1。原理看下图：</p>
<p><img src="https://img-blog.csdnimg.cn/ef20e9a978d64323b740b1fd21e59584.png" alt="在这里插入图片描述"></p>
<h3 id="删除key-value"><a href="#删除key-value" class="headerlink" title="删除key value"></a>删除key value</h3><p><strong>语法</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>, key)</span><br></pre></td></tr></table></figure>
<p><strong>删除流程</strong><br>1 校验map是否为空，map是否正在写，如果是，则直接报”concurrent map writes”错误<br>2 设置写标志，计算key的哈希值<br>3 计算桶链首地址和tophash<br>4 找到桶链下的所有桶的元素，如果找到key，处理指针相关。<br>5 设置该位置的tophash值，这个逻辑比较复杂，详细会在tophash详解里面介绍<br>6 map总元素个数减1<br>7 清除写标志</p>
<p><img src="https://img-blog.csdnimg.cn/a81eef2e87ab4373b1fb7ef3e0f94b4e.png" alt="在这里插入图片描述"><br><strong>源码分析</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除key、val</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1.判断map是否处于写状态</span></span><br><span class="line">  <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 设置写标志，计算key的哈希值</span></span><br><span class="line">  hash := t.hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">  h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3 找出对应的桶位置</span></span><br><span class="line">  <span class="comment">//  如果需要迁移，继续迁移</span></span><br><span class="line">  bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">  <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">    growWork(t, h, bucket)</span><br><span class="line">  &#125;</span><br><span class="line">  b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">  bOrig := b</span><br><span class="line">  top := tophash(hash)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2</span></span><br><span class="line">  <span class="comment">//  2-1 找出tophash key val位置</span></span><br><span class="line">  <span class="comment">//  2-2 把tophash置为 emptyOne（当前位置为空，但后面还有元素）</span></span><br><span class="line">  <span class="comment">//  2-3 当前bucket后面没有元素，则置为emptyRest（当前位置为空，且后面没有元素）</span></span><br><span class="line">search:</span><br><span class="line">  <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">        <span class="keyword">if</span> b.tophash[i] == emptyRest &#123; <span class="comment">//如果发现对应的tophash已经是emptyRest状态，则标识后面没有数据了</span></span><br><span class="line">          <span class="keyword">break</span> search</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">      k2 := k</span><br><span class="line">      <span class="keyword">if</span> !t.key.equal(key, k2) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">      <span class="comment">//清除val</span></span><br><span class="line">      <span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">        *(*unsafe.Pointer)(e) = <span class="literal">nil</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.elem.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">        memclrHasPointers(e, t.elem.size)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        memclrNoHeapPointers(e, t.elem.size)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 把tophash置为 emptyOne（当前位置为空，但后面还有元素）</span></span><br><span class="line">      b.tophash[i] = emptyOne</span><br><span class="line">      <span class="comment">//3 判断下一个位置（可能是溢出桶第一个）tophash是不是emptyRest</span></span><br><span class="line">      <span class="comment">//  3-1 如果不是，直接到notLast结束流程</span></span><br><span class="line">      <span class="comment">//  3-2 如果是，往前搜索，把所有emptyOne置为emptyRest</span></span><br><span class="line">      <span class="keyword">if</span> i == bucketCnt<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> b.overflow(t) != <span class="literal">nil</span> &amp;&amp; b.overflow(t).tophash[<span class="number">0</span>] != emptyRest &#123;</span><br><span class="line">          <span class="keyword">goto</span> notLast</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> b.tophash[i+<span class="number">1</span>] != emptyRest &#123;</span><br><span class="line">          <span class="keyword">goto</span> notLast</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> &#123;</span><br><span class="line">        b.tophash[i] = emptyRest</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> b == bOrig &#123;</span><br><span class="line">            <span class="keyword">break</span> </span><br><span class="line">          &#125;</span><br><span class="line">          c := b</span><br><span class="line">          <span class="keyword">for</span> b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">          i = bucketCnt - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          i--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> b.tophash[i] != emptyOne &#123;</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    notLast:</span><br><span class="line">      <span class="comment">//数量减1</span></span><br><span class="line">      h.count--</span><br><span class="line">      <span class="keyword">break</span> search</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="map查找"><a href="#map查找" class="headerlink" title="map查找"></a>map查找</h3><p> <strong>语法</strong></p>
<ul>
<li>第一种用法，只返回value值，当key在map中没有找到时，返回value对应类型的默认值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="built_in">print</span>(m[<span class="string">&quot;1&quot;</span>]) -- 结果为: <span class="number">0</span> (返回<span class="type">int</span>对应的默认值)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>第二种用法，返回value值以及key是否存在标志</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">val, ok := m[<span class="string">&quot;1&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(val, ok)  -- 结果为：<span class="number">0</span>, <span class="literal">false</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>第三种用法，返回key和value，只用于range迭代场景</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>整体思路</strong><br><img src="https://img-blog.csdnimg.cn/7bd94f3fe75e49e0bf691f24c0d3a03c.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<p>校验map是否正在写，如果是，则直接报”concurrent map read and map write”错误<br>计算key哈希值，并根据哈希值计算出key所在桶链位置<br>如果map正在扩（等量）容且该桶还未被迁移，定位到旧桶的位置<br>计算tophash值，便于快速查找<br>遍历桶链上的每一个桶，并依次遍历桶内的元素<br>先比较tophash，如果tophash不一致，再比较下一个，如果tophash一致，再比较key值是否相等<br>如果key值相等，计算出value的地址，并取出value值，并直接返回<br>如果key值不相等，则继续比较下一个元素，如果所有元素都不匹配，则直接返回value类型的默认值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 判断是否正在写，如果是直接报错</span></span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 计算key哈希值</span></span><br><span class="line">	alg := t.key.alg</span><br><span class="line">	hash := alg.hash(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 比如 B=5，那 m 就是31，二进制是全 1</span></span><br><span class="line">    <span class="comment">// 求 bucket num 时，将 hash 与 m 相与，</span></span><br><span class="line">    <span class="comment">// 达到 bucket num 由 hash 的低 8 位决定的效果</span></span><br><span class="line">    <span class="comment">//假如 B=5 低5的值就是通的位置，即10。</span></span><br><span class="line">    <span class="comment">// 10010111 | 000011110110110010001111001010100010010110010101010 │ 01010</span></span><br><span class="line">	m := bucketMask(h.B)</span><br><span class="line">	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">	<span class="comment">// 计算tophash值  高8位就是对应的tophash值 10010111--&gt;151,ophash 值（HOB hash）为 151 的 key</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断有没有旧桶（正在迁移）</span></span><br><span class="line">  <span class="comment">//  如果旧桶数据没有被迁移，定位到当前key在旧桶的位置</span></span><br><span class="line">  <span class="comment">//  如果当前旧桶没有被迁移，则迁移桶</span></span><br><span class="line">  <span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !h.sameSizeGrow() &#123; </span><br><span class="line">    <span class="comment">// 新 bucket 数量是老的 2 倍</span></span><br><span class="line">      m &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  求出 key 在老的 map 中的 bucket 位置</span></span><br><span class="line">    oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">    <span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">      b = oldb</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	top := tophash(hash)</span><br><span class="line">bucketloop:</span><br><span class="line">	<span class="comment">// 遍历桶链每个桶  从bucket中找出key对应的val，循环遍历top hash</span></span><br><span class="line">	<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123; </span><br><span class="line">	    <span class="comment">// 遍历桶的元素</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="comment">// 如果tophash不相等，continue</span></span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">			<span class="comment">// 如果top hash为emptyRest，则表示后面没数据了</span></span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123; </span><br><span class="line">					<span class="keyword">break</span> bucketloop</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// tophash相等</span></span><br><span class="line">			<span class="comment">// 获取当前位置对应的key值</span></span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				k = *((*unsafe.Pointer)(k))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果与key匹配，表明找到了，直接返回value值</span></span><br><span class="line">			<span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.valuesize))</span><br><span class="line">				<span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">					v = *((*unsafe.Pointer)(v))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> v</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 一直没有找到，返回value类型的默认值</span></span><br><span class="line">	<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="遍历-mapiterinit"><a href="#遍历-mapiterinit" class="headerlink" title="遍历  mapiterinit"></a>遍历  mapiterinit</h3><p><strong>为什么map是无序的？​</strong><br>遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。这样，遍历 map 的结果就不可能按原来的顺序了。<br>hash表中数据每次插入的位置是变化的（其实是因为实现的原因，一方面hash种子是随机的，这导致相同的数据在不同的map变量内的hash值不同；另一方面即使同一个map变量内，数据删除再添加的位置也有可能变化，因为在同一个桶及溢出链表中数据的位置不分先后），所以为了防止用户错误的依赖于每次迭代的顺序。</p>
<p><strong>整体流程</strong></p>
<ul>
<li>从hash数组中第it.startBucket个桶开始，先遍历hash桶，然后是这个桶的溢出链表。<br>之后hash数组偏移量+1，继续前一步动作。</li>
<li>遍历每一个桶，无论是hash桶还是溢出桶，都从it.offset偏移量开始。（如果只是随机一个开始的桶，range结果还是有序的；但每个桶都加it.offset偏移，这个输出结果就有点扑朔迷离，大家可以亲手试下，对同一个map多次range）</li>
<li>当迭代器经过一轮循环回到it.startBucket的位置，结束遍历。<br><img src="https://img-blog.csdnimg.cn/1e7f667a323f4427897344b1004f2574.png" alt="在这里插入图片描述"></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiterinit</span><span class="params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;</span><br><span class="line">  <span class="comment">//1 初始化迭代器</span></span><br><span class="line">  it.t = t</span><br><span class="line">  <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  it.h = h</span><br><span class="line">  it.B = h.B</span><br><span class="line">  it.buckets = h.buckets</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2 给一个随机数，决定迭代桶的开始位置和桶内开始迭代的顺序</span></span><br><span class="line">  r := <span class="type">uintptr</span>(fastrand())</span><br><span class="line">  <span class="keyword">if</span> h.B &gt; <span class="number">31</span>-bucketCntBits &#123;</span><br><span class="line">    r += <span class="type">uintptr</span>(fastrand()) &lt;&lt; <span class="number">31</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//it.startBucket：这个是hash数组的偏移量，表示遍历从这个桶开始</span></span><br><span class="line">   <span class="comment">//it.offset：这个是桶内的偏移量，表示每个桶的遍历都从这个偏移量开始</span></span><br><span class="line">  it.startBucket = r &amp; bucketMask(h.B)          <span class="comment">//桶的偏移量</span></span><br><span class="line">  it.offset = <span class="type">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>)) <span class="comment">//桶内偏移量</span></span><br><span class="line"></span><br><span class="line">  it.bucket = it.startBucket</span><br><span class="line">  ....</span><br><span class="line">   mapiternext(it) <span class="comment">// 初始化迭代器的同时也返回第1对key/value</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器迭代</span></span><br><span class="line"><span class="comment">//  1 从随机偏移桶循环迭代每个桶数据</span></span><br><span class="line"><span class="comment">//  2 桶内从随机偏移量开始遍历</span></span><br><span class="line"><span class="comment">//  3 列出该方法隐掉了当正在进行扩容时怎么迭代，需要了解参考源码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiternext</span><span class="params">(it *hiter)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123; <span class="comment">//有协程正在写</span></span><br><span class="line">    throw(<span class="string">&quot;concurrent map iteration and map write&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  t := it.t</span><br><span class="line">  bucket := it.bucket</span><br><span class="line">  b := it.bptr</span><br><span class="line">  i := it.i</span><br><span class="line">  checkBucket := it.checkBucket</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">  <span class="keyword">if</span> b == <span class="literal">nil</span> &#123; <span class="comment">//当前桶指针为nil，标识桶内数据已经遍历完成，需要遍历下一个桶</span></span><br><span class="line">    <span class="keyword">if</span> bucket == it.startBucket &amp;&amp; it.wrapped &#123; <span class="comment">//已经遍历到开始的桶</span></span><br><span class="line">      it.key = <span class="literal">nil</span></span><br><span class="line">      it.elem = <span class="literal">nil</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    bucket++</span><br><span class="line">    <span class="keyword">if</span> bucket == bucketShift(it.B) &#123;</span><br><span class="line">      bucket = <span class="number">0</span></span><br><span class="line">      it.wrapped = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ; i &lt; bucketCnt; i++ &#123;</span><br><span class="line">    offi := (i + it.offset) &amp; (bucketCnt - <span class="number">1</span>) <span class="comment">//从桶内哪个位置开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty &#123;<span class="comment">//没数据</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    k := add(unsafe.Pointer(b), dataOffset+<span class="type">uintptr</span>(offi)*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">    e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+<span class="type">uintptr</span>(offi)*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">  b = b.overflow(t)</span><br><span class="line">  i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">goto</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代还需要关注扩容缩容的情况：<br>如果是在迭代开始后才growing，这种情况当前的逻辑没处理，迭代有可能异常。呃，go map不支持并发。<br>如果是先growing，再开始迭代，这是有可能的。这种情况下，会先到旧hash表中检查key对应的桶有没有被疏散，未疏散则遍历旧桶，已疏散则遍历新hash表里对应的桶。</p>
<h3 id="go-map的扩容缩容"><a href="#go-map的扩容缩容" class="headerlink" title="go map的扩容缩容"></a>go map的扩容缩容</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// overLoadFactor()返回true则触发扩容，即map的count大于hash桶数量(2^B)*6.5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="type">int</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="type">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tooManyOverflowBuckets()，顾名思义，溢出桶太多了触发缩容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="type">uint16</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">		B = <span class="number">15</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> noverflow &gt;= <span class="type">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map只在插入元素即mapassign()函数中对是否扩容缩容进行触发，条件即是上面这段代码：</p>
<ul>
<li>条件1：当前不处在growing状态</li>
<li>条件2-1：触发扩容：map的数据量count大于hash桶数量(2B)*6.5。注意这里的(2B)只是hash数组大小，不包括溢出的桶</li>
<li>条件2-2：触发缩容：溢出的桶数量noverflow&gt;&#x3D;32768(1&lt;&lt;15)或者&gt;&#x3D;hash数组大小。<br>仔细观察触发的代码，扩容和缩容是同一个函数，这是怎么做到的呢？在hashGrow()开始，会先判断是否满足扩容条件，如果满足就表明这次是扩容，不满足就一定是缩容条件触发了。扩容和缩容剩下的逻辑，主要区别就在于容量变化，就是hmap.B参数，扩容时B+1则hash表容量扩大1倍，缩容时hash表容量不变。</li>
<li>h.oldbuckets：指向旧的hash数组，即当前的h.buckets</li>
<li>h.buckets：指向新创建的hash数组</li>
</ul>
<p>触发的主要工作已经完成，接下来就是怎么把元素搬迁到新hash表里了。如果现在就一次全量搬迁过去，显然接下来会有比较长的一段时间map被占用（不支持并发）。所以搬迁的工作是异步增量搬迁的。<br>在插入和删除的函数内都有下面一段代码用于在每次插入和删除操作时，执行一次搬迁工作.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> h.growing() &#123; <span class="comment">// 当前处于搬迁状态</span></span><br><span class="line">		growWork(t, h, bucket) <span class="comment">// 调用搬迁函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 将当前需要处理的桶搬迁</span></span><br><span class="line">	evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123; <span class="comment">// 再多搬迁一个桶</span></span><br><span class="line">		evacuate(t, h, h.nevacuate)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每执行一次插入或删除，都会调用growWork搬迁0~2个hash桶（有可能这次需要搬迁的2个桶在此之前都被搬过了）</li>
<li>搬迁是以hash桶为单位的，包含对应的hash桶和这个桶的溢出链表</li>
<li>被delete掉的元素(emptyone标志)会被舍弃（这是缩容的关键）</li>
</ul>
<p><strong>为什么叫“伪缩容”？如何实现“真缩容”？</strong><br>因为缩容仅仅针对<strong>溢出桶太多</strong>的情况，触发缩容时hash数组的大小不变，即hash数组所占用的空间只增不减。也就是说，如果我们把一个已经增长到很大的map的元素挨个全部删除掉，hash表所占用的内存空间也不会被释放。所以如果要实现“真缩容”，需自己实现缩容搬迁，即创建一个较小的map，将需要缩容的map的元素挨个搬迁过来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go map缩容代码示例</span></span><br><span class="line">myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这里我们对bigMap做了很多次插入，之后又做了很多次删除，此时bigMap的元素数量远小于hash表大小</span></span><br><span class="line"><span class="comment">// 接下来我们开始缩容</span></span><br><span class="line">smallMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="built_in">len</span>(myMap))</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">    smallMap[k] = v</span><br><span class="line">&#125;</span><br><span class="line">myMap = smallMap <span class="comment">// 缩容完成，原来的map被我们丢弃，交给gc去清理</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>关键知识点</strong></p>
<p>5.1 基本原理</p>
<ul>
<li>底层是hash实现，数据结构为hash数组 + 桶 + 溢出的桶链表，每个桶存储最多8个key-value对。</li>
<li>查找和插入的原理：key的hash值（低阶位）与桶数量相与，得到key所在的hash桶，再用key的高8位与桶中的tophash[i]对比，相同则进一步对比key值，key值相等则找到</li>
<li>go map不支持并发。插入、删除、搬迁等操作会置writing标志，检测到并发直接panic</li>
<li>每次扩容hash表增大1倍，hash表只增不减</li>
<li>支持有限缩容，delete操作只置删除标志位，释放溢出桶的空间依靠触发缩容来实现。</li>
<li>map在使用前必须初始化，否则panic：已初始化的map是make(map[key]value)或make(map[key]value, hint)这两种形式。而new或var xxx map[key]value这两种形式是未初始化的，直接使用会panic。</li>
</ul>
<p>5.2 时间复杂度和空间复杂度分析<br>时间复杂度，go map是hash实现：</p>
<ul>
<li>正常情况，且<strong>不考虑扩容状态</strong>，复杂度O(1)：通过hash值定位桶是O(1)，一个桶最多8个元素，合理的hash算法应该能把元素相对均匀散列，所以溢出链表（如果有）也不会太长，所以虽然在桶和溢出链表上定位key是遍历，考虑到数量小也可以认为是O(1)</li>
<li>正常情况，处于<strong>扩容状态时</strong>，复杂度也是O(1)：相比于上一种状态，扩容会增加搬迁最多2个桶和溢出链表的时间消耗，当溢出链表不太长时，复杂度也可以认为是O(1)</li>
<li>极端情况，散列极不均匀，大部分数据被集中在一条散列链表上，复杂度退化为O(n)。<br>所以综合情况下go map的时间复杂度应为O(1)</li>
</ul>
<p>空间复杂度分析：<br>首先我们不考虑因删除大量元素导致的空间浪费情况（这种情况现在go是留给程序员自己解决），只考虑一个持续增长状态的map的一个空间使用率：<br>由于溢出桶数量超过hash桶数量时会触发缩容，所以最坏的情况是数据被集中在一条链上，hash表基本是空的，这时空间浪费O(n)。<br>最好的情况下，数据均匀散列在hash表上，没有元素溢出，这时最好的空间复杂度就是扩散因子决定了，当前go的扩散因子由全局变量决定，即loadFactorNum&#x2F;loadFactorDen &#x3D; 6.5。即平均每个hash桶被分配到6.5个元素以上时，开始扩容。所以最小的空间浪费是(8-6.5)&#x2F;8 &#x3D; 0.1875，即O(0.1875n)<br>结论：go map的空间复杂度（指除去正常存储元素所需空间之外的空间浪费）是O(0.1875n) ~ O(n)之间。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://cyd217.github.io">caicai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://cyd217.github.io/2022/10/27/golang/%E5%9F%BA%E7%A1%80/go_map/">http://cyd217.github.io/2022/10/27/golang/%E5%9F%BA%E7%A1%80/go_map/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://cyd217.github.io" target="_blank">知识是海洋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a></div><div class="post_share"><div class="social-share" data-image="/img/post/6833939bly1giph4fomxoj20zk0m8axp.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/27/golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><img class="prev-cover" src="/img/post/2a1a96f06d6248acab61d2a88ba09d3c.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">go-内存管理篇（二） 万字总结-golang内存分配篇</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/27/golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Tcmalloc/"><img class="next-cover" src="/img/post/c1494648e2ed49e9bf0ffcc3efd8f63c.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">go-内存管理篇（一） TCMalloc</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/10/27/goframe/gf_lua/" title="gf_lua脚本"><img class="cover" src="/img/post/6833939bly1gicitht3xtj20zk0m8k5v.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-27</div><div class="title">gf_lua脚本</div></div></a></div><div><a href="/2022/10/27/zookeeper/zookeeper%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9C%BA%E6%99%AF%E7%AF%87/" title="zookeeper学习（四）场景篇"><img class="cover" src="https://img-blog.csdnimg.cn/08ff0dd7eb614f8eb0652dd43b5ddc78.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-27</div><div class="title">zookeeper学习（四）场景篇</div></div></a></div><div><a href="/2022/10/27/golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Tcmalloc/" title="go-内存管理篇（一） TCMalloc"><img class="cover" src="/img/post/c1494648e2ed49e9bf0ffcc3efd8f63c.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-27</div><div class="title">go-内存管理篇（一） TCMalloc</div></div></a></div><div><a href="/2022/10/27/golang/%E5%9F%BA%E7%A1%80/go/" title="golang-值接收者和指针接收者的区别"><img class="cover" src="/img/post/6833939bly1giph4fomxoj20zk0m8axp.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-27</div><div class="title">golang-值接收者和指针接收者的区别</div></div></a></div><div><a href="/2022/10/27/golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/" title="高频问题-逃逸分析"><img class="cover" src="/img/post/6833939bly1giciuja1j1j20zk0m8kjl.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-27</div><div class="title">高频问题-逃逸分析</div></div></a></div><div><a href="/2022/10/27/golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" title="go-内存管理篇（三）内存对齐"><img class="cover" src="/img/post/0156bb5dfd474a7cae6053335e73948b.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-27</div><div class="title">go-内存管理篇（三）内存对齐</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/R-C.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">caicai</div><div class="author-info__description">代码和我，总有一个可以跑！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cyd217"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cyd217" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMap%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是Map？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-map%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%87%8D%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">go map的数据结构(重点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E5%88%9B%E5%BB%BA"><span class="toc-number">3.</span> <span class="toc-text">map创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%88%96%E6%9B%B4%E6%96%B0"><span class="toc-number">4.</span> <span class="toc-text">插入或更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4key-value"><span class="toc-number">5.</span> <span class="toc-text">删除key value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E6%9F%A5%E6%89%BE"><span class="toc-number">6.</span> <span class="toc-text">map查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-mapiterinit"><span class="toc-number">7.</span> <span class="toc-text">遍历  mapiterinit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-map%E7%9A%84%E6%89%A9%E5%AE%B9%E7%BC%A9%E5%AE%B9"><span class="toc-number">8.</span> <span class="toc-text">go map的扩容缩容</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/30/%E9%9D%A2%E8%AF%95%E9%A2%98/zookeeper%E7%AF%87/" title="面试-zk篇"><img src="/img/post/bb04ee5adabd4a4f9d79d54001d17bdd.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试-zk篇"/></a><div class="content"><a class="title" href="/2022/10/30/%E9%9D%A2%E8%AF%95%E9%A2%98/zookeeper%E7%AF%87/" title="面试-zk篇">面试-zk篇</a><time datetime="2022-10-30T06:27:46.612Z" title="发表于 2022-10-30 14:27:46">2022-10-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/28/docker/docker%E5%85%A5%E9%97%A8/" title="无题"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/10/28/docker/docker%E5%85%A5%E9%97%A8/" title="无题">无题</a><time datetime="2022-10-28T14:11:13.571Z" title="发表于 2022-10-28 22:11:13">2022-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/27/redis/redis-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" title="redis-消息队列"><img src="https://img-blog.csdnimg.cn/1ed740d7173c421ea19502ae8cc658d7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis-消息队列"/></a><div class="content"><a class="title" href="/2022/10/27/redis/redis-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" title="redis-消息队列">redis-消息队列</a><time datetime="2022-10-27T13:59:17.788Z" title="发表于 2022-10-27 21:59:17">2022-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/27/redis/Redis%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E2%80%94HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/" title="Redis高级特性—HyperLoglog解决统计问题"><img src="https://img-blog.csdnimg.cn/e642cbd4bb8b4182a58da81cf8636d87.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis高级特性—HyperLoglog解决统计问题"/></a><div class="content"><a class="title" href="/2022/10/27/redis/Redis%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E2%80%94HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/" title="Redis高级特性—HyperLoglog解决统计问题">Redis高级特性—HyperLoglog解决统计问题</a><time datetime="2022-10-27T13:58:17.507Z" title="发表于 2022-10-27 21:58:17">2022-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/27/redis/redis%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-bitmap/" title="别问我内存满了怎么办"><img src="https://img-blog.csdnimg.cn/e642cbd4bb8b4182a58da81cf8636d87.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="别问我内存满了怎么办"/></a><div class="content"><a class="title" href="/2022/10/27/redis/redis%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-bitmap/" title="别问我内存满了怎么办">别问我内存满了怎么办</a><time datetime="2022-10-27T13:57:05.916Z" title="发表于 2022-10-27 21:57:05">2022-10-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/post/6833939bly1giph4fomxoj20zk0m8axp.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By caicai</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script type="text/javascript" src="/js/hourse.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script></div></body></html>