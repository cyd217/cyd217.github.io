<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>知识是海洋</title><meta name="author" content="caicai"><meta name="copyright" content="caicai"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="代码和我，总有一个可以跑！">
<meta property="og:type" content="website">
<meta property="og:title" content="知识是海洋">
<meta property="og:url" content="http://cyd217.github.io/index.html">
<meta property="og:site_name" content="知识是海洋">
<meta property="og:description" content="代码和我，总有一个可以跑！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://cyd217.github.io/img/R-C.jpg">
<meta property="article:author" content="caicai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cyd217.github.io/img/R-C.jpg"><link rel="shortcut icon" href="/img/R-C.jpg"><link rel="canonical" href="http://cyd217.github.io/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '知识是海洋',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-11-01 22:19:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/bg.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/R-C.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/img/6833939bly1gipet8c1a2j20zk0m8kct.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">知识是海洋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">知识是海洋</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://github.com/cyd217" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/2022/11/01/redis/redis-%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F/" title="redis-主从"><img class="post_bg" src="https://img-blog.csdnimg.cn/acb212b1d4754107bde6140f42cc9550.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis-主从"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/11/01/redis/redis-%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F/" title="redis-主从">redis-主从</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-01T14:17:07.587Z" title="发表于 2022-11-01 22:17:07">2022-11-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/redis/">redis</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/redis/">redis</a></span></div><div class="content">由于数据都是存储在一台服务器上，如果出事就完犊子了，比如：

服务器发生了宕机，这个期间是无法服务新的请求的；
服务器的硬盘出现了故障，可能数据就都丢失了。

要避免这种单点故障，最好的办法是将数据备份到其他服务器上，让这些服务器也可以对外提供服务。
主从复制概述主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。（redis有主从同步，从从同步）。
主从复制的作用主要包括：

数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
负载均衡，读写分离：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/11/01/redis/redis%E4%BA%8B%E5%8A%A1/" title="简单说明redis事务"><img class="post_bg" src="https://img-blog.csdnimg.cn/1a68c64a4059400b806be6b21c51159f.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="简单说明redis事务"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/11/01/redis/redis%E4%BA%8B%E5%8A%A1/" title="简单说明redis事务">简单说明redis事务</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-01T14:13:11.363Z" title="发表于 2022-11-01 22:13:11">2022-11-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/redis/">redis</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/redis/">redis</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="content">Redis的事务可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序串行化的执行而不会被其他命令插入。Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。这个与Redis的特点：快速、高效有着密切的关联，因为一些列回滚操作、像事务隔离级别那这样加锁、解锁，是非常消耗性能的。
相关指令Redis中执行事务的流程只需要简单的下面三个步骤：

开始事务（MULTI）
命令入队
执行事务（EXEC）、撤销事务（DISCARD ）

在Redis中事务的实现主要是通过如下的命令实现的：



命令
功能描述



MULTI
事务开始的命令，执行该命令后，后面执行的对Redis数据类型的操作命令都会顺序的放进队列，等待执行EXEC命令后队列中的命令才会被执行


DISCARD
放弃执行队列中的命令，你可以理解为Mysql的回滚操作。


EXEC
顺序执行队列中的命令，执行完后并将结果显示在客户端。若是执行该命令之前有key被执行WATCH命令并且又被其它客户端修改，那么就会放弃执行队列中的所有命令， ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/11/01/redis/redis%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" title="实战分析-排查Redis性能问题"><img class="post_bg" src="https://img-blog.csdnimg.cn/4d1386aee574413882e7bb1e6ebfb336.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="实战分析-排查Redis性能问题"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/11/01/redis/redis%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" title="实战分析-排查Redis性能问题">实战分析-排查Redis性能问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-01T14:09:59.275Z" title="发表于 2022-11-01 22:09:59">2022-11-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/redis/">redis</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/redis/">redis</a></span></div><div class="content">前言你们是否遇到过以下这些场景：

在 Redis 上执行同样的命令，为什么有时响应很快，有时却很慢？
为什么 Redis 执行 SET、DEL 命令耗时也很久？
为什么我的 Redis 突然慢了一波，之后又恢复正常了？
为什么我的 Redis 稳定运行了很久，突然从某个时间点开始变慢了？

ps：我遇到过2，4。
Redis真的变慢了吗？首先，在开始之前，你需要弄清楚Redis是否真的变慢了？
如果你发现你的业务服务 API 响应延迟变长，首先你需要先排查服务内部，究竟是哪个环节拖慢了整个服务。比较高效的做法是，在服务内部集成链路追踪(打印日志的方式也可以)，也就是在服务访问外部依赖的出入口，记录每次请求外部依赖的响应延时。如果你发现确实是操作 Redis 的这条链路耗时变长了，那么此刻你需要把焦点关注在业务服务到 Redis 这条链路上。 Redis这条链路变慢的原因可能也有 2 个：

业务服务器到 Redis 服务器之间的网络存在问题，例如网络线路质量不佳，网络数据包在传输时存在延迟、丢包等情况；
Redis 本身存在问题，需要进一步排查是什么原因导致 Redis 变慢。

* ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/11/01/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="分布式-分布式锁的实现"><img class="post_bg" src="https://img-blog.csdnimg.cn/1b4ebdc6c7a74d9d9e749b3705782e9d.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式-分布式锁的实现"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/11/01/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="分布式-分布式锁的实现">分布式-分布式锁的实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-01T14:04:57.996Z" title="发表于 2022-11-01 22:04:57">2022-11-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span></div><div class="content">什么是分布式锁说到Redis，我们第一想到的功能就是可以缓存数据，除此之外，Redis因为单进程、性能高的特点，它还经常被用于做分布式锁。
分布式锁，顾名思义，就是分布式项目开发中用到的锁，可以用来控制分布式系统之间同步访问共享资源，一般来说，分布式锁需要满足的特性有这么几点：

1、互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁；
2、高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署；
3、防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁；
4、独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了；
5、可重入性:一个线程如果获取了锁之后,可以再次对其请求加锁。

分布式锁常见的三种实现方式
数据库乐观锁；
基于Redis的分布式锁；
基于ZooKeeper的分布式锁。

第一种:redis实现
加锁：SET EX PX NX  + 校验唯一随机值Redis分布式锁大部分人都会想到：setnx ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/11/01/redis/Redis%20%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%20IO%20%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="Redis 高性能之 IO 多路复用"><img class="post_bg" src="https://img-blog.csdnimg.cn/b8e978e3a28842aebbeab9cbbbde8782.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis 高性能之 IO 多路复用"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/11/01/redis/Redis%20%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%20IO%20%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="Redis 高性能之 IO 多路复用">Redis 高性能之 IO 多路复用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-01T13:44:09.661Z" title="发表于 2022-11-01 21:44:09">2022-11-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/redis/">redis</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/redis/">redis</a></span></div><div class="content">Redis那么快的原因
纯内存操作
使用IO多路复用技术
非CPU密集型任务
单线程的优势
纯内存操作

Redis是一个内存数据库，它的数据都存储在内存中，这意味着读写数据都是在内存中完成，这个速度是非常快的。它内部构建了一个哈希表，根据指定的KEY访问时，只需要O(1)的时间复杂度就可以找到对应的数据。
使用IO多路复用技术Redis采用了IO多路复用技术和非阻塞IO，这个技术由操作系统实现提供，Redis可以方便地操作系统的API即可。Redis可以在单线程中监听多个Socket的请求，在任意一个Socket可读/可写时，Redis去读取客户端请求，在内存中操作对应的数据，然后再写回到Socket中。整个过程非常高效，Redis利用了IO多路复用技术的事件驱动模型，保证在监听多个Socket连接的情况下，只针对有活动的Socket采取反应。
非CPU密集型任务采用单线程的缺点很明显，无法使用多核CPU。由于Redis的大部分操作并不是CPU密集型任务，而Redis的瓶颈在于内存和网络带宽。在高并发请求下，Redis需要更多的内存和更高的网络带宽，否则瓶颈很容易出现在内存不够用和网 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/10/30/redis/redis-%E4%B8%89%E5%A4%A7%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/" title="redis-三大缓存问题"><img class="post_bg" src="https://img-blog.csdnimg.cn/1a68c64a4059400b806be6b21c51159f.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis-三大缓存问题"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/10/30/redis/redis-%E4%B8%89%E5%A4%A7%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/" title="redis-三大缓存问题">redis-三大缓存问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-10-30T14:40:51.382Z" title="发表于 2022-10-30 22:40:51">2022-10-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/redis/">redis</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/redis/">redis</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="content">前言日常的开发中，无不都是使用数据库来进行数据的存储，由于一般的系统任务中通常不会存在高并发的情况，所以这样看起来并没有什么问题。一旦涉及大数据量的需求，如一些商品抢购的情景，或者主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读&#x2F;写速度问题有严重的性能弊端，在这一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读&#x2F;写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。为了克服上述的问题，项目通常会引入NoSQL技术，这是一种基于内存的数据库，并且提供一定的持久化功能。但同时，它也带来了一些问题。其中，最要害的问题，就是**数据的一致性**问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。另外的一些典型问题就是，缓存穿透、缓存击穿和缓存雪崩。本篇文章从实际代码操作，来提出解决这三个缓存问题的方案，毕竟Redis的缓存问题是实际面试中高频问点，理论和实操要兼得。
缓存穿透缓存穿透是指查询一条**数据库和缓存都没有**的一条数据，就会一直查询数据库 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/10/30/%E9%9D%A2%E8%AF%95%E9%A2%98/redis/" title="面试-redis篇"><img class="post_bg" src="https://img-blog.csdnimg.cn/c926524dd2e242a48cebf016bc30cbc6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试-redis篇"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/10/30/%E9%9D%A2%E8%AF%95%E9%A2%98/redis/" title="面试-redis篇">面试-redis篇</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-10-30T06:34:03.715Z" title="发表于 2022-10-30 14:34:03">2022-10-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/redis/">redis</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="content">redis三大缓存问题redis和db如何保证数据一致性3.Redis持久化方式：rdb、aof；redis中哪个版本开始可以对分布式使用sortedSet的底层数据结构利用redis实现分布式锁redis使用单线程的好处redis中如何控制多线程并发redis删除key的策略redis的主动缓存，被动缓存如何保证数据一致性问题集群环境下如何处理，解释一下一致性哈希缓存数据如何同DB同步更新？你的项目中使用了Redis，你在哪些地方使用了Redis排行榜功能的实现：使用redis的zset；zset的底层数据结构是什么样的；除了redis的zset还有什么其他的数据结构可以实现这个功能</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/10/30/%E9%9D%A2%E8%AF%95%E9%A2%98/zookeeper%E7%AF%87/" title="面试-zk篇"><img class="post_bg" src="/img/post/bb04ee5adabd4a4f9d79d54001d17bdd.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试-zk篇"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/10/30/%E9%9D%A2%E8%AF%95%E9%A2%98/zookeeper%E7%AF%87/" title="面试-zk篇">面试-zk篇</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-10-30T06:27:46.612Z" title="发表于 2022-10-30 14:27:46">2022-10-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/zookeeper/">zookeeper</a></span></div><div class="content">zookeeper场景面试题1.为什么ZooKeeper可以作为注册中心zookeeper作为注册中心依赖于临时节点和watch监听机制。分布式系统就无法避免对节点管理的问题(实时感知节点的状态、节点进行统一管理等等)。服务注册、发现过程简述如下：

服务提供者启动时，会将其服务名称，ip地址（临时节点）注册到配置中心。
服务消费者在第一次调用服务时，会通过注册中心找到相应服务的ip地址列表，并缓存到本地，以供后续使用。当消费者调用服务时，不会再去请求注册中心，而是直接通过负载均衡算法从ip列表中取一个服务提供者的服务器调用服务。
当服务提供者的某台服务器宕机或下线时，相应的ip会从服务提供者ip列表中移除。同时，注册中心会将新的服务ip地址列表发送给服务消费者机器，缓存在消费者本机（watch）。
当某个服务的所有服务器都下线了，那么这个服务也就下线了。
同样，当服务提供者的某台服务器上线时，注册中心会将新的服务ip地址列表发送给服务消费者机器，缓存在消费者本机（watch)。

zookeeper提供了“心跳检测”功能，它会定时向各个服务提供者发送一个请求( socket 长连接) ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/10/28/docker/docker%E5%85%A5%E9%97%A8/" title="docker入门篇---初始docker（一）"><img class="post_bg" src="https://img-blog.csdnimg.cn/07aa2018a6084712864c3b6e1b4d9b75.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="docker入门篇---初始docker（一）"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/10/28/docker/docker%E5%85%A5%E9%97%A8/" title="docker入门篇---初始docker（一）">docker入门篇---初始docker（一）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-10-28T14:11:13.571Z" title="发表于 2022-10-28 22:11:13">2022-10-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/docker/">docker</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/docker/">docker</a></span></div><div class="content">docker为什么会出现？一款产品：开发—-&gt;运维，两套环境！应用环境，应用配置！常见问题：我的电脑可以运行，版本更新，导致服务不可用。环境配置十分的麻烦，每个机器都需要部署环境（redis集群，es等。。。。）。不能跨平台。发布项目（jar+mysql+redis。。。），项目能不能带上环境去发布。传统：开发jar，运维来做！现在：开发打包部署上线，一套流程。
以上问题，docker提出解决方法。java —&gt;jar(环境)—-&gt;（打包项目带上环境）镜像—-&gt;(docker)—-&gt;下载镜像—-&gt;运行。docker的核心思想：**隔离，打包装箱，每个箱子互相隔离**。
文档：https://docs.docker.com/仓库：https://hub.docker.com/
docker能干嘛
之前的虚拟机技术


缺点：1.资源占用多；2.冗余步骤多；3.启动慢。

容器化技术

与传统的虚拟机不同：

传统的虚拟机：运行一个完成的操作系统，在这个系统中安装和运行。
容器化：应用直接运行在宿主机的内核上，容器自己没有内核， 每个容器间，相互隔离，互 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/10/27/redis/redis-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" title="redis-消息队列"><img class="post_bg" src="https://img-blog.csdnimg.cn/1ed740d7173c421ea19502ae8cc658d7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis-消息队列"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/10/27/redis/redis-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" title="redis-消息队列">redis-消息队列</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-10-27T13:59:17.788Z" title="发表于 2022-10-27 21:59:17">2022-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/redis/">redis</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/redis/">redis</a></span></div><div class="content">回顾消息队列消息队列 是指利用 高效可靠 的消息传递机制 进行与平台无关的 数据交流，并基于数据通信来进行分布式系统的集成。通过提供 消息传递 和 消息排队 模型，它可以在 分布式环境 下提供 应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步 等等功能。消息队列常见的使用场景：

比如电商里的下单后与会员积分、物流订单等异步解耦处理
电商促销短信下发，使用MQ来削峰填谷

三个角色：生产者、消费者、消息处理中心异步处理模式：生产者 将消息发送到一条 虚拟的通道（消息队列）上，而无须等待响应。消费者则订阅或是监听该通道，取出消息。两者互不干扰，甚至都不需要同时在线，也就是我们说的松耦合。一般设计消息队列需要考虑三个需求，分别是

消息保序：对应消息需要有序消费的场景;
处理重复消息：如网络抖动引起的同一条消息多次被投递到队列的场景;
保证消息可靠性：消息从队列取出，此时客户端宕机，消息未正常消费的场景;

市面上已经存在专业的 MQ有RocketMQ、Kafka等，为什么还需要Redis来自定义实现消息队列？

重！需要额外的成本负担，包括运维成本、学习成本等等；所以如果你的场 ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/#content-inner">4</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/R-C.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">caicai</div><div class="author-info__description">代码和我，总有一个可以跑！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cyd217"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cyd217" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/01/redis/redis-%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F/" title="redis-主从"><img src="https://img-blog.csdnimg.cn/acb212b1d4754107bde6140f42cc9550.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis-主从"/></a><div class="content"><a class="title" href="/2022/11/01/redis/redis-%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F/" title="redis-主从">redis-主从</a><time datetime="2022-11-01T14:17:07.587Z" title="发表于 2022-11-01 22:17:07">2022-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/01/redis/redis%E4%BA%8B%E5%8A%A1/" title="简单说明redis事务"><img src="https://img-blog.csdnimg.cn/1a68c64a4059400b806be6b21c51159f.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="简单说明redis事务"/></a><div class="content"><a class="title" href="/2022/11/01/redis/redis%E4%BA%8B%E5%8A%A1/" title="简单说明redis事务">简单说明redis事务</a><time datetime="2022-11-01T14:13:11.363Z" title="发表于 2022-11-01 22:13:11">2022-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/01/redis/redis%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" title="实战分析-排查Redis性能问题"><img src="https://img-blog.csdnimg.cn/4d1386aee574413882e7bb1e6ebfb336.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="实战分析-排查Redis性能问题"/></a><div class="content"><a class="title" href="/2022/11/01/redis/redis%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" title="实战分析-排查Redis性能问题">实战分析-排查Redis性能问题</a><time datetime="2022-11-01T14:09:59.275Z" title="发表于 2022-11-01 22:09:59">2022-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/01/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="分布式-分布式锁的实现"><img src="https://img-blog.csdnimg.cn/1b4ebdc6c7a74d9d9e749b3705782e9d.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式-分布式锁的实现"/></a><div class="content"><a class="title" href="/2022/11/01/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="分布式-分布式锁的实现">分布式-分布式锁的实现</a><time datetime="2022-11-01T14:04:57.996Z" title="发表于 2022-11-01 22:04:57">2022-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/01/redis/Redis%20%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%20IO%20%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="Redis 高性能之 IO 多路复用"><img src="https://img-blog.csdnimg.cn/b8e978e3a28842aebbeab9cbbbde8782.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis 高性能之 IO 多路复用"/></a><div class="content"><a class="title" href="/2022/11/01/redis/Redis%20%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%20IO%20%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="Redis 高性能之 IO 多路复用">Redis 高性能之 IO 多路复用</a><time datetime="2022-11-01T13:44:09.661Z" title="发表于 2022-11-01 21:44:09">2022-11-01</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/docker/"><span class="card-category-list-name">docker</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/golang/"><span class="card-category-list-name">golang</span><span class="card-category-list-count">14</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/redis/"><span class="card-category-list-name">redis</span><span class="card-category-list-count">15</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/zookeeper/"><span class="card-category-list-name">zookeeper</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="card-category-list-name">分布式</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/"><span class="card-category-list-name">网络</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="card-category-list-name">面试</span><span class="card-category-list-count">4</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/docker/" style="font-size: 1.1em; color: #999">docker</a> <a href="/tags/goframe/" style="font-size: 1.1em; color: #999">goframe</a> <a href="/tags/golang/" style="font-size: 1.5em; color: #99a9bf">golang</a> <a href="/tags/redis/" style="font-size: 1.5em; color: #99a9bf">redis</a> <a href="/tags/zab/" style="font-size: 1.1em; color: #999">zab</a> <a href="/tags/zookeeper/" style="font-size: 1.34em; color: #99a3b0">zookeeper</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 1.18em; color: #999ca1">中间件</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 1.26em; color: #999fa8">内存管理</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 1.26em; color: #999fa8">分布式</a> <a href="/tags/%E5%88%87%E7%89%87/" style="font-size: 1.1em; color: #999">切片</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 1.26em; color: #999fa8">并发</a> <a href="/tags/%E6%8C%87%E9%92%88/" style="font-size: 1.1em; color: #999">指针</a> <a href="/tags/%E7%BB%93%E6%9E%84%E4%BD%93/" style="font-size: 1.1em; color: #999">结构体</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.1em; color: #999">网络</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.42em; color: #99a6b7">面试</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/11/"><span class="card-archive-list-date">十一月 2022</span><span class="card-archive-list-count">5</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/10/"><span class="card-archive-list-date">十月 2022</span><span class="card-archive-list-count">35</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">40</div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">122.6k</div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2022-11-01T14:19:05.223Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/6833939bly1gipet8c1a2j20zk0m8kct.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By caicai</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function subtitleType () {
  getScript('https://sdk.jinrishici.com/v2/browser/jinrishici.js').then(() => {
    jinrishici.load(result =>{
      if (true) {
        const sub = []
        const content = result.data.content
        sub.unshift(content)
        window.typed = new Typed('#subtitle', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('subtitle').innerHTML = result.data.content
      }
    })
  })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div><script type="text/javascript" src="/js/hourse.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script></div></body></html>